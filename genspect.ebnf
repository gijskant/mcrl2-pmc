//This is an EBNF description for the syntax of the GenSpect language.
//In this description:
//- the symbols <Whitespace> and <Comment> are layout symbols and may occur
//  between every other EBNF element;
//- the symbol <Keyword> lists all the keywords that are used in the
//  description and that may never be used as an identifier;
//- the symbol <Spec> is the start symbol.

//whitespace
Whitespace   ::= "\s"

//comment
Comment      ::= "%" ~[\n]* "\n"

//keywords
Keyword      ::= kwSpec | kwProcExpr | kwSortExpr | kwDataExpr
kwSpec       ::= "sort" | "cons" | "map" | "var" | "eqn" | "act" | "proc" | "init"
kwProcExpr   ::= "delta" | "tau" | "sum" | "restrict" | "allow" | "hide" | "rename" | "comm"
kwSortExpr   ::= "Bool" | "Pos" | "Nat" | "Int" | "List" | "Set" | "Bag"
kwDataExpr   ::= "true" | "false" | "whr" | "end" | "lambda" | "forall" | "exists" | "div" | "mod" | "in"

//identifier
Id           ::= [a-zA-Z\_][a-zA-Z0-9\_]*

//comma-separated list of identifiers
Ids          ::= Id ("," Id)*

//multiaction identifier
MAId         ::= Id ("|" Id)*

//set of multiaction identifiers
MAIdsSet     ::= "{" ( MAId ("," MAId)* )? "}"

//communication expression
CommExpr     ::= MAId ("->" Id)?

//set of communication expressions
CommExprSet  ::= "{" ( CommExpr ("," CommExpr)* )? "}"

//renaming expression
RenExpr      ::= Id "->" Id

//set of renaming expressions
RenExprSet   ::= "{" ( RenExpr ("," RenExpr)* )? "}"

//constructor declaration
ConstrDecl   ::= Id ("(" ProjDecls ")")? ("?" Id)?

//projection declaration
ProjDecl     ::= (Id ":")?  SortExpr ("#" SortExpr)*

//comma-separated list of projection declarations
ProjDecls    ::= ProjDecl ("," ProjDecl)*

//identifier declaration
IdDecl       ::= Id ":" SortExpr

//declaration of 1 or more identifiers of the same sort
IdDecls      ::= Ids ":" SortExpr

//comma-separated list of complex data expressions
CDataExprs   ::= CDataExpr ("," CDataExpr)*

//argument of a data expression
DataArg      ::= "(" CDataExprs ")"

//bag enumeration element
BagEnumElt   ::= CDataExpr ":" CDataExpr

//comma-separated list of bag enumeration elements
BagEnumElts  ::= BagEnumElt ("," BagEnumElt)*

//sort expression
SortExpr     ::= "Bool" | "Pos" | "Nat" | "Int"           //predefined sort
               | "List" "(" SortExpr ")"                  //list sort
               | "Set" "(" SortExpr ")"                   //set sort
               | "Bag" "(" SortExpr ")"                   //bag sort
               | Id                                       //declared sort
               | SortExpr ("#" SortExpr)* "->" SortExpr   //higher-order sort
               | "(" SortExpr ")"                         //parenthesized sort expression

//data expression
DataExpr     ::= "0" | ("-"? [1-9] [0-9]*)                //number
               | "true" | "false"                         //true,false
               | Id DataArg*                              //function application (possibly higher-order)
               | "[" "]"                                  //empty list
               | "[" CDataExprs "]"                       //list enumeration
               | "{" "}"                                  //empty set/bag
               | "{" CDataExprs "}"                       //set enumeration
               | "{" BagEnumElts "}"                      //bag enumeration 
               | "{" IdDecl "|" CDataExpr "}"             //set/bag comprehension
               | "(" CDataExpr ")"                        //parenthesized complex data expression
               | "!" DataExpr                             //logical negation, set complement
               | "-" DataExpr                             //arithmetic negation
               | "#" DataExpr                             //list/set/bag size

//complex data expression
CDataExpr    ::= DataExpr                                 //data expression
               | CDataExpr "whr" CDataExprs "end"         //where clause
               | "lambda" IdDecl "." CDataExpr            //lambda abstraction
               | "(" "lambda" IdDecl "." CDataExpr ")" DataArg+ //lambda abstraction plus application
               | "forall" IdDecl "." CDataExpr            //universal quantification
               | "exists" IdDecl "." CDataExpr            //existential quantification
               | CDataExpr "." CDataExpr                  //list element at position
               | "(" CDataExpr "." CDataExpr ")" DataArg+ //list element at position plus application
               | CDataExpr "*"   CDataExpr                //multiplication, set intersection, (associative)
               | CDataExpr "div" CDataExpr                //integer div
               | CDataExpr "mod" CDataExpr                //integer mod
               | CDataExpr "\\"  CDataExpr                //set difference
               | CDataExpr "+"   CDataExpr                //addition, set union (associative)
               | CDataExpr "-"   CDataExpr                //subtraction
               | CDataExpr "<"   CDataExpr                //less than, proper subset/subbag
               | CDataExpr ">"   CDataExpr                //greater than
               | CDataExpr "<="  CDataExpr                //less than or equal, subset/subbag
               | CDataExpr ">="  CDataExpr                //greater than or equal
               | CDataExpr "in"  CDataExpr                //element test
               | CDataExpr "|>"  CDataExpr                //list cons (right associative)
               | CDataExpr "<|"  CDataExpr                //list snoc (left associative)
               | CDataExpr "++"  CDataExpr                //list concatenation (associative)
               | CDataExpr "=="  CDataExpr                //equality (associative)
               | CDataExpr "!="  CDataExpr                //disequality (associative)
               | CDataExpr "&&"  CDataExpr                //conjunction (associative)
               | CDataExpr "||"  CDataExpr                //disjunction (associative)
               | CDataExpr "=>"  CDataExpr                //implication
               | "(" CDataExpr ")"                        //parenthesized complex data expression

//process expression
ProcExpr     ::= Id DataArg?                              //action or process reference
               | "delta"                                  //deadlock
               | "tau"                                    //internal action
               | "sum" "(" IdDecl "," ProcExpr ")"        //summation
               | "restrict" "(" MAIdsSet "," ProcExpr ")" //restriction AKA encapsulation
               | "allow" "(" MAIdsSet "," ProcExpr ")"    //allow AKA nabla 
               | "hide" "(" MAIdsSet "," ProcExpr ")"     //hiding
               | "rename" "(" RenExprSet "," ProcExpr ")" //renaming
               | "comm" "(" CommExprSet "," ProcExpr ")"  //communication
               | ProcExpr "|" ProcExpr                    //synchronisation (associative)
               | ProcExpr "@" DataExpr                    //timed expression
               | ProcExpr "." ProcExpr                    //sequential (associative)
               | ProcExpr "<<" ProcExpr                   //bounded initialisation (left associative)
               | ProcExpr "||" ProcExpr                   //parallel (associative)
               | ProcExpr "||_" ProcExpr                  //left merge (left associative)
               | DataExpr "->" ProcExpr                   //conditional
               | ProcExpr "+" ProcExpr                    //choice (associative)
               | "(" ProcExpr ")"                         //parenthesized process expression

//sort specification
SortSpec     ::= "sort" SortDecl+

//sort declaration
SortDecl     ::= Id                                       //standard sort
               | Id "=" SortExpr                          //sort expression
               | Id "=" ConstrDecl ("|" ConstrDecl)*      //structured sort

//operation specification
OpSpec       ::= ("cons" | "map") OpDecl+

//operation declaration
OpDecl       ::= IdDecls

//equation specification
EqnSpec      ::= ("var" IdDecls+)? "eqn" EqnDecl+

//equation declaration
EqnDecl      ::= CDataExpr "=" CDataExpr

//action specification
ActSpec      ::= "act" ActDecl+

//action declaration
ActDecl      ::= Ids (":" SortExpr ("#" SortExpr)* )?

//process specification
ProcSpec     ::= "proc" ProcDecl+

//process declaration
ProcDecl     ::= Id ("(" IdDecls ("," IdDecls)* ")")? "=" ProcExpr

//initialisation
Init         ::= "init" ProcExpr

//specification
Spec         ::= (SortSpec | OpSpec | EqnSpec | ActSpec | ProcSpec | Init)+
