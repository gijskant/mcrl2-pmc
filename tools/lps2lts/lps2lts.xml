<refentry id="lps2lts">
 <info>
  <date>2005-2007</date>
 </info>

<refmeta>
  <refentrytitle>lps2lts</refentrytitle>
  <manvolnum>1</manvolnum>
  <refmiscinfo class="source">lps2lts</refmiscinfo>
  <refmiscinfo class="version"></refmiscinfo>
  <refmiscinfo class="manual">User Commands</refmiscinfo>
</refmeta>

<refnamediv>
  <refname>lps2lts</refname>
  <refpurpose>generate state space of an LPS</refpurpose>
</refnamediv>

<refsynopsisdiv>
  <cmdsynopsis>
    <command>&lps2lts;</command>
    <arg choice="plain" rep="repeat"><arg choice="opt">&option;</arg></arg>
    <arg choice="opt">&infile;
    <arg choice="opt">&outfile;</arg>
    </arg>
  </cmdsynopsis>
</refsynopsisdiv>

<refsect1>
  <title>Description</title>
  <para>
    The &lps2lts; tool generates a state space of the linear process specification (LPS) in &infile; and
    saves the result to &outfile;. If &outfile; is not present,
    the state space is not stored.
  </para>
  <para>
    The format of &outfile; is determined by its extension (unless it is specified
     by an option). If the extension is unknown, the svc format will be used.
  </para>
</refsect1>

<refsect1>
<title>Options</title>
<para>
Mandatory arguments to long options are also mandatory to short options.
  <variablelist>
  <varlistentry>
    <term>&opt_h;</term>
    <term>&opt_help;</term>
    <listitem>
      <para>
        Display help message and terminate.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_version;</term>
    <listitem>
      <para>
        Display version information and terminate.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_q;</term>
    <term>&opt_quiet;</term>
    <listitem>
      <para>
        Do not display any unrequested information.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_v;</term>
    <term>&opt_verbose;</term>
    <listitem>
      <para>
        Display concise intermediate messages. This includes detailed status of
        the generation process. Once a level (in terms of breadth-first search)
        is completed, a message stating this is printed. After exploration of
        every 1000 states the following information is printed: current level,
        states explored, transitions explored, states seen. A state is explored
        if all its outgoing transitions have been explored.  A state is seen if
        (at least) one of the transitions leading to it has been explored.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_d;</term>
    <term>&opt_debug;</term>
    <listitem>
      <para>
        Display detailed intermediate messages.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_f;</term>
    <term>&opt_freevar;</term>
    <listitem>
      <para>
        Do not replace free variables in the LPS with dummy values. (See also &opt_dummy;.)
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_y;</term>
    <term>&opt_dummy;</term>
    <listitem>
      <para>
        Replace free variables in the LPS with dummy values (default). Free
        variables indicate that the behaviour of the LPS does not depend on the
        actual value of such a variable. Not replacing these variables can
        result in states containing free variables. Currently, &lps2lts;
        considers each free variable to be different from any other (value or
        variable) and therefore substituting a default dummy value for such
        variables can reduce the generated state space.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_u;</term>
    <term>&opt_unused-data;</term>
    <listitem>
      <para>
        Do not remove unused parts of the data specification.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_c;</term>
    <term>&opt_vector;</term>
    <listitem>
      <para>
        Store states in memory in a vector (fastest, default). 
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_r;</term>
    <term>&opt_tree;</term>
    <listitem>
      <para>
        Store states in memory in a tree (for memory efficiency).
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_b;[&num;]</term>
    <term>&opt_bit_hash;[=&num;]</term>
    <listitem>
      <para>
        Make use of bit hashing to store states and store at most &num; states.
        This means that instead of keeping a full record of all states that
        have been visited, a bit array is used that indicate whether or not a
        hash of a state has been seen before. Although this means that this
        option may cause states to be mistaken for others (because they are
        mapped to the same hash), it can be useful to explore very large
        state spaces that are otherwise not explorable.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_l;&num;</term>
    <term>&opt_max;=&num;</term>
    <listitem>
      <para>
        Explore at most &num; states. After exploring of &num; states
        &lps2lts; will stop, having generated a partial state space.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_todo_max;=&num;</term>
    <listitem>
      <para>
        Keep at most &num; states in todo lists; this option is only relevant
        for breadth-first search with bithashing, where &num; is the maximum
        number of states per level, and for depth first, where &num; is the
        maximum depth.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_D;</term>
    <term>&opt_deadlock;</term>
    <term>&opt_deadlock-detect;</term>
    <listitem>
      <para>
        Detect deadlocks (i.e. for every deadlock a message is
        printed). A deadlock is a state from which no transitions are
        possible.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_a;&name;*</term>
    <term>&opt_action;=&name;*</term>
    <listitem>
      <para>
        Detect action names from the list &name;*, which is a comma separated
        list of action names. A message is printed for every occurrence of one
        of these action names. Transitions containing such an occurrence are
        those which contain an action with an action name from the list.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_t;[&num;]</term>
    <term>&opt_trace;[=&num;]</term>
    <listitem>
      <para>
        Write a shortest trace to each state that is reached with an action
        from &name;* from option &opt_a;/&opt_action; or is a deadlock detected
        with &opt_D;/&opt_deadlock; to a file. No more than &num; traces will
        be written. If &num; is not supplied the maximum number of traces is
        10.
      </para>
      <para>
        For each trace that is to be written a unique file with extension .trc
        (trace) will be created containing a shortest trace from the initial
        state to the deadlock state. The traces can be pretty printed and
        converted to other formats using &tracepp-lnk;.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_error-trace;</term>
    <listitem>
      <para>
	If an error occurs during exploration, a trace to the state that could
	not be explored is saved to a trace file.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_C;[&name;]</term>
    <term>&opt_confluence;[=&name;]</term>
    <listitem>
      <para>
         Apply on-the-fly confluence reduction where action &name; is
         considered to denote a confluent silent step. If &name; is not
         supplied, tau is assumed to be the confluent silent step.
      </para>
    </listitem>
  </varlistentry>
  
  <varlistentry>
    <term>&opt_s;&name;</term>
    <term>&opt_strategy;=&name;</term>
    <listitem>
      <para>
         Use strategy &name; to explore the state space. The following strategies are available.
         <variablelist>
           <varlistentry>
             <term>b, breadth</term>
             <listitem>
               <para>
                 breadth-first search (default)
               </para>
             </listitem>
           </varlistentry>
           <varlistentry>
             <term>d, depth</term>
             <listitem>
               <para>
                 depth-first search
               </para>
             </listitem>
           </varlistentry>
           <varlistentry>
             <term>r, random</term>
             <listitem>
               <para>
                 random simulation
               </para>
             </listitem>
           </varlistentry>
         </variablelist>
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_R;&name;</term>
    <term>&opt_rewriter;=&name;</term>
    <listitem>
      <para>
         Use rewriter &name; (see &rewriter-lnk; manual page). &lps2lts; makes
         heavy use of a term rewriting engine to manipulate with the data term
         of the LPS and therefore the choice of the rewriter can heavily
         influence performance.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_aut;</term>
    <listitem>
      <para>
        Force &outfile; to be written in the AUT format. This implies the
        option &opt_no-info; (see below).
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_svc;</term>
    <listitem>
      <para>
         Force &outfile; to be written in the SVC format.
      </para>
    </listitem>
  </varlistentry>

   <varlistentry>
    <term>&opt_no-info;</term>
    <listitem>
      <para>
        Do not add state information to &outfile;. Without this option
        &lps2lts; adds state vector to the state space. This option causes this
        information to be discarded and states are only indicated by a sequence
        number. Explicit state information is useful for visualisation
        purposes, for instance, but can cause the &outfile; to grow
        considerably. Note that this option is implicit when writing in the AUT
        format.
      </para>
    </listitem>
  </varlistentry>
  
  <varlistentry>
    <term>&opt_init_tsize;=&num;</term>
    <listitem>
      <para>
         Set the initial size of the internally used hash tables. The default
         size is 10000.
      </para>
    </listitem>
  </varlistentry>
  </variablelist>
</para>
</refsect1>

<refsect1>
<title>Author</title>
<para>
  Written by Muck van Weerdenburg. &bugreport;
</para>
</refsect1>

</refentry>
