<refentry id="lpsconfcheck">
 <info>
  <date>2005-2007</date>
 </info>

<refmeta>
  <refentrytitle>lpsconfcheck</refentrytitle>
  <manvolnum>1</manvolnum>
  <refmiscinfo class="source">lpsconfcheck</refmiscinfo>
  <refmiscinfo class="version"></refmiscinfo>
  <refmiscinfo class="manual">User Commands</refmiscinfo>
</refmeta>

<refnamediv>
  <refname>lpsconfcheck</refname>
  <refpurpose>mark confluent &tau;-summands of an LPS</refpurpose>
</refnamediv>

<refsynopsisdiv>
  <cmdsynopsis>
    <command>&lpsconfcheck;</command>
    <arg choice="plain" rep="repeat"><arg choice="opt">&option;</arg></arg>
    <arg choice="opt">&infile;<arg choice="opt">&outfile;</arg></arg>
  </cmdsynopsis>
</refsynopsisdiv>

<refsect1>
  <title>Description</title>
  <para>
    The &lpsconfcheck; tool checks which &tau;-summands of the mCRL2 LPS as found
    in &infile; are confluent and marks them by renaming their &tau;-actions to &ctau;. The
    resulting LPS is written to the file named &outfile;.
  </para>

  <para>
    If &infile; is not specified, the LPS is read from &cstdin;. If &outfile; is
    not specified, the resulting LPS is written to &cstdout;.
  </para>

  <para>
    Given an LPS,
    <literallayout>
      P(d: D) = ...
              + sum ei: Ei. ci(d, ei) -> ai(fi(d, ei)) . P(gi(d, ei))
              + ...
              + sum ej: Ej. cj(d, ej) -> tau . P(gj(d, ej))
              + ...;
    </literallayout>
    &tau;-summand <literal>j</literal> is confluent with summand <literal>i</literal> if the following condition holds
    for all <literal>d: D</literal>, for all <literal>ei: Ei</literal> and for all <literal>ej: Ej</literal>:
    <literallayout>
      (inv(d) /\ ci(d, ei) /\ cj(d, ej))
      =>
      (ci(gj(d, ej), ei) /\ cj(gi(d, ei), ej) /\ fi(d, ei) == fi(gj(d, ej), ei) /\ gi(gj(d, ej), ei) == gj(gi(d, ei), ej))
    </literallayout>
    where &inv; is the invariant specified using the option &opt_invariant;. In case <literal>ai</literal>
    is also a &tau;-action, this formula can be weakened to the following:
    <literallayout>
      (inv(d) /\ ci(d, ei) /\ cj(d, ej))
      =>
      (gi(d, ei) == gj(d, ej) \/ (ci(gj(d, ej), ei) /\ cj(gi(d, ei), ej) /\ gi(gj(d, ej), ei) == gj(gi(d, ei), ej)))
    </literallayout>
    If the option &opt_invariant; is not used, the invariant is equal to &const_true;.
  </para>

  <para>
    The tool will generate these confluence conditions for all
    &tau;-summands
    and tries to prove that they are tautologies using a BDD based prover for
    propositional formulas. In some cases &lpsconfcheck; indicates that a
    &tau;-summand is not confluent
    even though it is. The option &opt_verbose; gives insight into what the prover is
    doing and can be used to see if rewrite rules have to be added to the specification
    in order to enable the prover to determine that certain condition are indeed
    tautologies.
  </para>

  <para>
    In some cases it may be useful to use an SMT solver to assist the prover. The SMT
    solver can further reduce BDDs by removing inconsistent paths. A specific SMT solver
    can be chosen using the option &opt_smt_solver;=&solver;. Either
  the SMT solver &solver_ario-lnk; or &solver_cvc_lite-lnk; can be used.
  To use one of these solvers, the directory containing the
    corresponding executable must be in the path.
  </para>

  <para>
    The tool can determine whether two summands are confluent in three ways and will
    indicate which of the methods was used while proving confluence. The three ways
    of determining confluence are as follows:
    <itemizedlist spacing='compact'>
      <listitem>
        <para>
          If summand number 1 has been proven confluent with summand number 2, summand
          number 2 is also confluent with summand number 1. This method of checking
          confluence is called checking confluence by symmetry. If two summands are
          confluent by symmetry, &lpsconfcheck; indicates this by printing a dot ('.').
        </para>
      </listitem>
      <listitem>
        <para>
          Another way of checking the confluence of two summands is determining whether
          the two summands are syntactically disjoint. Two summands are syntactically
          disjoint if the following holds:
          <itemizedlist spacing='compact'>
            <listitem>
              <para>
                The set of variables used by one summand is disjoint from the set
                of variables changed by the other summand and vice versa.
              </para>
            </listitem>
            <listitem>
              <para>
                The set of variables changed by one summand is disjoint from the set
                of variables changed by the other summand.
              </para>
            </listitem>
          </itemizedlist>
          If two summands are confluent because of syntactic disjointness, &lpsconfcheck;
          indicates this by printing a colon (':').
        </para>
      </listitem>
      <listitem>
        <para>
          The most time consuming way of checking the confluence of two summands is
          generating the confluence condition and then checking if this condition is a
          tautology using the prover. If two summands are proven confluent using the
          prover, &lpsconfcheck; indicates this by printing a plus sign ('+').
          If the option &opt_generate_invariants; is used, the &lpsconfcheck; tool will try to prove
          that the reduced confluence condition is an invariant of the LPS, in case the confluence condition
          is not a tautology. If the reduced confluence condition is indeed an invariant, the
          two summands are proven confluent. &lpsconfcheck; indicates this by printing an 'i'.
        </para>
      </listitem>
    </itemizedlist>
  </para>
  <para>
    If there already is an action named &ctau; present in the LPS as found in &infile;, an error will be reported.
  </para>
</refsect1>

<refsect1>
<title>Options</title>
<para>
  Mandatory arguments to long options are mandatory for short options too.
  <variablelist>
  <varlistentry>
    <term>&opt_i;</term>
    <term>&opt_invariant;=&invariant;</term>
    <listitem>
      <para>
        Use the formula in mCRL2 format as
        found in &invariant; as invariant
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_g;</term>
    <term>&opt_generate_invariants;</term>
    <listitem>
      <para>
        Try to prove that the reduced confluence
        condition is an invariant of the LPS, in case
        the confluence condition is not a tautology.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_s;</term>
    <term>&opt_summand;=&num;</term>
    <listitem>
      <para>
        Check the summand with number &num; only
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_n;</term>
    <term>&opt_no_check;</term>
    <listitem>
      <para>
        Do not check if the invariant holds before
        checking for confluence
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_m;</term>
    <term>&opt_no_marking;</term>
    <listitem>
      <para>
        Do not mark the confluent &tau;-summands.
        Since there are no changes made to the LPS,
        nothing is written to &outfile;
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_a;</term>
    <term>&opt_check_all;</term>
    <listitem>
      <para>
        Check the confluence of the &tau;-summands regarding all other summands, instead of
        continuing with the next &tau;-summand as soon as a summand is
        encountered that is not confluent with the current &tau;-summand
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_c;</term>
    <term>&opt_counter_example;</term>
    <listitem>
      <para>
        Give a valuation for which the confluence
        condition does not hold, in case the
        encountered condition is neither a
        contradiction nor a tautolgy
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_p;</term>
    <term>&opt_print_dot;</term>
    <listitem>
      <para>
        Save a .dot file of the resulting BDD in
        case two summands cannot be proven
        confluent. PREFIX will be used as prefix
        of the output files
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_h;</term>
    <term>&opt_help;</term>
    <listitem>
      <para>
        Display help message and terminate
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_version;</term>
    <listitem>
      <para>
        Display version information and terminate
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_q;</term>
    <term>&opt_quiet;</term>
    <listitem>
      <para>
        Do not display warning messages
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_v;</term>
    <term>&opt_verbose;</term>
    <listitem>
      <para>
        Display concise intermediate messages
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_d;</term>
    <term>&opt_debug;</term>
    <listitem>
      <para>
        Display detailed intermediate messages
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_r;</term>
    <term>&opt_rewrite_strategy;=&strategy;</term>
    <listitem>
      <para>
        Use the specified &strategy; as rewrite strategy (see &rewriter-lnk;
        manual page).  By default, &strat_jitty_string; is used
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_t;</term>
    <term>&opt_time_limit;=&seconds;</term>
    <listitem>
      <para>
        Spend at most the specified number of &seconds; on proving
        a single formula
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_z;</term>
    <term>&opt_smt_solver;=&solver;</term>
    <listitem>
      <para>
        Use the specified &solver; to remove inconsistent paths from BDDs:
        <itemizedlist spacing='compact'>
          <listitem>
            <para>
              &solver_ario_string; for the SMT solver Ario
            </para>
          </listitem>
          <listitem>
            <para>
              &solver_cvc_lite_string; for the SMT solver CVC Lite
            </para>
          </listitem>
        </itemizedlist>
        By default, no path elimination is applied
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_o;</term>
    <term>&opt_induction;</term>
    <listitem>
      <para>
        Apply induction on lists
      </para>
    </listitem>
  </varlistentry>

  </variablelist>
</para>
</refsect1>

<refsect1>
<title>Author</title>
<para>
  Written by Luc Engelen. &bugreport;
</para>
</refsect1>

</refentry>
