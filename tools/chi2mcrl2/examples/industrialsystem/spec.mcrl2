sort s0  =  List(Nat);

map es, se: Nat;
eqn es=0;
eqn se=1;
act Send_Nat, Recv_Nat, Comm_Nat: Nat#Nat#Nat;
act Send_s0, Recv_s0, Comm_s0: Nat#Nat#s0;

map take_s0: s0#Nat ->s0;
var xs :s0;
    n  :Nat;
    x  :Nat;
eqn take_s0(xs, 0)= [];
    n>0 -> take_s0( x |> xs, n ) = x |> take_s0(xs , Int2Nat(n - 1 ));

map drop_s0: s0#Nat ->s0;
var xs :s0;
    n  :Nat;
    x  :Nat;
eqn drop_s0(xs, 0)= xs;
    n>0 -> drop_s0( x |> xs , n ) = drop_s0(xs , Int2Nat(n - 1 ));

act Terminator, skip; 
 
proc 
  Spec(s: Nat, x: Nat, xs: s0, es: Nat, es_hash: Nat, se: Nat, se_hash: Nat, state_0: Nat)= 
	  ( state_0 == 0) -> skip.Spec(s, x, [], es, es_hash, se, se_hash, 1) <> delta
	+ ( state_0 == 1) -> sum es0:Nat. Recv_Nat(es, es_hash, es0).Spec(s, es0, xs, es, es_hash, se, se_hash, 2) <> delta
	+ ( state_0 == 2) -> skip.Spec(s, x, xs ++ [x], es, es_hash, se, se_hash, 1) <> delta
	+ ( #xs>=s && state_0 == 1) -> Send_s0(se, se_hash, take_s0(xs , s)).Spec(s, x, xs, es, es_hash, se, se_hash, 1) <> delta
	+ ( state_0 == 4) -> skip.Spec(s, x, drop_s0(xs , s), es, es_hash, se, se_hash, 1) <> delta
	;

proc 
  Din(es: Nat, es_hash: Nat, state_0: Nat)= 
	  ( state_0 == 0) -> Send_Nat(es, es_hash, 1).Din(es, es_hash, 0) <> delta
	;

proc 
  Dout(store: s0, se: Nat, se_hash: Nat, state_0: Nat)= 
	  ( state_0 == 0) -> sum se0:s0. Recv_s0(se, se_hash, se0).Dout(se0, se, se_hash, 0) <> delta
	;

init 
 block({Send_Nat, Recv_Nat,Send_s0, Recv_s0},
  hide({skip},
   allow({ Terminator, skip,Send_Nat, Recv_Nat, Comm_Nat,Send_s0, Recv_s0, Comm_s0},
    comm({Send_Nat| Recv_Nat->Comm_Nat,Send_s0| Recv_s0->Comm_s0},
     Spec(10, 0, [], es, 0, se, 0, 0) || Din(es, 0, 0) || Dout([], se, 0, 0)
    )
   )
  )
 );
