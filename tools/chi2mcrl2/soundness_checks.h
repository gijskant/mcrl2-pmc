// Author(s): Wieger Wesselink
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//
/// \file mcrl2/basic/detail/soundness_checks.h
/// \brief Add your file description here.

#ifndef MCRL2_BASIC_DETAIL_SOUNDNESS_CHECKS_H
#define MCRL2_BASIC_DETAIL_SOUNDNESS_CHECKS_H

// This file contains soundness checks for LPS terms.
// N.B. This file is automatically generated!

#include <iostream>
#include "libstruct.h"
#include "libstruct_core.h"
#include "atermpp/aterm.h"
#include "atermpp/aterm_list.h"
#include "atermpp/aterm_appl.h"
#include "atermpp/aterm_traits.h"


namespace lps {

namespace detail {

using atermpp::aterm;
using atermpp::aterm_list;
using atermpp::aterm_appl;
using atermpp::aterm_traits;

// checks
// 1) if term t satisfies the predicate f
template <typename Term, typename CheckFunction>
bool check_term_argument(Term t, CheckFunction f)
{
  return f(t);
}

// checks
// 1) if term t is a list,
// 2) if the list has the proper minimum size
// 3) if all elements of the list satisfy the predicate f
template <typename Term, typename CheckFunction>
bool check_list_argument(Term t, CheckFunction f, unsigned int minimum_size)
{
  aterm term(aterm_traits<Term>::term(t));
  if (t.type() != AT_LIST)
    return false;
  aterm_list l(term);
  if (l.size() < minimum_size)
    return false;
  for (aterm_list::iterator i = l.begin(); i != l.end(); ++i)
  {
    if (!f(*i))
      return false;
  }
  return true;
}

template <typename Term>
bool check_rule_String(Term t)
{
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (a.size() > 0)
    return false;
  return true;
}

template <typename Term>
bool check_rule_NumberString(Term t)
{
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (a.size() > 0)
    return false;
  return true;
}

//--- begin generated code
template <typename Term> bool check_rule_SpecChi(Term t);
template <typename Term> bool check_rule_DecSpec(Term t);
template <typename Term> bool check_rule_VarSpec(Term t);
template <typename Term> bool check_rule_VarExpID(Term t);
template <typename Term> bool check_rule_VarID(Term t);
template <typename Term> bool check_rule_TypeExp(Term t);
template <typename Term> bool check_rule_TypeID(Term t);
template <typename Term> bool check_rule_Expr(Term t);
template <typename Term> bool check_rule_StatementSpec(Term t);
template <typename Term> bool check_rule_Statement(Term t);
template <typename Term> bool check_term_UnaryExpression(Term t);
template <typename Term> bool check_term_Assignment(Term t);
template <typename Term> bool check_term_Nil(Term t);
template <typename Term> bool check_term_Skip(Term t);
template <typename Term> bool check_term_Expression(Term t);
template <typename Term> bool check_term_DataVarID(Term t);
template <typename Term> bool check_term_StatementSpec(Term t);
template <typename Term> bool check_term_DataVarExprID(Term t);
template <typename Term> bool check_term_VarSpec(Term t);
template <typename Term> bool check_term_BinaryExpression(Term t);
template <typename Term> bool check_term_ProcSpec(Term t);
template <typename Term> bool check_term_Type(Term t);

template <typename Term>
bool check_rule_SpecChi(Term t)
{
  return    check_term_ProcSpec(t);
}

template <typename Term>
bool check_rule_DecSpec(Term t)
{
  return    check_rule_VarSpec(t)
         || check_term_Nil(t);
}

template <typename Term>
bool check_rule_VarSpec(Term t)
{
  return    check_term_VarSpec(t);
}

template <typename Term>
bool check_rule_VarExpID(Term t)
{
  return    check_term_DataVarExprID(t)
         || check_rule_VarID(t);
}

template <typename Term>
bool check_rule_VarID(Term t)
{
  return    check_term_DataVarID(t);
}

template <typename Term>
bool check_rule_TypeExp(Term t)
{
  return    check_rule_TypeID(t);
}

template <typename Term>
bool check_rule_TypeID(Term t)
{
  return    check_term_Type(t);
}

template <typename Term>
bool check_rule_Expr(Term t)
{
  return    check_term_Expression(t)
         || check_term_UnaryExpression(t)
         || check_term_BinaryExpression(t);
}

template <typename Term>
bool check_rule_StatementSpec(Term t)
{
  return    check_term_StatementSpec(t);
}

template <typename Term>
bool check_rule_Statement(Term t)
{
  return    check_term_Skip(t)
         || check_term_Assignment(t);
}

// UnaryExpression(String, Expr, TypeID)
template <typename Term>
bool check_term_UnaryExpression(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsUnaryExpression(a))
    return false;

  // check the children
  if (a.size() != 3)
    return false;
#ifndef LPS_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_String<aterm>))
    {
      std::cerr << "check_rule_String" << std::endl;
      return false;
    }
  if (!check_term_argument(a(1), check_rule_Expr<aterm>))
    {
      std::cerr << "check_rule_Expr" << std::endl;
      return false;
    }
  if (!check_term_argument(a(2), check_rule_TypeID<aterm>))
    {
      std::cerr << "check_rule_TypeID" << std::endl;
      return false;
    }
#endif // LPS_NO_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// Assignment(Expr+, Expr+)
template <typename Term>
bool check_term_Assignment(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsAssignment(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifndef LPS_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(a(0), check_rule_Expr<aterm>, 1))
    {
      std::cerr << "check_rule_Expr" << std::endl;
      return false;
    }
  if (!check_list_argument(a(1), check_rule_Expr<aterm>, 1))
    {
      std::cerr << "check_rule_Expr" << std::endl;
      return false;
    }
#endif // LPS_NO_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// Nil()
template <typename Term>
bool check_term_Nil(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsNil(a))
    return false;

  // check the children
  if (a.size() != 0)
    return false;

  return true;
}

// Skip()
template <typename Term>
bool check_term_Skip(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsSkip(a))
    return false;

  // check the children
  if (a.size() != 0)
    return false;

  return true;
}

// Expression(String, TypeID)
template <typename Term>
bool check_term_Expression(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsExpression(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifndef LPS_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_String<aterm>))
    {
      std::cerr << "check_rule_String" << std::endl;
      return false;
    }
  if (!check_term_argument(a(1), check_rule_TypeID<aterm>))
    {
      std::cerr << "check_rule_TypeID" << std::endl;
      return false;
    }
#endif // LPS_NO_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// DataVarID(String+, TypeExp)
template <typename Term>
bool check_term_DataVarID(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsDataVarID(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifndef LPS_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(a(0), check_rule_String<aterm>, 1))
    {
      std::cerr << "check_rule_String" << std::endl;
      return false;
    }
  if (!check_term_argument(a(1), check_rule_TypeExp<aterm>))
    {
      std::cerr << "check_rule_TypeExp" << std::endl;
      return false;
    }
#endif // LPS_NO_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// StatementSpec(Statement+)
template <typename Term>
bool check_term_StatementSpec(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsStatementSpec(a))
    return false;

  // check the children
  if (a.size() != 1)
    return false;
#ifndef LPS_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(a(0), check_rule_Statement<aterm>, 1))
    {
      std::cerr << "check_rule_Statement" << std::endl;
      return false;
    }
#endif // LPS_NO_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// DataVarExprID(VarID, Exp)
template <typename Term>
bool check_term_DataVarExprID(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsDataVarExprID(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifndef LPS_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_VarID<aterm>))
    {
      std::cerr << "check_rule_VarID" << std::endl;
      return false;
    }
  if (!check_term_argument(a(1), check_rule_Exp<aterm>))
    {
      std::cerr << "check_rule_Exp" << std::endl;
      return false;
    }
#endif // LPS_NO_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// VarSpec(VarExpID+)
template <typename Term>
bool check_term_VarSpec(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsVarSpec(a))
    return false;

  // check the children
  if (a.size() != 1)
    return false;
#ifndef LPS_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(a(0), check_rule_VarExpID<aterm>, 1))
    {
      std::cerr << "check_rule_VarExpID" << std::endl;
      return false;
    }
#endif // LPS_NO_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// BinaryExpression(String, Expr, Expr, TypeID)
template <typename Term>
bool check_term_BinaryExpression(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsBinaryExpression(a))
    return false;

  // check the children
  if (a.size() != 4)
    return false;
#ifndef LPS_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_String<aterm>))
    {
      std::cerr << "check_rule_String" << std::endl;
      return false;
    }
  if (!check_term_argument(a(1), check_rule_Expr<aterm>))
    {
      std::cerr << "check_rule_Expr" << std::endl;
      return false;
    }
  if (!check_term_argument(a(2), check_rule_Expr<aterm>))
    {
      std::cerr << "check_rule_Expr" << std::endl;
      return false;
    }
  if (!check_term_argument(a(3), check_rule_TypeID<aterm>))
    {
      std::cerr << "check_rule_TypeID" << std::endl;
      return false;
    }
#endif // LPS_NO_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// ProcSpec(DecSpec+, StatementSpec+)
template <typename Term>
bool check_term_ProcSpec(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsProcSpec(a))
    return false;

  // check the children
  if (a.size() != 2)
    return false;
#ifndef LPS_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_list_argument(a(0), check_rule_DecSpec<aterm>, 1))
    {
      std::cerr << "check_rule_DecSpec" << std::endl;
      return false;
    }
  if (!check_list_argument(a(1), check_rule_StatementSpec<aterm>, 1))
    {
      std::cerr << "check_rule_StatementSpec" << std::endl;
      return false;
    }
#endif // LPS_NO_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}

// Type(String)
template <typename Term>
bool check_term_Type(Term t)
{
  // check the type of the term
  aterm term(aterm_traits<Term>::term(t));
  if (term.type() != AT_APPL)
    return false;
  aterm_appl a(term);
  if (!gsIsType(a))
    return false;

  // check the children
  if (a.size() != 1)
    return false;
#ifndef LPS_NO_RECURSIVE_SOUNDNESS_CHECKS
  if (!check_term_argument(a(0), check_rule_String<aterm>))
    {
      std::cerr << "check_rule_String" << std::endl;
      return false;
    }
#endif // LPS_NO_RECURSIVE_SOUNDNESS_CHECKS

  return true;
}
//--- end generated code

} // namespace detail

} // namespace lps

#endif // MCRL2_BASIC_DETAIL_SOUNDNESS_CHECKS_H
