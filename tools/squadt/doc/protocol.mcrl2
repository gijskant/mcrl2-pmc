% Type that represents a configuration
sort Configuration = struct configuration(non_empty : Bool);

% Type used for identifying messages sent by the controller
sort MessageType = struct
   identification |         % identification response
   capabilities |           % request/respond for capabilities
   task_configuration |     % tool configuration specification
   task_start |             % signal that a tool may start task execution
   task_stop |              % signal that a tool has stopped task execution
   display_layout |         % communicates a display layout
   display_data |           % communicates state changes of the display
   termination |            % request/response for tool the termination
   report;                  % report

sort MessageData = struct empty | result(Bool) | other;

% Messages travel between a controller (address 0) and a tool instance (address 0 <)
sort Message = struct message(address : Nat, type : MessageType, data : MessageData);

act

   send, receive, communicate: Message;        % send or receive a message
   start_tool, tool_start:     Nat;            % create a new tool instance
   tool_terminate:             Nat;            % terminate a tool
   execute_task:               Configuration;  % perform the configured operation
   error;                                      % error action
   update_display, waiting;                    % other non-communication actions

% a: the tool id
proc unidentified_tool(a : Nat) =
      send(message(a, identification, other)).
        tool(a, configuration(false), false, false);

% a: the tool id
% c: configuration object
proc tool(a : Nat, c : Configuration, in_configuration : Bool, in_task : Bool) =
   receive(message(a, termination, empty)).           % received termination request
     send(message(a, termination, other)) +           % sends termination signal
   (receive(message(a, capabilities, empty)).         % received request for capabilities
      send(message(a, capabilities, other)) +         % response capabilities (tool)
    send(message(a, capabilities, empty))+            % requested controller capabilities
    receive(message(a, capabilities, other))+         % response capabilities (controller)
    send(message(a, display_layout, other)) +         % sent display layout
    send(message(a, display_data, other)) +           % sent display data
    receive(message(a, display_data, other)) +        % sent display data
    send(message(a, report, other))).
   tool(a, c, in_configuration, in_task) +
   (!in_configuration) ->
     ((!in_task) ->
       receive(message(a, task_configuration, empty)).
         tool(a, c, true, false)) <>                  % received a task specification
     send(message(a, task_configuration, other)).
       tool(a, configuration(true), false, false) +   % accepted task specification
   (!in_task) ->
     receive(message(a, task_start, empty)).          % task start signal
     tool(a, c, in_configuration,
             (non_empty(c) && !in_configuration)) <>
     (sum b : Bool.
       send(message(a, task_stop, result(b))).        % task finished or aborted
       tool(a, c, false, false));

% Workaround until proper support for finite sets is implemented
map in_set : Nat # List(Nat) -> Bool ;
    as_set : List(Nat) -> Set(Nat) ;
    add    : Nat # List(Nat) -> List(Nat);
    remove : Nat # List(Nat) -> List(Nat);

var m,x : Nat;
    xs : List(Nat);

eqn in_set(m, []) = false;
    in_set(m, x|>xs) = x == m || in_set(m, xs);
    as_set([]) = {};
    as_set(x|>xs) = {x} + as_set(xs);
    add(m,[]) = [m];
    add(m,x|>xs) = if(m < x, x|>add(m, xs), if(m == x, x|>xs, m|> xs));
    remove(m,[]) = [];
    remove(m,x|>xs) = if(x != m,x|>res,res) whr res = remove(m,xs) end;

% m: the maximum address of a running tool
% r: the set of active tools
% c: the set of active tools that are configured
% l: the set of active tools that have communicated a display layout
% s: the set of active tools that are executing a task
proc controller(m : Nat, r : List(Nat), c : List(Nat), l : List(Nat), s : List(Nat)) =
 (sum a : Nat. (a <= m) -> (
   start_tool(a).controller(m,add(a,r),c,l,s) +       % starts a new tool instance
   (a in r) -> (                                      % for tool a:
     tool_terminate(a).
       controller(m,remove(a,r), remove(a,c), remove(a,l), remove(a,s)) +
     receive(message(a, identification, other)).      % received instance identifier
       controller(max(m,a),r,c,l,s) +
     (receive(message(a, capabilities, empty)).       % received request for capabilities
        send(message(a, capabilities, other)) +
      send(message(a, capabilities, empty)).          % sent request for capabilities of
        receive(message(a, capabilities, other)) +
      receive(message(a, report, other)) +            % report delivered
      send(message(a, task_configuration, empty)) +
      (a in l) ->                                     % for tool a:
        receive(message(a, display_data, other)).     % update for display data
          update_display +
      (a in l) ->                                     % for tool a:
        send(message(a, display_data, other)) +       %  data from user interaction
      send(message(a, termination, empty))).          %  sent termination request
     controller(m,r,c,l,s) +
     receive(message(a, display_layout, other)).      %  display layout delivered
       controller(m,r,c,add(a,l),s) +
     receive(message(a, task_configuration, other)).  %  configuration was accepted
       controller(m,r,add(a,c),l,s) +
    (sum b : Bool.
      receive(message(a, task_stop, result(b)))).
      ((a in s && a in c) ->
         controller(m,r,c,l,remove(a,s)) <>
         error.controller(m,r,c,l,s)) +              % task completed
    (a in c) ->                                      % for tool a:
      send(message(a, task_start, empty)).
        controller(m,r,c,l,add(a,s)) +               %  task start command
    receive(message(a, termination, other)).         %  termination signal
      controller(m,remove(a,r),remove(a,c),remove(a,l),remove(a,s))) <>
      waiting.controller(m,r,c,l,s)));

  % Execution component (starts tools)
%  E(n : Nat) = start_tool(n).(E(n + 1) || unidentified_tool(n));
   E(n : Nat, m : Nat) = (n < m) -> start_tool(n).E(n + 1, m) <> waiting.E(n, m);

init

  hide({error, waiting, execute_task, update_display},
    allow({communicate, tool_start, tool_terminate,
                        error, waiting, execute_task, update_display},
      comm({send|receive -> communicate,start_tool|start_tool -> tool_start},
        controller(0,[],[],[],[]) || unidentified_tool(0) || E(0, 1))));

