% Type that represents a configuration
sort Configuration = struct configuration(valid : Bool);

% Type used for identifying messages sent by the controller
sort MessageType = struct
   identification |         % identification response
   capabilities |           % request/respond for capabilities
   task_configuration |     % tool configuration specification
   task_start |             % signal that a tool may start task execution
   task_stop |              % signal that a tool has stopped task execution
   display_layout |         % communicates a display layout
   display_data |           % communicates state changes of the display
   termination |            % request/response for tool the termination
   report;                  % report

sort MessageData = struct empty | result(Bool) | other;

% Messages travel between a controller (address 0) and a tool instance (address 0 <)
sort Message = struct message(address : Nat, type : MessageType, data : MessageData);

act

   send, receive, communicate: Message;        % send or receive a message
   start_tool, tool_start:     Nat;            % create a new tool instance
   tool_terminate:             Nat;            % terminate a tool
   execute_task:               Configuration;  % perform the configured operation
   error;                                      % error action
   update_display, waiting;                    % other non-communication actions

% a: the tool id
proc unidentified_tool(a : Nat) =
      send(message(a, identification, other)).
        tool(a, configuration(false), false, false);

% a: the tool id
% c: configuration object
proc tool(a : Nat, c : Configuration, in_configuration : Bool, in_task : Bool) =
   receive(message(a, termination, empty)).           % received termination request
     send(message(a, termination, other)) +           % sends termination signal
   (receive(message(a, capabilities, empty)).         % received request for capabilities
      send(message(a, capabilities, other)) +         % response capabilities (tool)
    send(message(a, capabilities, empty))+            % requested controller capabilities
    receive(message(a, capabilities, other))+         % response capabilities (controller)
    send(message(a, display_layout, other)) +         % sent display layout
    send(message(a, display_data, other)) +           % sent display data
    receive(message(a, display_data, other)) +        % sent display data
    send(message(a, report, other))).
   tool(a, c, in_configuration, in_task) +
   (!in_configuration) ->
     ((!in_task) ->
       receive(message(a, task_configuration, empty)).
         tool(a, c, true, false)) <>                  % received a task specification
     send(message(a, task_configuration, other)).
       tool(a, configuration(true), false, false) +   % accepted task specification
   (!in_task) ->
     receive(message(a, task_start, empty)).          % task start signal
     tool(a, c, in_configuration,
             (valid(c) && !in_configuration)) <>
     (sum b : Bool.
       send(message(a, task_stop, result(b))).        % task finished or aborted
       tool(a, c, false, false));

% Workaround until proper support for finite sets is implemented
map set_add    : Nat # List(Nat) -> List(Nat);
    set_erase : Nat # List(Nat) -> List(Nat);

var x,xx : Nat;
    xs   : List(Nat);

eqn set_add(x,[]) = [x];
    set_add(xx,x|>xs) = if(xx in xs,xs,if(xx < x,xx|>x|>xs,x|>set_add(xx,xs)));
    set_erase(x,[]) = [];
    set_erase(xx,x|>xs) = if(xx == x,xs,x|>if(xx in xs,set_erase(xx,xs),xs));

% m: the maximum address of a running tool
% r: the set of active tools
% c: the set of active tools that are configured
% l: the set of active tools that have communicated a display layout
% s: the set of active tools that are executing a task
proc controller(m : Nat, r : List(Nat), c : List(Nat), l : List(Nat), s : List(Nat)) =
 (sum a : Nat. (a <= m) -> (
   start_tool(a).controller(m,set_add(a,r),c,l,s) +   % starts a new tool instance
   (a in r) -> (                                      % for tool a:
     tool_terminate(a).
       controller(m,set_erase(a,r), set_erase(a,c),
                    set_erase(a,l), set_erase(a,s)) +
     receive(message(a, identification, other)).      % received instance identifier
       controller(max(m,a),r,c,l,s) +
     (receive(message(a, capabilities, empty)).       % received request for capabilities
        send(message(a, capabilities, other)) +
      send(message(a, capabilities, empty)).          % sent request for capabilities of
        receive(message(a, capabilities, other)) +
      receive(message(a, report, other)) +            % report delivered
      send(message(a, task_configuration, empty)) +
      (a in l) ->                                     % for tool a:
        receive(message(a, display_data, other)).     % update for display data
          update_display +
      (a in l) ->                                     % for tool a:
        send(message(a, display_data, other)) +       %  data from user interaction
      send(message(a, termination, empty))).          %  sent termination request
     controller(m,r,c,l,s) +
     receive(message(a, display_layout, other)).      %  display layout delivered
       controller(m,r,c,set_add(a,l),s) +
     receive(message(a, task_configuration, other)).  %  configuration was accepted
       controller(m,r,set_add(a,c),l,s) +
    (sum b : Bool.
      receive(message(a, task_stop, result(b)))).
      ((a in s && a in c) ->
         controller(m,r,c,l,set_erase(a,s)) <>
         error.controller(m,r,c,l,s)) +              % task completed
    (a in c) ->                                      % for tool a:
      send(message(a, task_start, empty)).
        controller(m,r,c,l,set_add(a,s)) +           %  task start command
    receive(message(a, termination, other)).         %  termination signal
      controller(m,set_erase(a,r),set_erase(a,c),
                   set_erase(a,l),set_erase(a,s))) <>
      waiting.controller(m,r,c,l,s)));

% Execution component (starts tools)
proc E(current : Nat, maximum : Nat) =
  (current < maximum) ->
        start_tool(current).E(current + 1, maximum);

init

  hide({error, waiting, execute_task, update_display},
    allow({communicate, tool_start, tool_terminate,
                        error, waiting, execute_task, update_display},
      comm({send|receive -> communicate,start_tool|start_tool -> tool_start},
        controller(0,[],[],[],[]) || unidentified_tool(0) || E(0, 1))));
