% Major simplifications:
%  - message content is not considered
%  - in reality squadt uses the instance id to determine which of all tools
%    that was started is trying to communicate via a socket connection, this
%    model ignores this detail

sort Configuration = struct configuration(non_empty : Bool);

  % Type used for identifying messages sent by the controller
sort MessageType = struct identification |
                           capabilities |           % request/respond for capabilities (e.g. supported protocol version) (empty for request)
                           task_configuration |     % tool configuration specification
                           task_start |             % signal that a tool may start task execution
                           task_stop |              % signal that a tool has stopped task execution
                           display_layout |         % communicates a display layout
                           display_data |           % communicates state changes of the display
                           termination |            % request/response for tool the termination
                           report;                  % report

sort MessageData = struct empty | result(Bool) | other;

% Messages travel between a controller (address 0) and a tool instance (address 0 <)
sort Message = struct message(address : Nat, type : MessageType, data : MessageData);

act

  send,receive,communicate:                    Message;        % send or receive a message
  start_tool, tool_start, tool_terminate:      Nat;            % create a new tool instance
  execute_task:                                Configuration;  % perform the configured operation
  error, update_display;                        % actions denoting operations

% a: the tool id
proc unidentified_tool(a : Nat) =
      send(message(a, identification, other)).tool(a, configuration(false), false, false);

% a: the tool id
% c: configuration object
proc tool(a : Nat, c : Configuration, in_configuration : Bool, in_task : Bool) =
      receive(message(a, termination, empty)).                                             % received termination request
        send(message(a, termination, empty)) +                                             % sends termination signal
      (receive(message(a, capabilities, empty)).                                           % received request for capabilities
         send(message(a, capabilities, other)) +                                           % responded with description of capabilities
       send(message(a, capabilities, empty))+                                              % requested controller capabilities
       receive(message(a, capabilities, other))+                                           % received controller capabilities
       send(message(a, display_layout, other)) +                                           % sent display layout
       send(message(a, display_data, other)) +                                             % sent display data
       receive(message(a, display_data, other)) +                                          % sent display data
       send(message(a, report, other))).
      tool(a, c, in_configuration, in_task) +
      (!in_configuration) ->
        ((!in_task) ->
          receive(message(a, task_configuration, empty)).
            tool(a, c, true, false)) <>                                                    % received a configuration request
        send(message(a, task_configuration, other)).
          tool(a, configuration(true), false, false) +                                     % accepted configuration description
      (!in_task) ->
        (receive(message(a, task_start, empty)).
          ((non_empty(c) && !in_configuration) ->
              tool(a, c, false, true) <>
              error.tool(a, c, in_configuration, false))) <>
        (error.send(message(a, task_stop, result(false))).tool(a, c, false, true) +        % error occurred, stop task execution
         send(message(a, task_stop, result(true))).tool(a, c, false, true));

% Workaround until proper support for finite sets (unique representation) is implemented in (lps2lts)
map in_set : Nat # List(Nat) -> Bool ;
    as_set : List(Nat) -> Set(Nat) ;
    add    : Nat # List(Nat) -> List(Nat);
    remove : Nat # List(Nat) -> List(Nat);

var m,x : Nat;
    xs : List(Nat);

eqn in_set(m, []) = false;
    in_set(m, x|>xs) = x == m || in_set(m, xs);
    as_set([]) = {};
    as_set(x|>xs) = {x} + as_set(xs);
    add(m,[]) = [m];
    add(m,x|>xs) = if(m < x, x|>add(m, xs), if(m == x, x|>xs, m|> xs));
    remove(m,[]) = [];
    remove(m,x|>xs) = if(x != m,x|>res,res) whr res = remove(m,xs) end;

% m: the maximum address of a running tool
% r: the set of active tools
% c: the set of active tools that are configured
% l: the set of active tools that have communicated a display layout
% s: the set of active tools that are executing a task
proc controller(m : Nat, r : List(Nat), c : List(Nat), l : List(Nat), s : List(Nat)) =
    (sum a : Nat. (a <= m) -> (
      start_tool(a).controller(m,add(a,r),c,l,s) +                                               % starts a new tool instance
      (a in r) -> (
        tool_terminate(a).controller(m,remove(a,r), remove(a,c), remove(a,l), remove(a,s)) +
        receive(message(a, identification, other)).controller(max(m,a),r,c,l,s) +            % received instance identifier
        (receive(message(a, capabilities, empty)).                                           % received request for capabilities
           send(message(a, capabilities, other)) +
         send(message(a, capabilities, empty)).                                              % sent request for capabilities of tool <a>
           receive(message(a, capabilities, other)) +
         receive(message(a, report, other)) +                                                % report delivered
         send(message(a, task_configuration, empty)) +
         receive(message(a, display_data, other)).                                           % received display data (used for manipulation of display)
           ((a in l) -> update_display <> error) +                                   % display data delivered
         (a in l) ->
           send(message(a, display_data, other)) +                                           % data from interaction only available when a layout is available
         send(message(a, termination, empty))).                                              % sent termination request to tool <a>
        controller(m,r,c,l,s) +
        receive(message(a, display_layout, other)).controller(m,r,c,add(a,l),s) +            % display layout delivered for tool <a>
        receive(message(a, task_configuration, other)).controller(m,r,add(a,c),l,s) +        % last configuration was accepted for tool <a>
        (sum b : Bool. receive(message(a, task_stop, result(b)))).
          ((a in s && a in c) ->
             controller(m,r,c,l,remove(a,s)) <>
             error.controller(m,r,c,l,s)) +                                                  % last task of tool <a> completed
        (a in c) ->
          send(message(a, task_start, empty)).controller(m,r,c,l,add(a,s)) +                     % sent task start signal to tool <a>
        receive(message(a, termination, empty)).                                             % termination signal received for tool <a>
          controller(m,remove(a,r),remove(a,c),remove(a,l),remove(a,s)))));

  % Execution component (starts tools)
%  E(n : Nat) = start_tool(n).(E(n + 1) || unidentified_tool(n));
   E(n : Nat, m : Nat) = (n < m) -> start_tool(n).E(n + 1, m);

init

  hide({error},
    allow({communicate, tool_start, tool_terminate, error, execute_task, update_display},
      comm({send|receive -> communicate,start_tool|start_tool -> tool_start},
        controller(0,[],[],[],[]) || unidentified_tool(0) || E(0, 1))));

