\documentclass{article}
\usepackage[UKenglish]{babel}
\usepackage{graphicx}
\usepackage{calc}
\usepackage{latexsym,amssymb,amsfonts,amsthm,amsmath}
\usepackage{float}
\usepackage{alltt}
\usepackage[top=3cm,left=3cm,bottom=3cm,right=3cm]{geometry}

\title{A Protocol for Interactively Controlling Tools}

\newtheorem{example}{Example}

\newcommand{\msg}[1]{\texttt{#1}}

\begin{document}

 \section{Concepts}

  \subsection{System}

   The protocol described in this document is designed for the purpose of
   developing a desktop application for interactive tool integration. The
   protocol forms the abstraction layer between the tools and this application
   we simply call system in this document.

  \subsection{Tool}

   A tool is a software program that can be executed multiple times
   concurrently on the same or different computer. The tool offers services to
   its environment. The end-user that is part of the environment has particular
   goals in mind and using the right combination of tools can help to achieve
   these goals.

   So a tool can be any computer program. Existing tools with a command line
   interface or more complex programs with graphical user interfaces. Note that
   there can be a large difference between required the degree of user
   interactivity to get the tool to perform the task that the user wants it to do.

  \subsection{Configuration}

   Tools may offer different services to the environment, but an end-user is
   interested in it only completing the task at hand. Most tools are
   configurable, by which we mean that it can be configured to perform a
   certain task within the functionality provided by the tool. For instance we
   want to configure a tool that computes prime numbers to compute the first
   1000 prime numbers and then terminate execution.

   The process of configuration is to bring the tool in a state where it will
   perform the desired task. A formalism is needed to capture this state such
   that it can be reproduced later. For our purposes a \textit{configuration}
   is a concrete specification that can be used to bring a tool into a state
   where it will perform the desired task.

% Implementation specific?
   This is not a novelty, programs with command line interfaces take arguments
   that are used to (re)produce this state non-interactively. The model behind
   this method of expressing a configuration is based on the idea that tasks
   consist of a sequence of operations that themselves are parametrised. A
   configuration is a selection between available operations and values for the
   parameters of each of these operations. On the command line such a
   configuration is represented as a string that consists of so-called options
   followed by values for the arguments of this option.

  \subsection{Tool Display}

   A tool offers services and the system offers a tool facilities for
   communication with the user and possibly also other tools. One of the
   facilities that is available for this purpose is the tool display. Any tool
   instance is associated with a graphical display through which it can
   communicate with a user, that exists as long as the tool is running.
   
   The extend to which the display can be manipulated will not be described in
   this document. The original idea was that the protocol provides the means
   for putting user interface controls on the display and to support
   interaction with these controls.

 \section{Background}

  The purpose of the communication protocol described in this document is to
  have a simple means of connecting a tool to our system. The system 
  provides a number of facilities that can be used by tools, but the tools are
  themselves services that are made accessible to the user of the system. The
  system acts as a controller for multiple tools at the same and therefore the
  system will be referred to as controller in the remainder of this document. 
  \\[4pt]
  A tool is a software program or some hardware wrapped by a program. In modern
  operating systems programs are started as a process, a in-memory instance of
  the program. From here on we talk about a tool as a communication partner of
  the controller.
  \\[4pt]
  The protocol described in this document is designed to be minimal and to
  allow future extension. All messages are typed and message content is based
  on the type, and direction only. No unnecessary restrictions have been put on
  the order of messages. A message context represents the ordered list of sent
  and received messages. This document describes version 1.0 of the protocol.

 \section{Messages} \label{s:message_definitions}

  \subsection{Instance identification}

   When the controller starts a tool this tool will build a connection back to
   the controller across the network. On an new incoming connection the
   controller has no way of knowing what lives on the other side of the
   connection. The tool should identify itself by presenting a secret. The
   first message after a connection has been established must be structured as
   follows.
   
   \begin{figure}[H]
    \begin{tabular}{|ll|}
     \hline
     message type:    & \msg{identification} \\
     \hline
     direction:       & tool to controller \\
     data:            & token \\
     \hline
    \end{tabular}
   \end{figure}

   \noindent When started the tool is given a token which it should sent as
   part of this message. If the controller does not receive a such a message as
   first message or the token inside the message does not match one of the
   expected tokens, then the connection must be severed. Messages of this type
   must be ignored if they are not the first message after the connection has
   been established.

  \subsection{Capabilities}

   The controller provides facilities for tools. A tool must have been
   programmed to use a specific facility. We want to allow differences between
   the set of available services between different versions or configurations
   of the controller. To this end we introduce a message type for communicating
   this kind of information. From any context a message:

   \begin{figure}[H]
    \begin{tabular}{|ll|}
     \hline
     message type:    & \msg{capabilities} \\
     \hline
     direction:       & tool to controller \\
     data:            & none \\
     \hline
    \end{tabular}
   \end{figure}

   \noindent represents a request for capabilities. The controller must respond
   to this message with the following message.

   \begin{figure}[H]
    \begin{tabular}{|ll|}
     \hline
      message type:   & \msg{capabilities} \\
     \hline
      direction:      & controller to tool \\
      data:           & Version $\times$ Dimensions \\
                      & Version    = struct major : Nat $|$ minor : Nat \\
     \hline
    \end{tabular}
   \end{figure}

   The only facility available to tools with the first version of the protocol
   is the tool display. The controller creates and associates a display with
   every tool. The tool can use the display to communicate with the user. This
   facility is assumed to be always present, so the only information carried by
   the response message sent to a tool is the version of the protocol used by
   controller.
   \\[4pt]
   A similar information need exists on the side of the controller. The idea is
   that every connected tool offers its services to a controller.  Simply put,
   in order to make use of such a service there must be an indication of what
   is required for, and what is obtained by making use of the service. From any
   context a message:
   
   \begin{figure}[H]
    \begin{tabular}{|ll|}
     \hline
      message type:   & \msg{capabilities} \\
     \hline
      direction:      & controller to tool \\
      data:           & none \\
     \hline
    \end{tabular}
   \end{figure}

   \noindent serves as a request for such information. A tool must respond to
   this message with  the following message.

   \begin{figure}[H]
    \begin{tabular}{|ll|}
     \hline
      message type:   & \msg{capabilities} \\
     \hline
      direction:      & tool to controller \\
      data:           & version $\times$ List (input-combination) \\
                      &  version           = struct major : Nat $|$ minor : Nat \\
                      &  input-combination = category $\times$ List (data-source) \\
                      &  category          = String,   a name that characterises the function of the tool \\
                      &  data-source       = id $\times$ format \\
                      &  format            = mime-type, storage format specifier for the tools main input \\
     \hline
    \end{tabular}
   \end{figure}

   The information communicated with this message is the protocol version used
   by the tool and a list of so-called input combinations. An input combination
   represents a specific configuration of the tool. It consists of a category,
   which is a name that can be used by the controller to categorise tools based
   on functionality, and a list of identifiers for data sources. The data
   sources are typically files that reside somewhere on local or network
   storage but can also be unbounded data streams. The format is a string that
   follows the syntax defined in RFC2822 and describes the format used for
   storing the data.

  \subsection{Tool Configuration}

   The controller uses services provided by a tool by configuring the tool to
   perform a task within the range of services it provides. Configuration and
   task execution are separated and the latter is discussed in the next subsection.
   \\[4pt]
   Tool configuration is performed in two steps. First the controller sends a
   configuration, the tool inspects this configuration and responds with a
   verdict on whether or not the configuration can be used to successfully
   configure the tool (i.e. it is deemed acceptable). Such a message may be
   sent from any context and has the following structure:
   
   \begin{figure}[H]
    \begin{tabular}{|ll|}
     \hline
      message type:   & \msg{configuration} \\
     \hline
      direction       & controller to tool \\
      data:           & fresh $\times$ category $\times$ List (option) $\times$ inputs $\times$ outputs \\
                      & \ inputs  = List (object) \\
                      & \ outputs = List (object) \\
                      & \ fresh   = Bool, whether the configuration is fresh \\
                      & \ option  = id $\times$ data-type $\times$ values \\
                      & \ object  = id $\times$ format $\times$ URI \\
                      & \ values  = List(String) \\
     \hline
    \end{tabular}
   \end{figure}

   \noindent To sent a message of this type the controller must have a
   configuration, which consists of a category name that specifies the kind of
   functionality the configuration will provide, the inputs and outputs to the
   tool as well as options and values for these options. The controller can
   obtain configurations in two ways. It can cast a single input combination as
   received from a previous \msg{tool\_capabilities} message into a
   configuration, in which case the configuration is marked as fresh. On the
   other hand the controller can use a configuration that was previously
   accepted by a tool.
   \\[4pt]
   Often before sending a response the tool will communicate with the user (see
   subsection \ref{ss:user_interaction}) to get additional configuration
   parameters. A response message has the same structure structure as the request. 

   \begin{figure}[H]
    \begin{tabular}{|ll|}
     \hline
      message type:   & \msg{configuration} \\
     \hline
      direction       & tool to controller \\
      data:           & fresh $\times$ category $\times$ List (option) $\times$ inputs $\times$ outputs \\
                      & \ inputs  = List (object) \\
                      & \ outputs = List (object) \\
                      & \ fresh   = Bool, whether the configuration is fresh \\
                      & \ option  = id $\times$ data-type $\times$ values \\
                      & \ object  = id $\times$ format $\times$ URI \\
                      & \ values  = List(String) \\
     \hline
    \end{tabular}
   \end{figure}

   \noindent For the response message the freshness attribute is interpreted
   differently.  When fresh then the configuration is rejected, otherwise it is
   accepted meaning that tool configuration is complete and task execution may
   start.  The tool can freely modify and extend any configuration information
   except for the category and other information present in the
   input-combination on which the configuration was originally based.
   \\[4pt]
   \noindent About the configuration specifications: every option is uniquely
   identified, and so is every object. An option represents an atomic unit in
   the configurable behaviour of a tool. For validation purposes a data type
   can be specified against which the values for the option are matched. An
   object is a file associated with a format (again specified by a mime-type)
   and a location.

  \subsection{Task Execution}

   \noindent When tool configuration is complete the controller may start task
   execution by sending a message with the following structure.

   \begin{figure}[H]
    \begin{tabular}{|ll|}
     \hline
      message type:   & \msg{task\_start} \\
     \hline
      direction       & controller to tool \\
     \hline
    \end{tabular}
   \end{figure}

   \noindent The controller has to ensure that the input objects in a configuration exist
   before a tool is started. And that the output objects can be created or
   modified.
   \\[4pt]
   When a task has been completed the tool must send a response to the
   controller that signals this fact. From a context where a \msg{task\_start}
   has been received and no subsequent \msg{task\_done} has been sent a tool
   may send a message with the following structure:

   \begin{figure}[H]
    \begin{tabular}{|ll|}
     \hline
      message type:   & \msg{task\_done} \\
     \hline
      direction       & tool to controller \\
      data            & result : Bool \\
     \hline
    \end{tabular}
   \end{figure}

   \noindent which signifies that execution of the task has finished. In addition it also
   tells whether or not the task has been completed successfully or not.

  \subsection{Tool Report}

   From any context a tool can sent a report that signifies a warning, error or
   just some information.

   \begin{figure}[H]
    \begin{tabular}{|ll|}
     \hline
      message type:   & \msg{report} \\
     \hline
      direction:      & tool to controller \\
      data:           & description $\times$ struct notice $|$ warning $|$ error \\
     \hline
    \end{tabular}
   \end{figure}

   \noindent The controller will probably pass it through to the user but
   it has no effect on protocol state. Before termination a tool can report to
   the controller about what has been done. This report can contain anything
   from general information to errors as well as all the outputs produced by
   the tool.

  \subsection{User interaction} \label{ss:user_interaction}

   For user interaction a tool depends on the controller. The controller offers
   a display to the user on behalf of a tool. Using the display is a two step
   process. First the contents of the display is created from a layout
   specification that consists of controls and layout constraints. This step
   can be repeated to change the content of the display. Then updates are sent
   to the tool based on user interaction with the display and a tool can send
   updates to change the state of controls on the display.
   \\[4pt]
   A minimal set of controls is available for constructing layouts\footnote{It
   would be nice if these controls are not part of the protocol but added
   through the extension mechanism (because they are highly implementation
   specific)}. From any context the following message:
   
   \begin{figure}[H]
    \begin{tabular}{|ll|}
     \hline
      message type:   & \msg{display\_layout} \\
     \hline
      direction:      & tool to controller \\
      data:           & List (layout\_element) Where :\\
                      & \ layout\_element :  element\_type \\
                      & \ \ element\_type   : VerticalBox $|$ HorizontalBox $|$ ProgressBar $|$ \\
                      & \ \ \ \ RadioButton $|$ Button $|$ Label $|$ TextField \\
                      & \ \ vertical\_box   = List(layout\_element $\times$ horizontal\_alignment) \\
                      & \ \ horizontal\_box = List(layout\_element $\times$ vertical\_alignment) \\
                      & \ \ progress\_bar = Nat $\times$ Nat $\times$ Nat \\
                      & \ \ radio\_button = id $\times$ Bool \\
                      & \ \ button        = id $\times$ string \\
                      & \ \ label         = id $\times$ string \\
                      & \ \ text\_field   = id $\times$ type $\times$ String \\
                      & \ \ \ type        = bool $|$ integer $|$ real $|$ enumeration $|$ string \\
     \hline
    \end{tabular}
   \end{figure}

   \noindent containing a layout specification can be sent. A user can interact
   with the display, and results are communicated back to a tool with a message
   with the following structure.

   \begin{figure}[H]
    \begin{tabular}{|ll|}
     \hline
      message type:   & \msg{display\_data} \\
     \hline
      direction:      & controller to tool \\
      data:           & Id $\rightarrow$ State \\
     \hline
    \end{tabular}
   \end{figure}

   \noindent A tool can sent updates to controls on a display by their
   identifier using a message with the following structure:

   \begin{figure}[H]
    \begin{tabular}{|ll|}
     \hline
      message type:   & \msg{display\_data} \\
     \hline
      direction:      & tool to controller \\
      data:           & Id $\rightarrow$ State \\
     \hline
    \end{tabular}
   \end{figure}

  \subsection{Tool Termination}

   \noindent The controller can request a tool to terminate. This facility is present to
   allow tools tools to free resources and remove outputs or leave them in a
   consistent state.

   \begin{figure}[H]
    \begin{tabular}{|ll|}
     \hline
      message type:    & \msg{termination} \\
     \hline
      direction:       & controller to tool \\
      data:            & none \\
     \hline
    \end{tabular}
   \end{figure}

   \noindent As a response the tool should sent a message with the following
   structure, or risk being terminated after a timeout period.

   \begin{figure}[H]
    \begin{tabular}{|ll|}
     \hline
      message type:   & \msg{termination} \\
     \hline
      direction:      & tool to controller \\
      data:           & none \\
     \hline
    \end{tabular}
   \end{figure}

 \section{Implementation} \label{s:implementation}

   Our only requirements are that messages can be typed, that message order is
   preserved and we have a means of authenticating an incoming connection. We
   aim to have initial support Windows 2000/XP, for Mac OS X version 10.4, and
   GNU/Linux and do not want separate solutions for each of these platforms. An
   existing protocol that we considered is XMPP by the IETF (RFC 3920). It is a
   simple protocol between a client and a server that uses two XML streams and
   further features connection authentication mechanism.  Unfortunately no
   single client/server side implementations existed that was usable on all
   target platforms and creating our own implementation would have taken to
   much time. So a lightweight custom protocol was chosen, instead of using an
   existing protocol. 

  \subsection{Transport}

   \noindent The TCP/IP protocol suite is chosen as the means of transport. It is
   well-known and supported by a lot of programming languages. The protocol
   requires connection-state, a tool is authenticated once and on failure the
   connection is terminated. In addition, because meaning is assigned to the
   order of messages, the protocol requires that messages are delivered in the
   same order as which they were offered to the sender. All requirements are
   all supported by TCP/IP, note that for UDP/IP this is not the case.

  \subsection{Message Structure}

   \noindent The choice for XML is obvious we aim for extensibility and XML to some
   extend allows changes to the format extensions to the format there is wide
   support in many programming languages. With XML it is possible to create a
   good parser that is to some extent resistant to extensions, meaning it will
   also work on future versions of the format that may contain additional
   information.  Another benefit of using XML is it makes the messages
   readable, making it easy to print and manually verify the structure and
   contents.

   \subsubsection{XML Structure}

    \noindent messages are wrapped in the <message> tag. A mandatory attribute
    is \textit{type} that specifies the type of the message, it may occur only
    once. For example:
 
    \begin{example}
     <message type="termination">
      <![CDATA[message content]]>
     </message>
    \end{example}

    The content of a message is wrapped as so-called CDATA section. It means
    that the data inside is not interpreted when parsing a message. So a
    message that has invalid XML as content can still be valid XML itself.

\end{document}
