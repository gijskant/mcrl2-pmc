\documentclass{article}
\usepackage[UKenglish]{babel}
\usepackage{graphicx}
\usepackage{calc}
\usepackage{latexsym,amssymb,amsfonts,amsthm,amsmath}
\usepackage{float}
\usepackage[top=3cm,left=3cm,bottom=3cm,right=3cm]{geometry}

\title{A Protocol for Interactively Controlling Software Tools}
\author{J. van der Wulp}

\newtheorem{example}{Example}

\newcommand{\msg}[1]{\texttt{#1}}

\bibliographystyle{alpha}

\begin{document}

\maketitle

 \section{Introduction}

  The communication protocol described in this document has been designed out
  of need for an abstract control layer for an interactive tool integration
  platform. In which a tool is a software program that can be used to fulfill
  certain tasks. There existed a set of very concrete ideas of the platform
  itself, and the protocol has been designed to fit some of its specific needs.

  There exists a proof-of-concept implementation of the platform mentioned
  previously in the shape of a desktop application called deskSQuADT. The first
  part of the name refers to the fact that it is a desktop application, and the
  second part stands for Systems Quality, Analysis and Design Toolset.  The
  deskSQuADT application is distributed as part of the mCRL2 toolset (see
  \cite{groote_et_al:DSP:2007:862}), a collection of tools around the formal
  modelling language mCRL2 that can be used for verification and analysis.  In
  and by itself deskSQuADT cannot be called a toolset, but the idea is that it
  integrates the tools that are connected, in this case some of the mCRL2
  tools.   The protocol described in this document is currently the primary
  means by which tools are connected.
%  Nevertheless the protocol that is the subject of this document is described
%  as independent as possible from the system in order to show that it, or at
%  the very least the underlying ideas, can be used outside it as well.

  The deskSQuADT application is by no means meant to be functionally complete
  in any way. There are plenty ideas on what works and what does not work and
  should be changed in possible future implementations.  There are also a lot
  of ideas for future extension, for instance to make communication between
  tools possible as well. It is not necessarily the intention to incorporate
  all of such functionality into this protocol. The scope of this protocol is
  to interactively control single tools in much the same way as in which the
  standalone tool would be used.  The only added functionality provided is on
  the level of integration: consistency and automatism through repeatability.

  In abstract, the platform provides a number of facilities that can be used by
  tools to communicate with the user. The tools provide services that are made
  accessible to the user of the platform. The platform acts as a controller
  (possibly for multiple tools at the same time) and therefore the system will
  be referred to as (the) controller in the remainder of this document.
  Similarly, a tool is the communication partner of the controller.
%  \\[4pt]
%  The protocol described in this document is designed to be as minimal as
%  possible around the core ideas behind the system. Some care was taken to
%  allow future extensions.

  The remainder of this text is structured as follows. First the important
  concepts are introduced, to give the reader an overview of things involved.
  Next an abstract overview is given on the structure of communication: what
  messages are, what types of messages are used in the protocol, the meaning of
  those message and how the messages may interact. All of this is followed by a
  section that discusses implementation aspects such as the design choices that
  were made, along with motivation and an elaborate description of what
  messages look like in detail.

 \section{Concepts}

  \subsection{System}

   The system is a software application for interactive software tool
   integration. A concrete example of such a system would be deskSQuADT, but in
   the remainder of this document we will talk about system.

%   The protocol described in this document describes how the system and a
%   software tool communicate.
   
%   It is likely that the protocol will be extended in the future as more
%   functionality becomes available in the system.
   
  \subsection{Tool}

   A tool is a software program that can be executed multiple times
   concurrently on the same or a different machine.  A tool offers services to
   its environment, controlled by the user by means of the system. It is
   assumed that the end-user has particular goals in mind that require the use
   of functionality provided by a combination of different tools. The system
   will assist the user by finding and using the right tool at intermediate
   steps toward achieving the final goal.

   Applying a tool is assumed to consists of reading input and produce some
   result (output).  This result may or may not be a stepping stone for
   applying another tool on that result (or part thereof).  For example one
   tool generates a 3D model of a tree at random and another tool can be used
   to view and manipulate this model. The result is not required to be
   concrete. For example a visualisation tool might to give a user insight
   through different views on the input, but has otherwise probably no concrete
   result that another tool can continue with.
   
   We assume that the only direct communication between tools is
   uni-directional trough persistent storage (think of files in a filesystem).
   In particular no tools should not mutually depend on each others existence.
   If such a dependency does exist among tools then this dependency can be
   eliminated by treating their combination as a single tool.

   So a tool can be any computer program. It can be tools with a command line
   interface or more complex programs with graphical user interfaces.  There
   can be large differences between the required degree of user interactivity
   for different tools.

  \subsection{Configuration}

   Tools may have different services to offer, but an end-user is may only be
   interested in a very specific service, namely the one that helps completing
   the task at hand. Configuration is the name of the process of bringing a
   tool into a state from where it can be started to perform a certain task
   pertaining to some of the functionality offered by the tool. This does not
   mean that a tool is required to complete the task autonomously after it is
   started. For some tools user user-interaction is inherently a part of the
   task and in a way can be viewed as an extension of the configuration
   process. Our purpose is to single out the part of the configuration process
   that makes sense to repeat later without any user-interaction.
   
   A configured state is a particular state from which the tool will perform
   some task. This task may involve interaction with the user. The information
   that the tool requires to bring itself into a configured state must be
   captured somehow and cast into a form that allows it can be stored. This
   allows the same configured state to be reached at a later time. A
   \textit{configuration} is a formal specification that a tool can use to
   bring itself to a configured state.

%   The process of configuration is to bring the tool in a state where it will
%   perform the desired task. A formalism is needed to capture this state such
%   that it can be reproduced later. For our purposes a \textit{configuration}
%   is a concrete specification that can be used to bring a tool into a state
%   where it will perform the desired task.

  \subsection{Tool Display}

   All communication between the user and a system is assumed to take place via
   the inputs to the tool and any facilities that the system will provide for
   such communication. The \textit{tool display} is a system facility that
   offers an interactive display to user of the system of which the content is
   controlled by a single tool. As long as a tool is running a tool display is
   associated with it.

   Tools are not required to use the tool display at all. It is an optional
   facility that is available for when user interaction is needed. Recall that
   the purpose of the system is to integrate functionality provided by tools.
   From this perspective bypassing the tool display cannot be recommended as it
   sacrifices the uniformity of communication between a user and a tool.
   Nevertheless in some cases it may be a necessity because the tool display
   does not offer the desired functionality.

   The availability of a facility like the tool display in a protocol to
   control tools is questionable. This functionality does not seem to fit the
   purpose. The control aspect does not refer to total control of a tool in the
   sense that user-interaction is cut out. In fact it is not the system that
   asserts the control over tool, but rather the user does by means of the system.

%   The full extend to which the display can be manipulated will not be
%   described in this document. The original idea was that the protocol
%   provides the means for putting user interface controls on the display and
%   to support interaction with these controls. This however, requires the
%   protocol description to be updated every time as. It is up to the system to
%   provide a number of these interface controls that a tool requires for
%   operation.

 \section{Protocol (high level)} \label{s:message_definitions}

  The protocol is defined in terms of a number of typed messages. The semantics
  of a message may depend on the type, the direction in which the message
  travels (controller-to-tool or tool-to-controller) and the messaging context.
  In which the context of a message $m$ is the ordered list of all sent and
  received messages (assuming strict interleaving) up to the point that $m$ is
  sent or received.

  The protocol behaves asynchronous at any moment a request can arrive for any
  of the communication partners. After communication initiation, of which the
  initiative is at the side of a tool, the initiative is determined by which
  side sends a request.

  Typical patterns are request-response sequences. When one side sends a
  request, say a message with a type $t$, the other side \emph{must} respond
  after it has received with message with an acknowledgement, which is also a
  message of type $t$. After sending the request the sender can wait for the
  response provided that in the meanwhile it sends responds for all incoming
  requests. This avoids deadlock, i.e. both sides waiting on response for
  requests to one another.

  \subsection{Instance identification}

   When a tool is started it will initiate communication with a controller.
   The details on how the communication can be initiated is somehow
   communicated outside this protocol. On new incoming communication the
   controller has no way of knowing what lives on the other side of the
   connection. The tool should identify itself by presenting a secret. The
   first message after a connection has been established must be structured as
   follows.
   
   \begin{figure}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
      message type:    & \msg{identification} \\
      \hline
      direction:       & tool to controller \\
      data:            & token \\
      \hline
     \end{tabular}
    \end{center}
   \end{figure}

   \noindent When started the tool is given a token which it should sent as
   part of this message. The controller must sever the connection if the first
   message is not an identification message, or if the token was not among
   those that were expected. It is assumed that the controller has knowledge
   about what tools are expected to connect and each of them can be identified
   by their token.  Messages of this type must be ignored if they are not the
   first message after the connection has been established.

  \subsection{Capabilities}

   Exchange of capabilities represents a manner of communicating available
   functionality on both the side of a tool and that of a controller.  Such
   functionality can be used to offer implementation dependent functionality
   that is not (or not yet) prescribed by the protocol. Only the basic
   structure of the message is prescribed as it is determined by anyone who
   implements it. This is the recommended way of adding implementation
   dependent extensions to the protocol functionality without changing the
   protocol specification.

   A useful example of an implementation dependent extension is adding a new
   control for the tool display. The tool can check the capabilities of the
   controller to see whether the control is available. If it is available it
   can use it just like any other control in the tool display (see section
   \ref{ss:user_interaction}).

   The extension mechanism works the same in both ways (controller-to-tool or
   vice versa). The whole mechanism basically is a request-response, where the
   request is fixed and the response can be arbitrarily complex. The request
   represents a query for the other side's capabilities. The response is the
   combined set of capabilities. A request can be sent from any context and has
   the following structure.

   \begin{figure}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
      message type:    & \msg{capabilities} \\
      \hline
      data:            & none \\
      \hline
     \end{tabular}
    \end{center}
   \end{figure}

   The controller, when it receives a capabilities request must respond with a
   message that contains at least the following information.

   \begin{figure}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       message type:   & \msg{capabilities} \\
      \hline
       direction:      & controller to tool \\
       data:           & Version = struct major : Nat $|$ minor : Nat \\
      \hline
     \end{tabular}
    \end{center}
   \end{figure}

   The tool, when it receives a request for capabilities must also respond with
   a similar message. The difference with the response from the controller is
   in the fact that the tool must advertise its functionality. To operate, the
   tool requires input. Based on what the input represents (characterised by a
   format), it offers functionality (characterised by a category).
   
   \begin{figure}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       message type:   & \msg{capabilities} \\
      \hline
       direction:      & tool to controller \\
       data:           & version $\times$ List (input-configuration) \\
                       &  version             = struct major : Nat $|$ minor : Nat \\
                       &  input-configuration = category $\times$ List (id $\times$ format) \\
                       &  category            = String,   a name that characterises the function of the tool \\
                       &  format              = storage format specifier for the tools main input \\
      \hline
     \end{tabular}
    \end{center}
   \end{figure}

   The combination of a category and a list of pairs of a unique name and a
   format is called an \textit{input configuration} of the tool.  The available
   input configurations, in a rather abstract fashion represent the range of
   functionality offered by the tool.  An input configuration can also be
   considered as a template for a configuration (see section
   \refer{ss::tool\_configuration}). The controller may use the category names
   in an input configuration to categorise tools based on functionality. The
   pairing of a name and a format represents a name for a typed input slot. The
   idea is that to make use of functionality associated with a particular input
   configuration all of the input slots need to be `filled' with valid input
   sources (e.g. files).

  \subsection{Tool Configuration} \label{ss::tool_configuration}

   The controller indirectly makes use of the services provided by a tool by
   configuring the tool to perform a task within the range of services it
   provides. Configuration and task execution are separated and the latter is
   discussed in the next subsection.
   \\[4pt]
   Tool configuration is performed in two steps. First the controller sends a
   configuration, the tool inspects this configuration and responds with a
   verdict on whether or not the configuration can be used to successfully
   configure the tool (i.e. it is deemed acceptable). Such a message may be
   sent from any context and has the following structure:
   
   \begin{figure}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       message type:   & \msg{configuration} \\
      \hline
       direction       & controller to tool \\
       data:           & fresh $\times$ category $\times$ List (option) $\times$ inputs $\times$ outputs \\
                       & \ inputs  = List (object) \\
                       & \ outputs = List (object) \\
                       & \ fresh   = Bool, whether the configuration is fresh \\
                       & \ option  = id $\times$ data-type $\times$ values \\
                       & \ object  = id $\times$ format $\times$ URI \\
                       & \ values  = List(String) \\
      \hline
     \end{tabular}
    \end{center}
   \end{figure}

   \noindent To sent a message of this type the controller must have a
   configuration, which consists of a category name that specifies the kind of
   functionality the configuration will provide, the inputs and outputs to the
   tool as well as options and values for these options. The controller can
   obtain configurations in two ways. It can cast a single input configuration as
   received from a previous \msg{tool\_capabilities} message into a
   configuration, in which case the configuration is marked as fresh. On the
   other hand the controller can use a configuration that was previously
   accepted by a tool.
   \\[4pt]
   Often before sending a response the tool will communicate with the user (see
   subsection \ref{ss:user_interaction}) to get additional configuration
   parameters. A response message has the same structure structure as the request. 

   \begin{figure}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       message type:   & \msg{configuration} \\
      \hline
       direction       & tool to controller \\
       data:           & fresh $\times$ category $\times$ List (option) $\times$ inputs $\times$ outputs \\
                       & \ inputs  = List (object) \\
                       & \ outputs = List (object) \\
                       & \ fresh   = Bool, whether the configuration is fresh \\
                       & \ option  = id $\times$ data-type $\times$ values \\
                       & \ object  = id $\times$ format $\times$ URI \\
                       & \ values  = List(String) \\
      \hline
     \end{tabular}
    \end{center}
   \end{figure}

   \noindent The data in the acknowledgement represents the complete
   configuration and not incremental differences of some kind. For the response
   message the freshness attribute is interpreted differently.  When fresh then
   the previously sent configuration is rejected, otherwise it is accepted and
   the rest of the data specifies the accepted configuration.  An accepted
   configuration means that configuration is complete and task execution may
   start.  The tool can freely modify and extend any configuration information
   except for the category and other information present in the
   input-configuration on which the configuration was originally based.
   \\[4pt]
   \noindent About the configuration specifications: every option is uniquely
   identified, and so is every object. The reason is to make it easier for a
   tool developer to test for availability of options/objects.  An option
   represents an atomic unit in the configurable behaviour of a tool. For
   validation purposes a data type can be specified against which the values
   for the option are matched. An object is a file associated with a format and
   a location.

  \subsection{Task Execution}

   \noindent When tool configuration is complete the controller may start task
   execution by sending a message with the following structure.

   \begin{figure}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       message type:   & \msg{task\_start} \\
      \hline
       direction       & controller to tool \\
      \hline
     \end{tabular}
    \end{center}
   \end{figure}

   \noindent The controller has to ensure that the input objects in a
   configuration exist before a tool is started. And that the output objects
   can be created or modified.
   \\[4pt]
   When a task has been completed the tool must send a response to the
   controller that signals this fact. From a context where a \msg{task\_start}
   has been received and no subsequent \msg{task\_done} has been sent a tool
   may send a message with the following structure:

   \begin{figure}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       message type:   & \msg{task\_done} \\
      \hline
       direction       & tool to controller \\
       data            & result : Bool \\
      \hline
     \end{tabular}
    \end{center}
   \end{figure}

   \noindent which signifies that execution of the task has finished. In addition it also
   tells whether or not the task has been completed successfully or not.

  \subsection{Tool Report}

   From any context a tool can send a report that signifies a warning, error or
   just some information.

   \begin{figure}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       message type:   & \msg{report} \\
      \hline
       direction:      & tool to controller \\
       data:           & struct notice $|$ warning $|$ error $\times$ description \\
      \hline
     \end{tabular}
    \end{center}
   \end{figure}

   \noindent The controller will probably pass it through to the user but
   it has no effect on protocol state. Before termination a tool can report to
   the controller about what has been done. This report can contain anything
   from general information to errors. A controller will display this in some
   way to the user.

  \subsection{User interaction} \label{ss:user_interaction}

   For user interaction a tool depends on the facilities provided by the
   controller. The controller offers a display to the user on behalf of a tool.
   Using the display is a two step process. First the contents of the display
   is created from a layout specification that consists of controls and layout
   constraints. This step can be repeated to change the content of the display.
   Then updates are sent to the tool based on user interaction with the display
   and a tool can send updates to change the state of controls on the display.
   \\[4pt]
   A minimal set of controls is available for constructing layouts\footnote{It
   would be nice if these controls are not part of the protocol but added
   through the extension mechanism (because they are highly implementation
   specific)}. From any context the following message:
   
   \begin{figure}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       message type:   & \msg{display\_layout} \\
      \hline
       direction:      & tool to controller \\
       data:           & List (layout\_element) Where :\\
                       & \ layout\_element :  element\_type \\
                       & \ \ element\_type   : VerticalBox $|$ HorizontalBox $|$ ProgressBar $|$ \\
                       & \ \ \ \ RadioButton $|$ Button $|$ Label $|$ TextField $|$ Checkbox \\
                       & \ \ vertical\_box   = List(layout\_element $\times$ horizontal\_alignment) \\
                       & \ \ horizontal\_box = List(layout\_element $\times$ vertical\_alignment) \\
                       & \ \ progress\_bar = Nat $\times$ Nat $\times$ Nat \\
                       & \ \ radio\_button = id $\times$ Bool \\
                       & \ \ button        = id $\times$ string \\
                       & \ \ label         = id $\times$ string \\
                       & \ \ text\_field   = id $\times$ String \\
%                       & \ \ text\_field   = id $\times$ type $\times$ String \\
%                       & \ \ \ type        = Bool $|$ integer $|$ real $|$ enumeration $|$ string \\
      \hline
     \end{tabular}
    \end{center}
   \end{figure}

   \noindent containing a layout specification can be sent. Every layout
   element has a unique identifier that can be used in subsequent messages to
   change the state (tool-side) or signal updates to the states in accordance
   to user interaction (controller-side).  A user can interact with the
   display, and results are communicated back to a tool with a message with the
   following structure.

   \begin{figure}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       message type:   & \msg{display\_data} \\
      \hline
       direction:      & controller to tool \\
       data:           & Id $\rightarrow$ State \\
      \hline
     \end{tabular}
    \end{center}
   \end{figure}

   \noindent A tool can send updates to controls on a display by their
   identifier using a message with the following structure:

   \begin{figure}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       message type:   & \msg{display\_data} \\
      \hline
       direction:      & tool to controller \\
       data:           & Id $\rightarrow$ State \\
      \hline
     \end{tabular}
    \end{center}
   \end{figure}

  \subsection{Tool Termination}

   \noindent The controller can request a tool to terminate. This facility is present to
   allow tools tools to free resources and remove outputs or leave them in a
   consistent state.

   \begin{figure}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       message type:    & \msg{termination} \\
      \hline
       direction:       & controller to tool \\
       data:            & none \\
      \hline
     \end{tabular}
    \end{center}
   \end{figure}

   \noindent As a response the tool should sent a message with the following
   structure, or risk being terminated after a timeout period.

   \begin{figure}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       message type:   & \msg{termination} \\
      \hline
       direction:      & tool to controller \\
       data:           & none \\
      \hline
     \end{tabular}
    \end{center}
   \end{figure}

 \section{Implementation} \label{s:implementation}

   Our only requirements are that messages can be typed, that message order is
   preserved and we have a means of authenticating an incoming connection. We
   aim to have initial support for Windows 2000/XP, for Mac OS X version 10.4,
   and GNU/Linux and do not settle for separate solutions for each of these
   platforms. An existing communication protocol that we considered is XMPP
   (Extensible Messaging and Presence Protocol, \cite{rfc3920}). It is a simple
   protocol between a client and a server that uses two XML (see
   \cite{Sperberg-McQueen:06:EML}) streams and further features connection
   authentication mechanism.

   XMPP has the notion of a message that can be sent from client to client, on
   top of it our protocol can be implemented.   Unfortunately no single
   client/server side implementations exist at the time that are usable on all
   target platforms without also introducing quite a number of other
   dependencies. Creating our own implementation would have taken to much time,
   especially when we would have implemented all of XMPP.  So we choose a lightweight
   custom implementation, instead of using XMPP with 3rd-party client and
   server implementations.

  \subsection{Transport}

   \noindent The TCP/IP protocol suite is chosen as the means of transport. It is
   well-known and supported by a lot of programming languages. The protocol
   requires connection-state, a tool is authenticated once and on failure the
   connection is terminated. In addition, because meaning is assigned to the
   order of messages, the protocol requires that messages are delivered in the
   same order as which they were offered to the sender. All requirements are
   all supported by TCP/IP, note that for UDP/IP this is not the case.

  \subsection{Message Structure}

   \noindent The choice for XML is obvious we aim for extensibility and XML to some
   extend allows changes to the format extensions to the format there is wide
   support in many programming languages. With XML it is possible to create a
   good parser that is to some extent resistant to extensions, meaning it will
   also work on future versions of the format that may contain additional
   information.  Another benefit of using XML is it makes the messages
   readable, making it easy to print and manually verify the structure and
   contents.

   \subsubsection{XML Structure}

    \noindent messages are wrapped in the \textbf{message} element. A mandatory
    attribute is \textbf{type} that specifies the type of the message, it may
    occur only once. For example:
 
    \begin{verbatim}
     <message type="termination"><![CDATA[message content]]></message>\end{verbatim}

    The content of a message is wrapped as so-called CDATA section. It means
    that the data inside is not interpreted when parsing a message. As a
    consequence a message that has invalid XML as content can still be valid
    XML itself.

  \subsection{Message Content}

   The structure of an XML document is usually specified using XML Document
   Type Declaration (\cite{Sperberg-McQueen:06:EML}) or the XML Schema standard
   \cite{Malhotra:06:XSP}. Many people find this difficult to read and
   discussing semantics is easier by showing small examples of constructs. So
   the translation of the functional specification of the previous section to
   XML is sketched by means of examples. Needless to mention: all messages must
   be valid XML.

  \subsubsection{Authentication}

   Instead of a full-featured authentication scheme we choose a simple instance
   identification scheme. Of course security is something that should be part
   of the design and the security of this solution is very poor from that
   perspective. It only solves the technical problem of identifying the peer
   assuming that everyone has good intentions. This is something we did
   realise. The only justification for this is in the fact implementing
   cross-platform authentication is still a non-trivial undertaking despite of
   all libraries that are available today.  At this point, security is not a
   focus point in this project and getting a multi-platform software
   application to prove the viability of interactive tool integration is.

   As far as the message structure is concerned; an identification message
   contains a single string as content. The string represents the token
   mentioned in the previous section, that is used by the controller to
   identify the communication partner.

  \subsubsection{Capabilities}

   Messages for communicating the capabilities of each of the communication
   partners contain at the very least the version of the protocol. For example:

    \begin{verbatim}
     <capabilities>
      <protocol-version major="1" minor="0"/>
     </capabilities>\end{verbatim}

   A capabilities message sent in reply to a request for capabilities by the
   controller. Contains the input-configurations in addition to the version
   number. So in addition the \textbf{capabilities} element may contain any
   number of \textbf{input-configuration} elements as follows:

    \begin{verbatim}
     <capabilities>
      <protocol-version major="1" minor="0"/>
      <input-configuration category="" format="" id=""/>
     </capabilities>\end{verbatim}

    All attributes: \textbf{category}, \textbf{format} and \textbf{id} are
    mandatory.  The \textbf{category} attribute is an arbitrary string which
    represents a name that characterises functionality targeted by the input
    configuration. The \textbf{id} attribute represents a unique identifier for
    an input object in a future configuration, the \textbf{format} attribute
    specifies the format of this object.

    By creating an \textbf{configuration} element, adding a Boolean attribute
    \textbf{fresh} set to true and adding a single object of type input with
    the same values for the \textbf{id} and \textbf{format} attributes as an
    \textbf{input-configuration} a valid (initial) configuration can be obtained.

  \subsubsection{Configuration}

   The purpose of a configuration specification is to differentiate different
   behaviours of a tool and to be able to make a deterministic selection of the
   desired behaviour. Of course it depends on the developer of a tool if
   different behaviour can be observed from outside and to which extend this
   behaviour can be selected before run-time and maybe controlled interactively
   at run-time.

   This is not a novelty, programs with command line interfaces take arguments
   that are used to (re)produce this state non-interactively by means of a
   single string. The model behind this method of expressing a configuration is
   based on the idea that tasks consist of a sequence of operations each of
   which can be parametrised. A configuration is a selection between available
   operations and values for the parameters of each of these operations. On the
   command line such a configuration is represented as a string that consists
   of so-called options followed by values for the arguments of this option. We
   choose to reuse this model but will not use the same implementation as the
   traditional command-line interface.

   The controller is assumed to be oblivious to the data that is produced by
   tools. In particular the controller has registers what data is produced and
   the name by which this data is available, but it has no access to this data
   to inspect it. The application of a tools is restricted by the kind of data
   that they can take as input so a method is required to describe this
   information about the data. Such information is usually called the file-type
   or format and traditionally this information is encoded in a filename. A
   more modern approach is MIME (Multipurpose Internet Mail Extensions, \cite{rfc2822})
   that is widely used by applications and in other communication protocols.

   The structure of the data contained in a configuration message was specified
   at a higher level in the previous section. The translation to XML is as
   follows:

    \begin{verbatim}
     <configuration fresh="true" category="debugging">
      <option id="-v">
       <argument type="integer">1</argument>
      </option>
      <object id="in" type="input" location="" format=""/>
      <object id="out" type="output" location="" format=""/>
     </configuration>\end{verbatim}

   \noindent When the \text{fresh} attribute is not available it is assumed to
   be false. The \textbf{id} attributes to \textbf{option} and \textbf{object}
   elements represent the identifiers and all must be unique within the
   containing \textbf{configuration} element.  A \textbf{configuration} element
   can contain an arbitrary number of \textbf{object} and \textbf{option}
   elements in any order.

   An \textbf{option} element may contain an arbitrary number of
   \textbf{argument} elements that each represent a single typed-argument to the
   option. A number of predefined types is available for arguments to options:
   string, enumeration, integer, natural, positive, real. The types are used
   later to relieve the tool developer from having to ensure that the values that
   a user inputs as a string have the correct pattern.

   An \textbf{object} element must contain the \textbf{type} attribute, which
   specifies whether the tool takes it as input or produces it as output. It is
   forbidden to have two objects in the same configuration with different
   values for the \textbf{type} attribute. The \textbf{location} attribute is a
   URI (see \cite{rfc3305}), and the \textbf{format} attribute represents a data format
   characterisation using the syntax of the MIME standard.

  \subsubsection{Display}
   
   Display manipulation is restricted to filling the display with interface
   controls, by means of a layout specification, and modifying the state of
   these controls. In particular it is not possible to manipulate the layout
   itself. By now it sounds that we would have been better of picking up
   HTML/CSS. As far as functionality is considered HTML/CSS could have solved
   the problem. However we lack resources to complete the implementation in the
   first place and then make it work reliably on the targeted platforms and
   support it.

   We have chosen a limited subset of controls that can be used by tools in
   display layouts for version one of the protocol. It has however always been
   the intention of making it easy to add new controls to the repertoire. A
   quick detailed treatment for all controls follows:

    \begin{verbatim}
     <display-layout>
      <layout-manager>
       <box-layout-manager variant="vertical" id="">
        ...
       </box-layout-manager>
      </layout-manager>
     </configuration>\end{verbatim}

   A display layout specification is represented by a \textbf{display-layout}
   element that contains a single \text{layout-manager} element. The layout
   manager specifies the way in which elements are laid out across the display.
   All elements are laid out on the screen horizontally, or vertically and are
   expanded to fill space. The \textbf{box-layout-manager} has a
   \textbf{variant} attribute that specifies the direction in which the
   elements directly contained in it are laid out on the available space. The
   layout managers can be nested for more control on relative position of
   elements.

   All elements in the layout have an \textbf{id} attribute that must be unique
   within the scope of the containing \textbf{display-layout} element. The
   available elements are: \textbf{box-layout-manager}, \textbf{progress-bar},
   \textbf{radio-button}, \textbf{button}, \textbf{label}, \textbf{checkbox},
   \textbf{text\_field}.  These elements will be introduced later in this
   subsection.

   A number of layout properties provide more control over how elements are
   positioned and if they are visible and functional (enabled/disabled). The
   available properties are: alignment, margins (top, right, bottom, left),
   vertical alignment (top, middle, bottom), horizontal-alignment (left,
   center, right), element visibility and element activity. Every element that
   is a child of a layout manager is associated with a value for each of the
   layout properties.  Having an explicit value for each of the properties for
   each element in the specification would drastically increase its size, so a
   set of implicitly assumed default values are chosen.  The default properties
   are: alignment is left, no margins, elements are enabled and visible. The
   effective properties of an element are relative to that of the previous
   child. For example:

    \begin{verbatim}
 <box-layout-manager variant="vertical" id="">
  <properties margin-top="1" margin-bottom="1" horizontal-alignment="right">
  <button>Ok</button>
  <properties>
  <button>Cancel</button>
 </box-layout-manager>\end{verbatim}

   The layout properties for both buttons are the same, top and bottom margins
   are one pixel, vertical alignment is middle and horizontal alignment is right
   and both elements are visible and enabled. The \textbf{properties} element
   directly preceding a control defines the properties for that control. If
   there is no properties element then the previous \textbf{properties} element
   within the same layout manager defines the layout properties for that
   element.

   Now that it is clear what the structure of a layout specification looks
   like, the available controls will be described in more detail.The simplest
   controls are the label and the button.

    \begin{verbatim}
  <label id="x"><![CDATA[Cancel]]></label>
  <button id="y"><![CDATA[Cancel]]></button>
  <checkbox id="y" checked="true"><![CDATA[Cancel]]></checkbox>\end{verbatim}

   Please recall that for all controls the \textbf{id} attribute is mandatory.
   This example shows a label and a button with text Cancel. When the button is
   pressed this is communicated by sending a \msg{display\_data} message with the
   complete button specification. The checkbox has a description and is always
   in one of two states: checked or not. A more complex example is the
   radio-button control, because it is not a stand-alone control.

    \begin{verbatim}
  <radio-button id="x" connected="y"><![CDATA[first]]></radio-button>
  <radio-button id="y" connected="x" selected="true"><![CDATA[second]]></radio-button>\end{verbatim}

   Radio buttons are always grouped at all times only a single button in the
   group is be depressed.  By default the first radio button is selected, if
   another radio button should be selected then the \textbf{select} attribute
   must have value true. The radio buttons are connected by means of the
   \textbf{connected} attribute that contains the value of the \textbf{id}
   attribute of another radio button in the group. If the selection is changed
   then only the specification of the radio button that gets selected needs to
   be send by means of a \msg{display\_data} message to inform the other side
   of this event.

    \begin{verbatim}
  <text-field id="x"><text><![CDATA[100]]><text></text-field>\end{verbatim}

   The text field displays an input control for the user to put in text. It is
   much the same as the button control, but it contains a child element
   \textbf{text} that holds the content of the control. The reason for this
   difference is that pattern checking may be added in the future that may
   signal whether the data entered by the user matches the expectations of the
   tool developer. For example if the input box should contain a number then it
   cannot contain non-digit characters.

   The last control that was not treated is the progress bar. As the name
   suggests it is used to show progress to a user. It models progress by means
   of a sub range of the integer domain, specified by a minimum and maximum
   value and shows progress by colouring part of this domain up to some
   `current' value (that must be in the domain). The example is self
   explanatory:

    \begin{verbatim}
  <progress-bar id="x" minimum="10" maximum="20" current="15"/>\end{verbatim}

   Updates to change the status of a control have the exact same specification
   as in the layout specification. The \textbf{id} attribute identifies the
   control of which the status is to be updated. The remaining attributes
   specify the new value for the attribute with the same name and child
   elements specify other aspects of the state.

  \subsection{Extensibility}

   Protocol extension is performed by increasing the major version number and
   introducing the changes. The increase in version number is supposed to make
   it easy to test whether additional functionality with respect to previous
   versions is available and/or to signal compatibility mode. The nature of the
   changes is not described and therefore not restricted. Changes can be
   anything but only proper extensions are recommended.

  \section{Conclusion}

   The goal of the protocol is to control tools; configure them to do a
   specific task, start and stop task execution and allow (semi-)automatic
   repeat of a configuration. In addition it also includes remote generation of
   a graphical user interface in order to allow a user-friendly configuration
   process. The last functionality is mentioned separately because strictly
   speaking it is not a part of the controlling functionality, it is only
   needed to obtain a configuration, something which \emph{is} part of that
   functionality.

   Since the decision was made to create a custom implementation for our
   protocol, the XMPP protocol has been formalised by the IETF and it is now an
   open internet standard. It was (and remains) an option to use our protocol
   on top of XMPP, because he notion of a message is approximately the same for
   the protocols.
   
   It is still interesting to consider implementing this protocol on top of
   XMPP, because the latter has additional functionality that can be used to
   help solve other tool integration problems. An example of this is active
   communication between multiple tools through a publish-subscribe mechanism.
   A future extension to the protocol or perhaps even another protocol can
   offer such functionality.

  \enlargethispage*{4pt}
  \bibliography{references}

\end{document}
