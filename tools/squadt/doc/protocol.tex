\documentclass{article}
\usepackage[UKenglish]{babel}
\usepackage{graphicx}
\usepackage{calc}
\usepackage{latexsym,amssymb,amsfonts,amsthm,amsmath}
\usepackage{float}
\usepackage[top=3cm,left=3cm,bottom=3cm,right=3cm]{geometry}

\title{A Protocol for Interactively Controlling Software Tools}
\author{J. van der Wulp}

\newtheorem{example}{Example}

\newcommand{\msg}[1]{\texttt{#1}}

\bibliographystyle{alpha}

\begin{document}

\maketitle

 \section{Introduction}

  The communication protocol described in this document has been designed out
  of need for an abstract control layer for an interactive tool integration
  platform. In which a tool is a software program that can be used to fulfill
  certain tasks. There existed a set of very concrete ideas of the platform
  itself, and the protocol has been designed to fit some of its specific needs.

  There exists a proof-of-concept implementation of the platform mentioned
  previously in the shape of a desktop application called deskSQuADT. The first
  part of the name refers to the fact that it is a desktop application, and the
  second part stands for Systems Quality, Analysis and Design Toolset.  The
  deskSQuADT application is distributed as part of the mCRL2 toolset (see
  \cite{groote_et_al:DSP:2007:862}), a collection of tools around the formal
  modelling language mCRL2 that can be used for verification and analysis.  In
  and by itself deskSQuADT cannot be called a toolset, but the idea is that it
  integrates the tools that are connected, in this case some of the mCRL2
  tools.   The protocol described in this document is currently the primary
  means by which tools are connected.
%  Nevertheless the protocol that is the subject of this document is described
%  as independent as possible from the system in order to show that it, or at
%  the very least the underlying ideas, can be used outside it as well.

  The deskSQuADT application is by no means meant to be functionally complete
  in any way. There are plenty ideas on what works and what should be changed
  in possible future versions.  There are also a lot of ideas for future
  extension, for instance to make communication between tools possible as well.
  It is not necessarily the intention to incorporate all of such functionality
  into one protocol. The scope of this protocol is to interactively control
  single tools in much the same way as in which the standalone tool would be
  used.
  
  The functionality added by the system becomes visible when using a
  combination of tools subsequently or concurrently. The benefits are found at
  the level of integration: overview of data dependencies, guarding data
  consistency and (semi-)automated task execution.

  In abstract, the platform provides a number of facilities that can be used by
  tools to communicate with the user. The tools provide services that are made
  accessible to the user of the platform. The platform acts as a controller
  (possibly for multiple tools at the same time) and therefore the system will
  be referred to as (the) controller in the remainder of this document.
  Similarly, a tool is the communication partner of the controller.
%  \\[4pt]
%  The protocol described in this document is designed to be as minimal as
%  possible around the core ideas behind the system. Some care was taken to
%  allow future extensions.

  The remainder of this text is structured as follows. First the important
  concepts are introduced, to give the reader an overview of things involved.
  Next an abstract overview is given on the structure of communication: what
  messages are, what types of messages are used in the protocol, the meaning of
  those message and how the messages may interact. All of this is followed by a
  section that discusses implementation aspects such as the design choices that
  were made, along with motivation and an elaborate description of what
  messages look like in detail.

 \pagebreak

 \section{Concepts}

  \subsection{System}

   The system is a software application for interactive software tool
   integration. A concrete example of such a system would be deskSQuADT, but in
   the remainder of this document we will talk about system, or controller when
   viewing the system as a communication partner of a tool.

%   The protocol described in this document describes how the system and a
%   software tool communicate.
   
%   It is likely that the protocol will be extended in the future as more
%   functionality becomes available in the system.
   
  \subsection{Tool}

   A tool is a software program that can be executed multiple times
   concurrently on the same or a different machine.  A tool offers services to
   its environment, controlled by the user by means of the system. It is
   assumed that the end-user has particular goals in mind that require the use
   of functionality provided by a combination of different tools. The system
   will assist the user by finding and using the right tool at intermediate
   steps toward achieving the final goal.

   Applying a tool is assumed to consists of reading input and produce some
   result (output).  This result may or may not be a stepping stone for
   applying another tool on that result (or part thereof).  For example one
   tool generates a 3D model of a tree at random and another tool can be used
   to view and manipulate this model. The result is not required to be
   concrete. For example a visualisation tool might to give a user insight
   through different views on the input, but has otherwise probably no concrete
   result that another tool can continue with.
   
   We assume that the only direct communication between tools is
   uni-directional trough persistent storage (think of files in a filesystem).
   In particular no tools should not mutually depend on each others existence.
   If such a dependency does exist among tools then this dependency can be
   eliminated by treating their combination as a single tool.

   So a tool can be any computer program. It can be tools with a command line
   interface or more complex programs with graphical user interfaces.  There
   can be large differences between the required degree of user interactivity
   for different tools.

  \subsection{Task Configuration}

   Tools may have different services to offer, but an end-user may only be
   interested in a very specific service, namely the one that helps completing
   the task at hand. Configuration is the name of the process of bringing a
   tool into a state from where it can be started to perform a certain task
   pertaining to some of the functionality offered by the tool. A \textit{task}
   is an indivisible amount of work with a concrete result that a tool can
   perform.  A tool is not required to complete a task autonomously after it is
   started.
   
   A (task) \textit{configuration} is a formal specification that uniquely
   defines a task up to user-interaction. A tool must be able to use a valid
   configuration to bring itself in a configured state from which it will
   always perform that same task. Configurations are bound to a tool, sometimes
   even specific versions of it. A configuration for one tool may not be a
   valid configuration for another. Or a configuration for version 1.0 may not
   be valid for version 1.1; this is up to the developer of the tool.
   
   For some tools user user-interaction is inherently a part of the task and in
   a way can be viewed as part of the configuration process. Our purpose for
   defining a task and a configuration as means of uniquely defining a task is
   to have a manner to (semi)automatically recreate this task by circumventing
   all or part of the user-interaction. Control about exactly what user
   interaction is required and what not is in the hands of the tool developer.

   We assume that the system does not have to interpret a configuration except
   to find out what input is needed for the task and what output is produced by
   the task. Apart from input/output the semantics of the configuration are
   determined by the tool. The conceived use of a configuration is as follows.
   On request a tool in any configured state $s$, must specify its
   configuration $c$.  At a later time the tool may be requested to recreate
   the configured state from $c$. The resulting configured state must of course
   be $s$.

%   The information that the tool requires to bring itself into a
%   configured state must be captured somehow and cast into a form that allows
%   it can be stored. This allows the same configured state to be recreated at a
%   later time.

%   The process of configuration is to bring the tool in a state where it will
%   perform the desired task. A formalism is needed to capture this state such
%   that it can be reproduced later. For our purposes a \textit{configuration}
%   is a concrete specification that can be used to bring a tool into a state
%   where it will perform the desired task.

  \subsection{Tool Display}

   All communication between the user and a system is assumed to take place via
   the inputs to the tool and any facilities that the system will provide for
   such communication. The \textit{tool display} is a system facility that
   offers an interactive display to user of the system of which the content is
   controlled by a single tool. As long as a tool is running a tool display is
   associated with it.

   Tools are not required to use the tool display at all. It is an optional
   facility that is available for when user interaction is needed. Recall that
   the purpose of the system is to integrate functionality provided by tools.
   From this perspective bypassing the tool display cannot be recommended as it
   sacrifices the uniformity of communication between a user and a tool.
   Nevertheless in some cases it may be a necessity because the tool display
   does not offer the desired functionality.

   The availability of a facility like the tool display in a protocol to
   control tools is questionable. This functionality does not seem to fit the
   purpose. The control aspect does not refer to total control of a tool in the
   sense that user-interaction is cut out. In fact it is not the system that
   asserts the control over tool, but rather the user does by means of the system.

%   The full extend to which the display can be manipulated will not be
%   described in this document. The original idea was that the protocol
%   provides the means for putting user interface controls on the display and
%   to support interaction with these controls. This however, requires the
%   protocol description to be updated every time as. It is up to the system to
%   provide a number of these interface controls that a tool requires for
%   operation.

 \section{Protocol (high level)} \label{s:message_definitions}

  The protocol is defined in terms of a number of typed messages. The semantics
  of a message may depend on the type, the direction in which the message
  travels (controller-to-tool or tool-to-controller) and the messaging context.
  In which the context of a message $m$ is the ordered list of all sent and
  received messages (assuming strict interleaving) up to the point that $m$ is
  sent or received.

  The protocol behaves asynchronous at any moment a request can arrive for any
  of the communication partners. After communication initiation, of which the
  initiative is at the side of a tool, the initiative is determined by which
  side sends a request.

  Typical patterns are request-response sequences. When one side sends a
  request, say a message with a type $t$, the other side \emph{must} respond
  after it has received with message with an acknowledgement, which is also a
  message of type $t$. After sending the request the sender can wait for the
  response provided that in the meanwhile it sends responds for all incoming
  requests. This avoids deadlock, i.e. both sides waiting on response for
  requests to one another.

  \subsection{Instance identification}

   When a tool is started it will initiate communication with a controller.
   The details on how the communication can be initiated is somehow
   communicated outside this protocol. On new incoming communication the
   controller has no way of knowing what lives on the other side of the
   connection. The tool should identify itself by presenting a secret. The
   first message after a connection has been established must be structured as
   follows.
   
   \begin{figure}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
      message type:    & \msg{identification} \\
      \hline
      direction:       & tool to controller \\
      data:            & token \\
      \hline
     \end{tabular}
    \end{center}
   \end{figure}

   \noindent When started the tool is given a token which it should sent as
   part of this message. The controller must sever the connection if the first
   message is not an identification message, or if the token was not among
   those that were expected. It is assumed that the controller has knowledge
   about what tools are expected to connect and each of them can be identified
   by their token.  Messages of this type must be ignored if they are not the
   first message after the connection has been established.

  \subsection{Capabilities}

   Exchange of capabilities represents a manner of communicating available
   functionality on both the side of a tool and that of a controller.  Such
   functionality can be used to offer implementation dependent functionality
   that is not (or not yet) prescribed by the protocol. Only the basic
   structure of the message is prescribed as it is determined by anyone who
   implements it. This is the recommended way of adding implementation
   dependent extensions to the protocol functionality without changing the
   protocol specification.

   A useful example of an implementation dependent extension is adding a new
   control for the tool display. The tool can check the capabilities of the
   controller to see whether the control is available. If it is available it
   can use it just like any other control in the tool display (see section
   \ref{ss:user_interaction}).

   The extension mechanism works the same in both ways (controller-to-tool or
   vice versa). The whole mechanism basically is a request-response, where the
   request is fixed and the response can be arbitrarily complex. The request
   represents a query for the other side's capabilities. The response is the
   combined set of capabilities. A request can be sent from any context and has
   the following structure.

   \begin{figure}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
      message type:    & \msg{capabilities} \\
      \hline
      data:            & none \\
      \hline
     \end{tabular}
    \end{center}
   \end{figure}

   The controller, when it receives a capabilities request must respond with a
   message that contains at least the following information.

   \begin{figure}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       message type:   & \msg{capabilities} \\
      \hline
       direction:      & controller to tool \\
       data:           & Version = struct major : Nat $|$ minor : Nat \\
      \hline
     \end{tabular}
    \end{center}
   \end{figure}

   \noindent The tool, when it receives a request for capabilities must also respond with
   a similar message. The difference with the response from the controller is
   in the fact that the tool must advertise its functionality. To operate, the
   tool requires input. Based on what the input represents (characterised by a
   format), it offers functionality (characterised by a category).
   
   \begin{figure}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       message type:   & \msg{capabilities} \\
      \hline
       direction:      & tool to controller \\
       data:           & version $\times$ List (input-configuration) \\
                       &  version             = struct major : Nat $|$ minor : Nat \\
                       &  input-configuration = category $\times$ List (id $\times$ format) \\
                       &  category            = String,   a name that characterises the function of the tool \\
                       &  format              = storage format specifier for the tools main input \\
      \hline
     \end{tabular}
    \end{center}
   \end{figure}

   \noindent The combination of a category and a list of pairs of a unique name and a
   format is called an \textit{input configuration} of the tool.  The available
   input configurations, in a rather abstract fashion represent the range of
   functionality offered by the tool.  An input configuration can also be
   considered as a template for a configuration (see section
   \ref{ss::tool_configuration}). The controller may use the category names
   in an input configuration to categorise tools based on functionality. The
   pairing of a name and a format represents a name for a typed input slot. The
   idea is that to make use of functionality associated with a particular input
   configuration all of the input slots need to be `filled' with valid input
   sources (e.g. files).

  \subsection{Tool Configuration} \label{ss::tool_configuration}

   The controller makes use of the services provided by a tool through task
   configuration. After that the task that is performed makes use of a
   selection of the functionality that the tool provides.  Configuration and
   task execution are separated, the latter is discussed in the section
   \ref{ss::task_execution}.

   Tool configuration is a two step process. First the controller sends a
   configuration. The tool inspects this configuration and responds with a
   verdict on whether or not the configuration is valid. A valid configuration
   has the property that it can be used to successfully configure the tool. A
   configuration message may be sent from any context and has the following
   structure:

   \begin{figure}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       message type:   & \msg{configuration} \\
      \hline
       direction       & controller to tool \\
       data:           & fresh $\times$ Configuration \\
                       & \ Configuration = category $\times$ List (option) $\times$ List(object) \\
                       & \ \ fresh   = Bool \\
                       & \ \ option  = id $\times$ List(data-type $\times$ String) \\
                       & \ \ object  = id $\times$ io-type $\times$ format $\times$ URI \\
                       & \ \ io-type = struct input $|$ output \\
      \hline
     \end{tabular}
    \end{center}
   \end{figure}

   \noindent The message describes a freshness marking, and a configuration. A
   fresh configuration is a configuration that is generated by the controller
   using information from capability messages. The configuration itself
   consists of a category name, a list of options and a list of input/output
   objects. The category name has a cosmetic function only; it describes the
   functionality the tool will use to perform the task. The list of options,
   represents the total of options as well as values for possible arguments to
   those options.

   Before sending any response the tool may initiate user interaction (see
   subsection \ref{ss:user_interaction}) in order to refine the configuration.
   The second step of configuration is the response message. This response
   signals whether a configured state can be created from the configuration.
   The response message has the same structure structure as the request:

   \begin{figure}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       message type:   & \msg{configuration} \\
      \hline
       direction       & tool to controller \\
       data:           & valid $\times$ Configuration \\
                       & \ valid = Bool \\
      \hline
     \end{tabular}
    \end{center}
   \end{figure}

   \noindent The only difference between the request and the response is that
   the validity marking. The message indicates by means of the validity marking
   whether the embedded configuration is valid. A configuration is called
   accepted if a response marks it as valid.

   It is assumed that the embedded configuration has a strong resemblance to
   the configuration embedded in the request. There is only one restriction,
   the category embedded in both configurations must be the same in both the
   request and the response. The underlying idea is that the tool would start
   with the configuration from the request, determine its validity and possibly
   refine it by consulting the user. How much the configurations in the request
   and response messages resemble each other depends on the creativity of the
   tool developer.

   For a configuration request message the controller needs a configuration for
   that specific tool.  The controller can obtain configurations in two ways.
   It can generate a configuration from a single input configuration (as
   received from a previous \msg{tool\_capabilities} message). In this case the
   configuration must be marked as fresh. Alternatively the controller can use
   any configuration for a tool that was previously considered valid by that
   tool.

%   \noindent About the configuration specifications: every option is uniquely
%   identified, and so is every object. The reason is to make it easier for a
%   tool developer to test for availability of options/objects.  An option
%   represents an atomic unit in the configurable behaviour of a tool. For
%   validation purposes a data type can be specified against which the values
%   for the option are matched. An object is a file associated with a format and
%   a location.

  \subsection{Task Execution} \label{ss::task_execution}

   \noindent Tool configuration is complete when the controller receives a
   configuration response message with an accepted configuration and it has not
   sent a new configuration request.  When configuration is complete the
   controller may start task execution with message with the following
   structure: 

   \begin{figure}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       message type:   & \msg{task\_start} \\
      \hline
       direction       & controller to tool \\
      \hline
     \end{tabular}
    \end{center}
   \end{figure}

   \noindent On receipt of such a message a tool must start executing a task
   based on the last accepted configuration. The controller has the
   responsibility to ensure that the input objects in a configuration exist
   prior to starting a task that depends on them, and ensure that they remain
   unchanged (by the environment) during task execution. Likewise, the output
   objects must not exist or be modifiable by the tool prior to starting a
   task, and it must ensure that the environment leaves the outputs unchanged
   during task execution.

   When a task has been completed the tool must send a response to the
   controller that signals this fact. From a context where a \msg{task\_start}
   has been received and no subsequent \msg{task\_done} has been sent a tool
   may send a message with the following structure:

   \begin{figure}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       message type:   & \msg{task\_done} \\
      \hline
       direction       & tool to controller \\
       data            & result : Bool \\
      \hline
     \end{tabular}
    \end{center}
   \end{figure}

   \noindent which signifies that execution of the task has finished. The
   result signifies success or failure in task execution.

  \subsection{Tool Termination}

   \noindent The controller can request a tool to terminate. This facility is
   present to allow tools to free resources and remove outputs or leave
   them in a consistent state.

   \begin{figure}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       message type:    & \msg{termination} \\
      \hline
       direction:       & controller to tool \\
       data:            & none \\
      \hline
     \end{tabular}
    \end{center}
   \end{figure}

   \noindent As a response the tool should sent a message with the following
   structure:

   \begin{figure}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       message type:   & \msg{termination} \\
      \hline
       direction:      & tool to controller \\
       data:           & none \\
      \hline
     \end{tabular}
    \end{center}
   \end{figure}

   If, after a reasonable amount of time has past without a response, the
   controller may terminate the tool through other means.

  \pagebreak

  \subsection{User interaction} \label{ss:user_interaction}

   For user interaction a tool depends on the facilities provided by the
   controller. The controller shows a display to the user on behalf of each
   tool.  A tool can communicate with a user by listening and responding to
   user-interaction with the display. The controller captures and relays all
   user interaction with the display to the tool. A tool can either alter the
   content of the display entirely or update the internal state of some
   controls it contains.

   To use the display, a tool must send a valid layout specification first.
   The controller can use it to fill the display. The layout specification
   describes the controls and layout constraints that must be observed for
   laying them out on the display. Every time a layout specification is sent in
   this fashion it replaces the contents of the display. From any context the
   a message structured as follows may be used communicates a layout specification.
%\footnote{It would be nice if these controls are not part of the protocol but added
%   through the extension mechanism (because they are highly implementation
%   specific)}. 
   
   \begin{table}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       message type:   & \msg{display\_layout} \\
      \hline
       direction:      & tool to controller \\
       data:           & element = struct box(direction $\times$ List(properties $\times$ element)) $|$ control \\
                       & \ direction = struct horizontal $|$ vertical \\
                       & \ properties = struct visibility $|$ input $|$ margin $|$ alignment \\
                       & \ \ visibility = struct visible $|$ hidden \\
                       & \ \ input = struct enabled $|$ disabled \\
                       & \ \ margin = struct left $|$ top $|$ right $|$ bottom \\
                       & \ \ alignment = struct horizontal(struct left $|$ center $|$ right) $|$ \\
                       & \ \                    vertical(struct bottom $|$ middle $|$ top) \\
                       & \ control = progress\_bar $|$ radio\_button $|$ button $|$ label $|$ text\_field $|$ checkbox \\
                       & \ \ progress\_bar = Nat $\times$ Nat $\times$ Nat \\
                       & \ \ radio\_button = Bool \\
                       & \ \ button        = String \\
                       & \ \ label         = String \\
                       & \ \ text\_field   = String \\
      \hline
     \end{tabular}
    \end{center}
   \end{table}
   \vspace{-0.4cm}
   \noindent Every layout element has a unique identifier that can be used in
   subsequent messages to signal or change the state of a control. A layout is
   specified as a nested box elements that contain controls. Each control is
   associated with a set of layout properties that affect the way in which the
   control is placed on the display. The horizontal or vertical direction of a
   box determines the way it lays out the elements it contains above or beside
   each other respectively.

   The layout properties further affect layout of elements relative to each
   other or the containing box. Visibility determines whether a layout element
   is visible or not. Input determines whether a control is active, i.e.
   whether it responds to user interaction. Margins control the distance
   between the directly adjacent elements. For first and last elements this
   means the distance to the borders of the containing box. A box equally
   divides the amount of available space over the available controls. When
   there is plenty of space after deduction of margins the alignment can be
   used to control either the vertical or horizontal position of a control
   within the available space.

   The following message is used to communicate changes to a control on the
   display.

   \begin{figure}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       message type:   & \msg{display\_data} \\
      \hline
       direction:      & both \\
       data:           & id $\rightarrow$ state \\
      \hline
     \end{tabular}
    \end{center}
   \end{figure}
   \vspace{-0.4cm}
   \noindent The interpretation of the message depends on the direction of the
   message. When a tool receives the message it is interpreted as a change in
   the state of a control on the display. When the controller receives such a
   message it is interpreted as a request to change the state of a control on
   the display. If the id is unknown at the receiving side then the message
   must be ignored.
%    A tool can change the state of controls on a display by means of their
%    identifier. The following message must be used for this purpose.

  \subsection{Tool Report}

   From any context a tool can send a report that signifies a warning, error or
   just some information.

   \begin{figure}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       message type:   & \msg{report} \\
      \hline
       direction:      & tool to controller \\
       data:           & struct notice $|$ warning $|$ error $\times$ description \\
      \hline
     \end{tabular}
    \end{center}
   \end{figure}

   \noindent The controller will probably pass it through to the user but
   it has no effect on protocol state. Before termination a tool can report to
   the controller about what has been done. This report can contain anything
   from general information to errors. A controller can display this in some
   way to the user.

 \section{Implementation} \label{s:protocol_implementation}

   Section \ref{s:message_definitions}, presented a high level view of the
   protocol. The main characteristics are that all messages are typed, and that
   the origin of the message (or the direction in which it travels) determines
   how it should be interpreted. Also significant, but not explicitly mentioned
   is that message order is preserved. Other important functionality is
   authentication, which was made a part of the protocol.  Meaning that the
   choice was already made to include authentication functionality in the
   protocol instead of relying on another protocol that has this functionality.

   In terms of the seven layers of the OSI model \cite{Day1983}, our protocol
   only covers the 6th (presentation) layer. All functionality below the
   presentation layer will be provided through the use of standard protocols
   (see section \ref{ss:transport}).
   
  \subsection{Transport} \label{ss:transport}

   For the actual transport of data the TCP/IP protocol suite is the best
   contender. It satisfies all requirements discussed at the start of this
   section. More specifically, it provides:
    \begin{itemize}
     \item state-full connection which allows authentication at initiation
     \item data is delivered in the order in which it was offered
    \end{itemize}
   Furthermore TCP/IP is available on many platforms and usable from many
   different programming languages.

   A possible alternative would have been to use standard input/output streams
   (or piping).  The disadvantage of this facility is that there is not
   built-in support in many programming languages to do non-blocking
   communication. This is a strict requirement because of the asynchronous
   nature of the protocol. A further disadvantage over TCP/IP is that all
   communication is limited to the same machine.

%   The TCP/IP protocol suite is chosen as the recommended means of
%   transport. It is well-known and supported by a lot of programming languages.
%   The protocol requires connection-state, a tool is authenticated once and on
%   failure the connection is terminated. In addition, because meaning is
%   assigned to the order of messages, the protocol requires that messages are
%   delivered in the same order as which they were offered to the sender. All
%   requirements are all supported by TCP/IP, note that for UDP/IP this is not
%   the case.

  \subsection{Messaging}

   In the previous subsection TCP/IP was established as a good candidate for
   data transport. All that is needed next is a messaging mechanism for
   communication of arbitrary content between the communication partners.  An
   existing protocol that offers a messaging mechanism and as added bonus also
   offers authentication is XMPP core (Extensible Messaging and Presence Protocol,
   \cite{rfc3920}).  It is a simple communication protocol that that relies on
   TCP/IP to transport two XML (see \cite{Sperberg-McQueen:06:EML}) streams
   (one for each direction).

   The XMPP core messaging mechanism can be used as a basis for our protocol.
   The only disadvantage at this point is no suitable standalone implementation
   seems to be available that suits all of our needs. Creating our own XMPP
   core implementation would take too much time, especially the authentication
   would require a substantial amount of time. We are more interested in the
   results obtained from using this protocol in the context of the interactive
   tool integration system. Instead of using XMPP core directly a very similar
   looking messaging mechanism will be developed in the next section.

   XMPP has the notion of a message that can be sent from client to client, on
   top of it our protocol can be implemented.   Unfortunately no single
   client/server side implementations exist at the time that are usable on all
   target platforms without also introducing quite a number of other
   dependencies. Creating our own implementation would have taken to much time,
   especially when we would have implemented all of XMPP.  So we choose a lightweight
   custom implementation, instead of using XMPP with 3rd-party client and
   server implementations.

   The choice for XML is obvious we aim for extensibility and XML to some
   extend allows changes to the format extensions to the format there is wide
   support in many programming languages. With XML it is possible to create a
   good parser that is to some extent resistant to extensions, meaning it will
   also work on future versions of the format that may contain additional
   information.  Another benefit of using XML is it makes the messages
   readable, making it easy to print and manually verify the structure and
   contents.

   \subsubsection{Structure} \label{ss:structure}

    \noindent messages are wrapped in the \textbf{message} element. A mandatory
    attribute is \textbf{type} that specifies the type of the message, it may
    occur only once. For example:
 
    \begin{verbatim}
     <message type="termination"><![CDATA[message content]]></message>\end{verbatim}

    The content of a message is wrapped as so-called CDATA section. It means
    that the data inside is not interpreted when parsing a message. As a
    consequence a message that has invalid XML as content can still be valid
    XML itself.

  \subsection{Message Content}

   The structure of an XML document is usually specified using XML Document
   Type Declaration (\cite{Sperberg-McQueen:06:EML}) or the XML Schema standard
   \cite{Malhotra:06:XSP}. Many people find this difficult to read and
   discussing semantics is easier by showing small examples of constructs. So
   the translation of the functional specification of the previous section to
   XML is sketched by means of examples. Needless to mention: all messages must
   be valid XML.

  \subsubsection{Authentication}

   Instead of a full-featured authentication scheme we choose a simple instance
   identification scheme. Of course security is something that should be part
   of the design and the security of this solution is very poor from that
   perspective. It only solves the technical problem of identifying the peer
   assuming that everyone has good intentions. This is something we did
   realise. The only justification for this is in the fact implementing
   cross-platform authentication is still a non-trivial undertaking despite of
   all libraries that are available today.  At this point, security is not a
   focus point in this project and getting a multi-platform software
   application to prove the viability of interactive tool integration is.

   As far as the message structure is concerned; an identification message
   contains a single string as content. The string represents the token
   mentioned in the previous section, that is used by the controller to
   identify the communication partner.

  \subsubsection{Capabilities}

   Messages for communicating the capabilities of each of the communication
   partners contain at the very least the version of the protocol. For example:

    \begin{verbatim}
     <capabilities>
      <protocol-version major="1" minor="0"/>
     </capabilities>\end{verbatim}

   A capabilities message sent in reply to a request for capabilities by the
   controller. Contains the input-configurations in addition to the version
   number. So in addition the \textbf{capabilities} element may contain any
   number of \textbf{input-configuration} elements as follows:

    \begin{verbatim}
     <capabilities>
      <protocol-version major="1" minor="0"/>
      <input-configuration category="" format="" id=""/>
     </capabilities>\end{verbatim}

    All attributes: \textbf{category}, \textbf{format} and \textbf{id} are
    mandatory.  The \textbf{category} attribute is an arbitrary string which
    represents a name that characterises functionality targeted by the input
    configuration. The \textbf{id} attribute represents a unique identifier for
    an input object in a future configuration, the \textbf{format} attribute
    specifies the format of this object.

    By creating an \textbf{configuration} element, adding a Boolean attribute
    \textbf{fresh} set to true and adding a single object of type input with
    the same values for the \textbf{id} and \textbf{format} attributes as an
    \textbf{input-configuration} a valid (initial) configuration can be obtained.

  \subsubsection{Configuration}

   The purpose of a configuration specification is to differentiate different
   behaviours of a tool and to be able to make a deterministic selection of the
   desired behaviour. Of course it depends on the developer of a tool if
   different behaviour can be observed from outside and to which extend this
   behaviour can be selected before run-time and maybe controlled interactively
   at run-time.

   This is not a novelty, programs with command line interfaces take arguments
   that are used to (re)produce this state non-interactively by means of a
   single string. The model behind this method of expressing a configuration is
   based on the idea that tasks consist of a sequence of operations each of
   which can be parametrised. A configuration is a selection between available
   operations and values for the parameters of each of these operations. On the
   command line such a configuration is represented as a string that consists
   of so-called options followed by values for the arguments of this option. We
   choose to reuse this model but will not use the same implementation as the
   traditional command-line interface.

   The controller is assumed to be oblivious to the data that is produced by
   tools. In particular the controller has registers what data is produced and
   the name by which this data is available, but it has no access to this data
   to inspect it. The application of a tools is restricted by the kind of data
   that they can take as input so a method is required to describe this
   information about the data. Such information is usually called the file-type
   or format and traditionally this information is encoded in a filename. A
   more modern approach is MIME (Multipurpose Internet Mail Extensions, \cite{rfc2822})
   that is widely used by applications and in other communication protocols.

   The structure of the data contained in a configuration message was specified
   at a higher level in the previous section. The translation to XML is as
   follows:

    \begin{verbatim}
     <configuration fresh="true" category="debugging">
      <option id="-v">
       <argument type="integer">1</argument>
      </option>
      <object id="in" type="input" location="" format=""/>
      <object id="out" type="output" location="" format=""/>
     </configuration>\end{verbatim}

   \noindent When the \text{fresh} attribute is not available it is assumed to
   be false. The \textbf{id} attributes to \textbf{option} and \textbf{object}
   elements represent the identifiers and all must be unique within the
   containing \textbf{configuration} element.  A \textbf{configuration} element
   can contain an arbitrary number of \textbf{object} and \textbf{option}
   elements in any order.

   An \textbf{option} element may contain an arbitrary number of
   \textbf{argument} elements that each represent a single typed-argument to the
   option. A number of predefined types is available for arguments to options:
   string, enumeration, integer, natural, positive, real. The types are used
   later to relieve the tool developer from having to ensure that the values that
   a user inputs as a string have the correct pattern.

   An \textbf{object} element must contain the \textbf{type} attribute, which
   specifies whether the tool takes it as input or produces it as output. It is
   forbidden to have two objects in the same configuration with different
   values for the \textbf{type} attribute. The \textbf{location} attribute is a
   URI (see \cite{rfc3305}), and the \textbf{format} attribute represents a data format
   characterisation using the syntax of the MIME standard.

  \subsubsection{Display}
   
   Display manipulation is restricted to filling the display with interface
   controls, by means of a layout specification, and modifying the state of
   these controls. In particular it is not possible to manipulate the layout
   itself. By now it sounds that we would have been better of picking up
   HTML/CSS. As far as functionality is considered HTML/CSS could have solved
   the problem. However we lack resources to complete the implementation in the
   first place and then make it work reliably on the targeted platforms and
   support it.

   We have chosen a limited subset of controls that can be used by tools in
   display layouts for version one of the protocol. It has however always been
   the intention of making it easy to add new controls to the repertoire. A
   quick detailed treatment for all controls follows:

    \begin{verbatim}
     <display-layout>
      <layout-manager>
       <box-layout-manager variant="vertical" id="">
        ...
       </box-layout-manager>
      </layout-manager>
     </configuration>\end{verbatim}

   A display layout specification is represented by a \textbf{display-layout}
   element that contains a single \text{layout-manager} element. The layout
   manager specifies the way in which elements are laid out across the display.
   All elements are laid out on the screen horizontally, or vertically and are
   expanded to fill space. The \textbf{box-layout-manager} has a
   \textbf{variant} attribute that specifies the direction in which the
   elements directly contained in it are laid out on the available space. The
   layout managers can be nested for more control on relative position of
   elements.

   All elements in the layout have an \textbf{id} attribute that must be unique
   within the scope of the containing \textbf{display-layout} element. The
   available elements are: \textbf{box-layout-manager}, \textbf{progress-bar},
   \textbf{radio-button}, \textbf{button}, \textbf{label}, \textbf{checkbox},
   \textbf{text\_field}.  These elements will be introduced later in this
   subsection.

   A number of layout properties provide more control over how elements are
   positioned and if they are visible and functional (enabled/disabled). The
   available properties are: alignment, margins (top, right, bottom, left),
   vertical alignment (top, middle, bottom), horizontal-alignment (left,
   center, right), element visibility and element activity. Every element that
   is a child of a layout manager is associated with a value for each of the
   layout properties.  Having an explicit value for each of the properties for
   each element in the specification would drastically increase its size, so a
   set of implicitly assumed default values are chosen.  The default properties
   are: alignment is left, no margins, elements are enabled and visible. The
   effective properties of an element are relative to that of the previous
   child. For example:

    \begin{verbatim}
 <box-layout-manager variant="vertical" id="">
  <properties margin-top="1" margin-bottom="1" horizontal-alignment="right">
  <button>Ok</button>
  <properties>
  <button>Cancel</button>
 </box-layout-manager>\end{verbatim}

   The layout properties for both buttons are the same, top and bottom margins
   are one pixel, vertical alignment is middle and horizontal alignment is right
   and both elements are visible and enabled. The \textbf{properties} element
   directly preceding a control defines the properties for that control. If
   there is no properties element then the previous \textbf{properties} element
   within the same layout manager defines the layout properties for that
   element.

   Now that it is clear what the structure of a layout specification looks
   like, the available controls will be described in more detail.The simplest
   controls are the label and the button.

    \begin{verbatim}
  <label id="x"><![CDATA[Cancel]]></label>
  <button id="y"><![CDATA[Cancel]]></button>
  <checkbox id="y" checked="true"><![CDATA[Cancel]]></checkbox>\end{verbatim}

   Please recall that for all controls the \textbf{id} attribute is mandatory.
   This example shows a label and a button with text Cancel. When the button is
   pressed this is communicated by sending a \msg{display\_data} message with the
   complete button specification. The checkbox has a description and is always
   in one of two states: checked or not. A more complex example is the
   radio-button control, because it is not a stand-alone control.

    \begin{verbatim}
<radio-button id="x" connected="y"><![CDATA[first]]></radio-button>
<radio-button id="y" connected="x" selected="true"><![CDATA[second]]></radio-button>\end{verbatim}

   Radio buttons are always grouped at all times only a single button in the
   group is be depressed.  By default the first radio button is selected, if
   another radio button should be selected then the \textbf{select} attribute
   must have value true. The radio buttons are connected by means of the
   \textbf{connected} attribute that contains the value of the \textbf{id}
   attribute of another radio button in the group. If the selection is changed
   then only the specification of the radio button that gets selected needs to
   be send by means of a \msg{display\_data} message to inform the other side
   of this event.

    \begin{verbatim}
  <text-field id="x"><text><![CDATA[100]]><text></text-field>\end{verbatim}

   The text field displays an input control for the user to put in text. It is
   much the same as the button control, but it contains a child element
   \textbf{text} that holds the content of the control. The reason for this
   difference is that pattern checking may be added in the future that may
   signal whether the data entered by the user matches the expectations of the
   tool developer. For example if the input box should contain a number then it
   cannot contain non-digit characters.

   The last control that was not treated is the progress bar. As the name
   suggests it is used to show progress to a user. It models progress by means
   of a sub range of the integer domain, specified by a minimum and maximum
   value and shows progress by colouring part of this domain up to some
   `current' value (that must be in the domain). The example is self
   explanatory:

    \begin{verbatim}
  <progress-bar id="x" minimum="10" maximum="20" current="15"/>\end{verbatim}

   Updates to change the status of a control have the exact same specification
   as in the layout specification. The \textbf{id} attribute identifies the
   control of which the status is to be updated. The remaining attributes
   specify the new value for the attribute with the same name and child
   elements specify other aspects of the state.

  \subsection{Extensibility}

   Protocol extension is performed by increasing the major version number and
   introducing the changes. The increase in version number is supposed to make
   it easy to test whether additional functionality with respect to previous
   versions is available and/or to signal compatibility mode. The nature of the
   changes is not described and therefore not restricted. Changes can be
   anything but only proper extensions are recommended.

  \section{Conclusion}

   The goal of the protocol is to control tools; configure them to do a
   specific task, start and stop task execution and allow (semi-)automatic
   repeat of a configuration. In addition it also includes remote generation of
   a graphical user interface in order to allow a user-friendly configuration
   process. The last functionality is mentioned separately because strictly
   speaking it is not a part of the controlling functionality, it is only
   needed to obtain a configuration, something which \emph{is} part of that
   functionality.

   The deskSQuADT application currently uses the protocol as its only method
   for controlling tools. The most important features provided by the current
   version of deskSQuADT are:
    \begin{itemize}
     \item dependencies generated by application of tools on files are
     visualised
     \item change propagation through (semi-)automated task execution for
     repeating tasks; changes in input are detected and tools are re-executed
     on request to ensure up-to-date outputs
     \item data consistency is guarded by avoiding concurrent execution of
     tasks that share inputs or outputs
    \end{itemize}
   All of these features are the result of functionality purposefully built
   into the protocol.

   Since the decision was made to create a custom implementation for the
   protocol, see section \ref{s:protocol_implementation}, the XMPP protocol has
   been formalised by the Internet Engineering Task Force (IETF). This means it
   is now an open internet standard. Because he notion of a message is
   approximately the same for the protocols, It was (and remains) an option to
   use our protocol on top of XMPP.

   It is still interesting to consider implementing this protocol on top of
   XMPP. The latter has additional functionality that can be used to help solve
   other tool integration problems. An example of this is active communication
   between multiple tools through a publish-subscribe mechanism.  A future
   extension to the protocol or perhaps even another protocol can offer such
   functionality.

  \enlargethispage*{4pt}
  \bibliography{references}

\end{document}
