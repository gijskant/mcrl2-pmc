\documentclass{article}
\usepackage[UKenglish]{babel}
\usepackage{pslatex}
\usepackage{graphicx}
\usepackage{calc}
\usepackage{latexsym,amssymb,amsfonts,amsthm,amsmath}
\usepackage{float}
\usepackage{verbatim}
\usepackage{xspace}

\usepackage[top=3cm,left=3.3cm,bottom=3cm,right=3.3cm]{geometry}

\title{A Protocol for Interactively Controlling Software Tools\\DRAFT}
\author{J. van der Wulp}

\newtheorem{example}{Example}

\newcommand{\msg}[1]{\texttt{#1}}
\newcommand{\squadt}{SQuADT\xspace}

\makeatletter
\renewcommand{\paragraph}{\@startsection
  {paragraph}%
  {4}%
  {-1.3em}%
  {-\baselineskip}%
  {0.1\baselineskip}%
  {\normalfont\normalsize\textbf}}
\makeatother

%\setlength{\parindent}{0cm}
%\setlength{\parskip}{\baselineskip}

\bibliographystyle{alpha}

\begin{document}

\maketitle
\thispagestyle{empty}

 \section{Introduction}

  The mCRL2 toolset (see \cite{groote_et_al:DSP:2007:862}) is a collection of
  tools around the formal modelling language mCRL2 that can be used for formal
  verification and analysis of process behaviour.  Most of the tools have a
  traditional command line interface and today not everyone is comfortable with
  this way of working.  Therefore we started working on a tool integration
  framework to make the toolset usable for a broader audience. The idea is that
  a uniform graphical user interface should make it easier to use tools without
  having too much knowledge about the specifics of every tool.  The focus is
  simplifying the use of individual tools as well as combinations of tools and
  to automate frequently occurring tasks that involve the use of multiple
  tools.
  
  The \squadt desktop application is a graphical user interface layer around a
  new tool integration framework, within which a central part is played by the
  communication protocol described in this text.  The name \squadt, stands for
  Systems Quality, Analysis and Design Toolset, which refers to the kind of
  tasks that can be performed with the connected tools. The connected tools are
  those found in the mCRL2 toolset. Most of these the tools can be used
  stand-alone by means of a traditional command line interface and some with a
  graphical user interface.  The only communication between the tools is
  uni-directional by means of files or file streams (also known as piping). The
  design of the \squadt graphical user interface as well as much of its
  functionality have, so far been targeted at tools with this specific
  behaviour.
  
  The idea of using a graphical user interface to simplify the use of a toolset
  is is not new. The \squadt application is very much influenced by the
  Eucalyptus application (see \cite{CADP}) in the CADP toolset. Eucalyptus was
  developed (around 1996) in the context of CADP for a very similar purpose as
  \squadt is for the mCRL2 toolset. However, this does not mean that all the
  underlying ideas of \squadt are the same as those of Eucalyptus.
  
  %  Ever since the first version, \squadt communicates with tools using the
  %  communication protocol described in this document.
  
  Contrary to Eucalyptus, in \squadt every action is performed in the context
  of a project. This approach is adapted from integrated development
  environments (IDE).  An IDE is an integration framework for software
  development; it integrates a number of often stand-alone software tools that
  are used for software development. In the project context \squadt manages a
  collection of files and a collection of tools that can be used to add new
  files to a project. The user observes and directs this process through a
  graphical user interface.  The core of that user interface is focused around
  an interactive visual overview of all data dependencies within a project.
  Every dependency represents an application of a tool on a set of files with
  another (disjoint) set of files as the result (where output depends on
  input).  Within a project \squadt keeps track of all file interdependencies
  and uses this to monitor file consistency (which will be explained in a moment).

%  One important use of those dependencies is the detection of possible
%  inconsistencies between files. As an illustration of the purpose consider the
%  following scenario. Picture a project containing a file representing a log
%  generated by a tool as a result of the task it performed. Now another tool is
%  applied in the context of the same project to generate a report of this log
%  file. For some reason the user decides to reapply the tool that generates the
%  log file thereby updating this file.  Depending on the intend of the user the
%  report is possibly no longer up-to-date (or inconsistent) with the data in
%  the log file. Inconsistencies arise frequently as a result of working with
%  multiple tools on multiple files. Sometimes such inconsistencies are
%  overlooked and as a result the user analyses the wrong results. The idea is
%  to help the user to become aware of such inconsistencies when they arise.
  A file in a project is either added by the user, or it is produced by a
  single tool with a single configuration from a single set of input files.
  Every file in the project that was not added by the user (called
  \textit{derived} file) can be (re)produced in a unique way by applying tools
  to files. Consistency is a property between two disjoint sets of files,
  called input and output. The property is established by the application of a
  tool to the files of the input, which (re)produces the files of the output. A
  change to a file in any of the two sets violates the property. A derived file
  is called \textit{consistent} if and only if reapplication of the tool on the
  input (with the same configuration) yields the exact same contents of all
  output files, and provided that the set of input files is consistent. By
  convention user added files are always called consistent. Derived files that
  are not consistent are called inconsistent.
  
  Monitoring consistency can help the user to find problems that result from
  the changes made to files in the project. This is not a novel idea. In much
  the same way IDEs monitor changes to files in project in order to
  conservatively rebuild executables from source files. The main difference
  between the two is that an IDE takes care of generation and maintenance of
  all derived files, whereas in our case the user is expected to actively do
  these tasks.

  Inconsistency can result from legitimate tool application within the scope of
  a project, but also from unexpected tool behaviour or system/hardware
  failure. A limiting assumption in this regard is that file contents cannot be
  inspected by the framework other than to create a checksum for detection of
  changes.  The integration framework as well as the individual connected tools
  must cooperate in order to maximise the effectiveness of any inconsistency
  detection mechanism.  Firstly, creation and modification of files by tools
  must be restricted, i.e. directed pro-actively by the integration framework.
  Note that this is in line with the assumption that a derived file must be
  producible in a unique way. Secondly, tools must communicate the complete
  input and output.  When tools behave accordingly the set of dependencies
  among files in a project is complete and the dependencies together form a
  directed acyclic graph.
 
  Better integration is possible when a tool is `aware' of the integration
  context.  Different user interfaces to the same functionality may have
  different requirements. For example in the context of a graphical user
  interface it is convenient and accepted practise visualise progress. For the
  purpose of integration it may be desirable to adapt a tool such that it shows
  progress when it is operating within the context of the integration
  framework. To conveniently use any functionality provided by the integration
  framework there must be access to use such functionality directly from within
  a tool.  The purpose of this text is to describe the communication protocol
  used by the integration framework that supports \squadt.

%  The access to functionality provided by the integration
%  framework will be provided by means of a custom communication protocol.

%%%  All functionality described above can in essence be obtained by an
%%%  integration system that just uses existing tools and their command line
%%%  interfaces. Making tools available in such a system would be a matter of
%%%  ad-hoc connection for instance by means of a plugin framework. This is the
%%%  approach chosen for Eucalyptus, the graphical front-end of the CADP toolset.
%%%  This approach is portable and works fine but connecting tools often takes a
%%%  lot of effort. One step further than Eucalyptus is to consider a facility at
%%%  user interface level that allows a tool to visualise task progress, and
%%%  interact with the user. This offers additional opportunities that were not
%%%  available to a tool with just a command line interface. So we decided on
%%%  using a custom communication protocol instead of existing command-line
%%%  interfaces in order to force tool builder to design new interfaces for
%%%  operating in a \squadt context.
%%%
%%%  As a matter of reference to an existing solution, a popular approach to an
%%%  interface is WSDL (see \cite{2001-WSDL}). Which is an interface description
%%%  language that is used to power web services, based on XML.  A web service is
%%%  ``a software system designed to support interoperable machine to machine
%%%  interaction over a network''. Technically it is possible to use the web
%%%  services model as intermediate interface between tool and integration system.
%%%  However, because of the static nature of interface description in WSDL it is
%%%  not easily possible to read additional input or produce additional output.
%%%  Several of the mCRL2 tools create new output files based on the input.
%%%  This is not something that is easily described in WSDL.
%%%  
%%%  For tools without a graphical user interface
%%%  it would be possible to create a web service layer around the tool. For tools
%%%  with a graphical user interface this would only work. Tools with graphical user Our
%%%  focus is on a protocol for controlling tools from start to finish.

%  In abstract, the platform provides a number of facilities that can be used by
%  tools to communicate with the user. The tools provide services that are made
%  accessible to the user of the platform. The platform acts as a controller
%  (possibly for multiple tools at the same time) and therefore the system will
%  mostly be referred to as (the) controller in the remainder of this document.
%  Similarly, a tool is the communication partner of the controller.

  The remainder of this text is structured as follows. To give an overview of
  things involved, the next section introduces the important concepts. This is
  followed by a high level overview of the protocol. From this the reader
  should get a picture of the structure of communication: what is communicated,
  in what way and why. This is followed by a more detailed description of the
  protocol. It consists of a description of the contents of messages, their
  syntax and effects (rough semantics) and some of the important design
  choices.  At the end is a quick comparison with interfaces used by other
  integration frameworks.
% IDE comparison
% note control aspect: user asserts control over a tool by means of the system

 \section{Concepts}

   It is only useful to consider integration between software tools when there
   is a meaningful way in which the tools can be used together. The purpose is
   then to to obtain a result that any of the individual tools cannot.
   
   The tool integration problem is the manner in which a given set of software
   tools can be used together in order to satisfy a given goal. Note that the
   problem does not necessarily have a solution for instance if the goal is not
   compatible with the functionality provided by the available tools.
   
   Our tool integration framework assists the user in solving tool integration
   problems. To this end the framework has functionality to take care of
   execution of individual tools, monitors consistency of individual tool
   input/output and it offers communication facilities for communication
   between a user and a tool. The purpose of the framework is to allow a
   software application be built on top of it that provides a (graphical) user
   interface that can uniformly shows details of tools (relevant to the
   integration problem).
% The consistency monitoring functionality has profoundly influenced protocol
% design at several points.
 
   The remainder of this section introduces a number of other important
   concepts around which a communication protocol will be built later on the
   text.

  \subsection{Tool}

%   A regular English dictionary defines the meaning of the word tool as: the
%   means whereby some act is accomplished.
   A \textit{(software) tool} is a program that processes input and produces
   output that functionally depends on that input. The output of a tool is the
   result or accomplishment. Both input and output of a tool are sets of
   references to sources of binary data. Considered so far are: data from files
   in a local filesystem or potentially unbounded streams of data sent or received
   over a network. Alternate sources of input or output namely data associated
   with user interaction through connected human interface devices are treated
   specially.
   
   Any tool is always used with a particular purpose in mind. Let's assume that
   the use serves the purpose (i.e. the tool is right for the job). A tool may
   serve different purposes and for each unique purpose the tool is said to
   have a \emph{function} for that particular purpose. For all thinkable
   purposes, the largest set of functions for a particular tool makes up its
   \textit{total functionality}.

%   Modern operating systems allow programs to be executed as processes either
%   concurrently or in a time-sharing fashion. The consequence of is that a tool
%   can be running multiple times at the same moment on the same machine. Notice
%   that a tool's input and output function as communication channels between
%   processes. % where to put unidirectional requirement?

  \subsection{Task}

   A \textit{task} for a tool is the use of a specific combination of functions
   of that tool. This combination determines the requirements on input and
   output. The input of a tool needed for a task, called \textit{task input},
   is a non-empty set of resource identifiers (discussed shortly). Similarly
   output of a tool for a task, called \textit{task output}, is a non-empty set
   of resource identifiers that is disjoint with task input. Notice that this
   precludes manipulation of input as part of the output. 

   A resource identifier is a name of a file or stream associated with a type
   that describes the data format (or file type).  The principle method of
   specifying input/output files or streams is the Uniform Resource Identifier
   (or URI, see \cite{rfc3305}). A URI that is specified as part of input must
   identify an existing resource before a tool can be applied. Similarly, a URI
   that is specified as output must identify an existing resource after the
   tool completes its task.

   Every input as well as output is associated with a type that is specified
   using the MIME format (Multipurpose Internet Mail Extensions, \cite{rfc2822}).
   The type of outputs must be classified carefully because output of one tool
   may serve as input to other tools that may have requirements on types.

  \subsection{Task Configuration} \label{concepts::task_configuration}

%Whether the use actually satisfies the purpose depends on the
%   functionality the tool provides and how the tool is used.
   
   The process of bringing a tool in the state where it can perform a specified
   task is called \textit{task configuration}. After task configuration is
   complete the state of a tool can be made explicit by capturing it as a task
   specification.  A \textit{task specification} for a tool is a concrete
   specification that uniquely defines a task for that tool (without accounting
   for user-interaction).

   \noindent A task specification consists of a description of the task
   input/output and it specifies the specific combination of functions that
   define the task. The task input is a set of URIs that all identify an
   existing resource. The task output is a set of URIs that is disjoint from
   the task input. Every input as well as output is associated with a MIME
   type, if the actual resource identified by the URI does not match the type, a
   tool is expected to fail in completing the task.

   \begin{figure}[H]
    \begin{center}
     \includegraphics{task_configuration.eps}
    \end{center}
    \caption{Graphic overview of the contents of a task specification}
   \end{figure}

   % creation and manipulation (tool and system)
 
   A tool creates its own task specification and communicates it afterwards
   with the integration framework. The framework can read and modify the part
   that specifies the task input and output, e.g. it can rename input files.
   The remainder of the task specification is tool-specific, the framework can
   only store this information but not interpret. The purpose of communicating
   the configuration with the framework is to have a means to preserve it.
   
   Task execution is the process of using a tool to fulfil a configured task.
   To configure a task the tool must create a task specification in cooperation
   with the user and communicate it with the integration framework. To actually
   start execution the framework communicates a task specification with the
   tool that must either accept or reject it. Once a task specification is
   accepted actual task execution may commence.

   % note on user interaction
%   Some tools always require interaction with the user. In such a case a task cannot
%   be unambiguously specified. The task specification only specifies a starting
%   point from where the user interaction . The actions of the user may
%   completely change the configuration in any way.

   % note on failure
%   Since tools are programs, and programs can fail, task execution may fail.
%   Nothing can be concluded about a task that failed. If output exists it
%   must be assumed to be corrupted.

  \subsection{Display}

   Since tools create task specifications themselves, with the user as
   beneficiary, the tool must have means of communicating with the user. The
   \textit{(interaction) display} is a tool-controlled graphical user interface
   that acts as a direct communication channel between a running tool and the
   user. Every running instance of a tool has its own display. The display can
   also be used for instance to show task progress or to query a user during
   task execution.

   There are no limits to the use of the display. Once a tool is running it can
   make use of the display facility.

%%   Ideal integration would present a single user interface for all supported
%%   tools. Naturally a tool integration framework sits between the user and a
%%   set of tools. Tools would use the facilities of the integration framework to
%%   create a (graphical) user interface for communication with the user. This
%%   level of integration is very nice for a user but is too restrictive for our
%%   purposes.  Tools that have not been developed with integration in mind, can
%%   still be adapted to work in the context of an integration framework.  Many
%%   such existing tools have their own (graphical) user interface which cannot
%%   easily be recreated just for the purpose of obtaining a more uniform
%%   interface when the tool is used from the integration framework.

%%   As an example on the use of the display consider the following scenario. In
%%   order to arrive at a task-configuration, a tool must communicate with the
%%   user. As a result \textit{the tool} produces this task-configuration.  The
%%   complete procedure is as follows. First the user selects a tool that has the
%%   functionality to complete the task at hand.  The tool is started and must be
%%   configured to actually complete that task.  The tool can gather the
%%   information it needs to produce a task specification from the user through
%%   its interaction display. After the process of task configuration a task can
%%   be started. The tool will commence task execution during which it can use
%%   the display to inform the user about progress, or request further input.

   % added value
%   As hinted at before, the interaction display can be used for other purposes
%   than configuration. It could be used to add a graphical user interface to a
%   tool that otherwise does not have one. The tool controls the contents of
%   its display as long as it runs. An example of its use in a
%   non-configuration setting may be giving progress indication during task
%   execution.

%  \subsection{Tool Integration}
%
%   The \squadt application is a tool for interactive software tool
%   integration.  It is built on top of a tool integration framework that
%   currently only consists of a tool control interface. The main tasks of the
%   framework are running tools and directing communication between tools
%   whether running or not. The integration level functionality that \squadt
%   provides using the framework are:
%   
%    \begin{itemize}
%     \item help guide users to find tools that offer the desired functionality
%     \item automate frequently (re)occurring tasks that involves running tools
%     \item offer a uniform way in which users can interact with tools
%    \end{itemize}
%
%   There are some more but these are the most significant ones and all have
%   directly affected the design of the tool control interface.

 \section{Communication Protocol (high level)} \label{s:high_level_specification}

  The \squadt application is built on top of a portable tool integration
  framework built in C++. At the heart of this framework is the communication
  protocol we are going to sketch in this section. The protocol represents the
  interface between two different parties, the framework or controlling-side
  (called \textit{controller}), and the side of a software program representing
  a tool (called \textit{tool}). The role of a tool is that a configurable
  service, that of a controller is to orchestrate on behalf of a user.

  The smallest unit of communication is a message. Messages are sent and
  received in a particular order and the protocol specifies how each message
  must be interpreted. Every message is equipped with a type that identifies
  its purpose.  The type indicates how the message should be interpreted and
  provides a means to specify restrictions on message order. Interpretation of
  a message is based on both its type and the role of the party that receives
  it.

  Message interpretation, besides type and role of the receiving party, is also
  affected by the messaging context.  A \textit{message context} is a
  chronologically ordered list of messages that were all either sent or
  received by the same communication partner in that particular order.  More
  formally let $p$ and $q$ be communication partners. The \textit{receiving
  context} of $p$ (pertaining to $q$) is the sequence of \emph{all} messages
  $m_{1}, m_{2}, m_{3}, \ldots$ that were sent by $q$ and received by $p$ in
  this particular order.  The \textit{sending context} of $p$ (pertaining to
  $q$) is the sequence of \emph{all} messages $m_{1}, m_{2}, m_{3}, \ldots$
  that were sent by $p$ and received by $q$ in this particular order. From
  hereon we will assume that every message that is sent will also be received
  and that message order is preserved. More precisely, the receiving context of
  $p$ pertaining to $q$ is a prefix of the sending context of $q$ pertaining to
  $p$.

  A basic pattern used in the protocol is a request-response sequence. The
  tool, as well as the controller, can issue a request that the other party
  \emph{must} respond to. So a request in the sending context can always be
  uniquely paired to a response in the receiving context. Besides this clear
  pattern there are also notification messages, e.g. message that do not
  require any response.

  This section provides a high level overview of the protocol in terms of what
  is communicated when and for what purpose. The next section zooms in on the
  different messages (by type) and the purpose and structure of data
  communicated by means of such a message.

  \subsection{Notes on Presentation}

   Messages have a name and are specified as a tuple consisting of a type, a
   direction and a specification of the structure of its contents. For example
   table \ref{table:example_message} describes a message called ``example
   message'' with type ``example'' it is sent by a controller and received by a
   tool and carries some data (discussed shortly). Message types are names that
   serve to identify message purpose and are introduced on demand.  Message
   direction determines which of the communication partners can send or receive
   such a message. The data, discussed in more detail shortly, is an abstract
   specification of the structure of data carried by the message.
   
   A message without data has an empty data field. Message names are of purely
   presentational use, the type, direction and data together also uniquely
   identify a message. For example a request and it's associated response the
   type identifies the purpose of the message (namely exchange of that what is
   requested) and the absence of data allows distinction between a request and
   the response.
   
   The structure of a message is described in terms of named types that may be
   composed of other (nested) types. The type notation is adapted from the
   mCRL2-data syntax for specification of data types. BNF-style specification
   is used to put the focus on the structure of the data rather than its
   precise representation (which is established in the next section).  The
   names of types hint at both the purpose and data inter-dependencies (between
   messages) and help to form an intuition about how this data is used to
   fulfil the purpose.  There is a small number of predefined types. The first
   type is \texttt{Id} representing a textual identifier (scope is determined
   at use).  The other types are \texttt{URI}, \texttt{MIME-type},
   $\mathbb{B}$, $\mathbb{N}$, and \texttt{String}, with the usual meaning.
   Tuple types are specified using the $\times$ operator as usual e.g.
   $\texttt{Id} \times \mathbb{N}$ is an ordered pair of an identifier and a
   natural number.  Lastly there are the set and list types, with constructors
   $Set$ and $List$ that are parametrised by the type of the elements, e.g.
   $Set(\mathbb{N})$ represents a set of natural numbers.
   
   The following table specifies a message sent by a tool with name `example
   message' of type \msg{example}.  The contents (or data) of the message is a
   list of finite length with pairs of Token $\times$ Number; where token is of
   type String and Number is a natural number.

   \begin{table}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       \multicolumn{2}{|l|}{\textbf{example request}} \\
      \hline
       message type:    & \msg{example} \\
      \hline
       direction:       & controller to tool, tool to controller \\
       data:            & List(Token $\times$ Number) \\
                        & \ Token  = String \\
                        & \ Number = $\mathbb{N}$ \\
      \hline
     \end{tabular}
     \vspace{-0.3cm}
    \end{center}
    \caption{Example request message}
    \label{table:example_message}
   \end{table}
   \noindent Consequently the contents of this message is a list of pairs
   consisting of a string and a natural number.

   \noindent Pictures of state machines (inspired by regular automata notation)
   are used to specify the allowed communication behaviour with regard to a
   message. When an action label on a transition is the name of a message then
   this transition represents a communication action, otherwise it is a local
   action by \emph{one} of the tool partners. The non-communication actions
   illustrate local choice that influences communication behaviour. The
   incoming arrow on the left identifies the initial state. Figure
   \ref{fig:process_example} shows an example process.

   \begin{figure}[H]
    \begin{center}
     \includegraphics{example.eps}
    \end{center}
    \vspace{-0.3cm}
    \caption{Example of a process based around communication behaviour}
    \label{fig:process_example}
   \end{figure}

   From the initial state an example request takes place, meaning that a
   communication action occurs between the partners. Subsequently an example
   response must occur, after which a state is reached from which a start
   notification can occur. A start notification can only be followed by a stop
   notification and vice-versa. The starting and stopping can be repeated ad
   infinitum.

  \subsection{Instance identification} \label{s:instance_identification}

   Although integration framework may invoke tools on demand, this does not
   automatically mean that protocol communication with that tool has been
   setup. The tool has responsibility for setting up this communication and the
   framework is to wait for this to happen.  The purpose of instance
   identification is to identify a tool that starts communicating with the
   controller.
   
   The integration framework that plays the part of controller starts tools on
   demand, e.g. to allow a user to configure a task, and waits for each tool to
   start communicating. The framework may be waiting for multiple tools to
   report as communication partner which makes it necessary to identify
   communication partners with tools that were started. To this end the
   integration framework passes the tool a token that identifies the purpose to
   which the tool was started.  When the tool initiates communication with the
   controller it must communicate this token. After a token is received the
   integration framework must decide on its validity and thereby the identity
   of the communication partner.   

   After a tool is started it will initiate communication with the controller.
   In practise this means that a new messaging context (connection) is
   established at the side of controller and tool.  After the connection is
   established the tool \emph{must} send an identification message containing
   the token it received.
   
   \begin{figure}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       \multicolumn{2}{|l|}{\textbf{identification notification}} \\
      \hline
       message type:    & \msg{identification} \\
      \hline
       direction:       & tool to controller \\
       data:            & Token \\
                        & \ Token = String \\
      \hline
     \end{tabular}
     \vspace{-0.3cm}
    \end{center}
   \end{figure}

   \noindent A message of this type \emph{must} be the first message in any
   sending context of a tool. The integration framework must evaluate an incoming
   token and must make a judgement on its validity. If the token is not valid
   then communication with the tool \emph{must} be aborted.

   \begin{figure}[H]
    \begin{center}
     \includegraphics{connection_and_identification.eps}
    \end{center}
    \vspace{-0.3cm}
    \caption{Process of instance identification}
    \label{fig::identification}
   \end{figure}

   \noindent Figure \ref{fig::identification} shows the combined behaviour of a
   controller and a tool with regard to instance identification. A tool
   initiates a connection, sends an identification notification and starts
   waiting for incoming messages.  At the side of controller the value of the
   token is used to choose between breaking the connection and accepting the
   identity of the tool on the other side. If the connection persists and the
   tool receives an arbitrary other message from the controller its identity
   was accepted.

  \subsection{Capabilities}

   Capabilities represent both an information facility for one communication
   partner to learn about the capabilities of the other, as well as a protocol
   extension mechanism. The extension mechanism currently only consists of a
   means to check for the protocol version supported by a communication
   partner. This provides some limited backward and forward compatibility
   between protocol versions.  For example it allows a tool developer to check
   controller side support for facilities that have been introduced in specific
   protocol versions.
   
   \noindent The exchange of capabilities follows a request response sequence
   as illustrated by the following figure.
   
   \begin{figure}[H]
    \begin{center}
     \includegraphics{exchange_of_capabilities.eps}
    \end{center}
    \vspace{-0.3cm}
    \caption{Process of exchange of capabilities}
   \end{figure}

   \noindent The process follows the basic request response pattern and is
   symmetric for both communication parties. A request for capabilities
   message looks as follows.
   
   \begin{table}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       \multicolumn{2}{|l|}{\textbf{capabilities request}} \\
      \hline
       message type:    & \msg{capabilities} \\
      \hline
       direction:       & controller to tool, tool to controller \\
       data:            & \\
      \hline
     \end{tabular}
     \vspace{-0.3cm}
    \end{center}
   \end{table}

   \noindent The partner that receives a capabilities request \emph{must} send
   a capabilities response message. For a controller the response only contains
   the protocol version number and looks as follows.

   \begin{table}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       \multicolumn{2}{|l|}{\textbf{capabilities response (controller)}} \\
      \hline
       message type:   & \msg{capabilities} \\
      \hline
       direction:      & controller to tool \\
       data:           & Version = Major $\times$ Minor \\
                       & \ Major = $\mathbb{N}$ \\
                       & \ Minor = $\mathbb{N}$ \\
      \hline
     \end{tabular}
    \end{center}
    \vspace{-0.3cm}
   \end{table}

   \noindent For a tool the response in addition contains an abstract
   `advertisement' of the tools functionality. This advertisement is a
   non-empty set of input configurations.  An \textit{input configuration} is a
   pair of a \textit{category} (introduced next), and a non-empty list of names
   for inputs each of which is associated with a type (as MIME-type).  The
   category is a descriptive name for the type of functionality that a tool
   offers for that specific input configuration.
   
   \begin{table}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       \multicolumn{2}{|l|}{\textbf{capabilities response (tool)}} \\
      \hline
       message type:   & \msg{capabilities} \\
      \hline
       direction:      & tool to controller \\
       data:           & Version $\times$ Set(InputConfiguration) \\
                       & \ Version = Major $\times$ Minor \\
                       & \ \ Major = $\mathbb{N}$ \\
                       & \ \ Minor = $\mathbb{N}$ \\
                       & \ InputConfiguration = Category $\times$ List(Id $\times$ Format) \\
                       & \ \ Category = String \\
                       & \ \ Format = MIME-type \\
      \hline
     \end{tabular}
    \end{center}
    \vspace{-0.3cm}
   \end{table}

   \noindent The set of input configurations partition the entirety of tasks
   that a tool can perform into classes that have the same input requirements
   and whose functionality falls in the same category. Every task specification
   is based on a single input combination. The input combination expresses a
   set of basic input requirements for configuration and abstractly
   characterises what functionality of the tool will be used.
   
%   It is important to realise that the content of capabilities response
%   messages described here represent only a bare minimum. Protocol extension
%   requires extension to contents and therefore the structure of these
%   messages (see section \ref{ss:structure}).

  \subsection{Task Configuration} \label{ss::task_configuration}

%   The controller makes use of the services provided by a tool through task
%   configuration. After that, the task that is performed makes use of a
%   selection of the functionality that the tool provides.  Configuration and
%   task execution are separated, the latter is discussed in section
%   \ref{ss::task_execution}.

   A task specification can be obtained in two ways, either by deriving it from
   an input configuration or by receiving one as result of a previous task
   configuration process. Task configuration is considered to be an incremental
   activity, the result of which is a configuration that is uniquely
   represented by a task configuration. The idea is to allow a user to modify a
   configuration after its initial creation, e.g. to add refinements.  In fact
   the task configuration process always starts with communicating an existing
   task specification with a tool.
   
   Configuration details, as part of task specifications, can now exist outside
   the tool.  A consequence is that it opens up the opportunity that a tool
   receives an invalid task specification, e.g. it does not uniquely specify a
   configuration. Whatever the cause, it is necessary for tools to check
   whether a task specifications are usable.  In other words a tool developer
   must provide a procedure to test task specification for validity. Moreover
   in the case a task specification is not valid the tool developer must resolve
   this problem by through communication with the user.

   The following figure depicts the basic (isolated) communication behaviour of
   the task configuration process.
   
   \begin{figure}[H]
    \begin{center}
     \includegraphics{configuration_execution.eps}
    \end{center}
    \vspace{-0.3cm}
    \label{fig:configuration_execution}
    \caption{Schematic overview of the process of task configuration and execution}
   \end{figure}

   \noindent The process of task configuration is a straight-forward application of the
   request-response pattern. The state with label \texttt{C} represents the
   configured state, i.e. the state from which task execution may commence.
   Similarly the state with label \texttt{E} represents the state in which the
   tool is executing a task. Section \ref{ss::task_execution} introduces the
   messages that deal with task execution.

%   Let $sc$ be the sending context of a controller and $rc$ be the receiving
%   context (pertaining to one tool). If both controller and tool are still
%   running and every configuration message in $sc$ can be paired to a unique
%   configuration message in the receiving context then \emph{no} task
%   configuration is in progress.
   
   The following figure specifies the content of the message that initiates the
   task configuration process.
   \begin{table}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       \multicolumn{2}{|l|}{\textbf{configuration request}} \\
      \hline
       message type:   & \msg{configuration} \\
      \hline
       direction       & controller to tool \\
       data:           & Interactive $\times$ Configuration \\
                       & \ Interactive = $\mathbb{B}$ \\
                       & \ Configuration = Category $\times$ List(ConfigurationItem) \\
                       & \ \ Category = String \\
                       & \ \ ConfigurationItem = Id $\times$ (Option $|$ Object) \\
                       & \ \ Option = List(DataType $\times$ String) \\
                       & \ \ \ DataType \\
                       & \ \ Object = (Input $|$ Output) $\times$ Format $\times$ Location \\
                       & \ \ \ Location = URI \\
                       & \ \ \ Format   = MIME-type \\
      \hline
     \end{tabular}
     \vspace{-0.3cm}
    \end{center}
   \end{table}

   \noindent The message \emph{must} specify contain the interactivity flag; it
   specifies whether or not further user configuration is desired. The tool may
   initiate interaction with the user regardless of the value for the
   interactivity flag. The intended meaning however is that the tool only
   verifies usability of the task specification (Configuration) and only
   initiates communication when this fails.

   The Configuration data type represents a task specification. A minimal task
   specification must have a non-empty list of objects, a category name, a list
   of options and a possibly empty list of outputs. The category gives an
   indication of what functionality of the tool is used to perform the task.
   The options represent the language for task specification. A single option
   is a parametrised entity that represents the smallest part of optional
   configurable behaviour. The list of options identifies a combination of
   functions that make up the task. 

   Before sending a response the tool may initiate arbitrary interaction with
   the user (see subsection \ref{ss:user_interaction}). The user as beneficiary
   is supposed to direct the process of task-configuration if interactive
   communication is the purpose. A response message looks as follows:
   (\textit{Configuration} is reused from configuration request)

   \begin{table}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       \multicolumn{2}{|l|}{\textbf{configuration response}} \\
      \hline
       message type:   & \msg{configuration} \\
      \hline
       direction       & tool to controller \\
       data:           & Validity $\times$ Configuration \\
                       & \ Validity = $\mathbb{B}$ \\
      \hline
     \end{tabular}
    \end{center}
    \vspace{-0.4cm}
   \end{table}

   \noindent The response carries a judgement, the validity flag, and the final
   configuration.  Depending on the Validity flag the embedded configuration
   was judged usable and is accepted. Notice that the configuration sent in the
   request is not necessarily the same as the configuration in the response.
   The tool may have made changes to the configuration hopefully after having
   consulted the user.

%   It is assumed that the task-configuration that is returned in a response has
%   a strong resemblance to the task-configuration sent in the request. At the
%   very least they should share the same main-input, the rest is up to the
%   creativity of the tool developer.

%   \noindent About the configuration specifications: every option is uniquely
%   identified, and so is every object. The reason is to make it easier for a
%   tool developer to test for availability of options/objects.  An option
%   represents an atomic unit in the configurable behaviour of a tool. For
%   validation purposes a data type can be specified against which the values
%   for the option are matched. An object is a file associated with a format and
%   a location.

  \subsection{Task Execution} \label{ss::task_execution}

   When configuration is complete the controller may start task execution by
   sending a task start command. Configuration is complete when the controller
   receives a configuration response message with an accepted configuration and
   it has not sent a new configuration request.  A task is called \textit{in
   progress} as soon as a task start signal is sent, and as long as no task
   stop signal has been received. See figure \ref{fig:configuration_execution}
   for a schematic overview of the process of task execution.

   A task start command message looks as follows:

   \begin{table}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       \multicolumn{2}{|l|}{\textbf{task start command}} \\
      \hline
       message type:   & \msg{task} \\
      \hline
       direction       & controller to tool \\
       data:           & \\
      \hline
     \end{tabular}
    \end{center}
    \vspace{-0.3cm}
   \end{table}

   \noindent When a tool receives a task start command it must start executing
   the configured task. As task execution completes the tool must send a task stop
   notification as shown in table \ref{table:task_stop}.

   \begin{table}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       \multicolumn{2}{|l|}{\textbf{task stop notification}} \\
      \hline
       message type:   & \msg{task} \\
      \hline
       direction       & tool to controller \\
       data            & Result \\
                       & \ Result = $\mathbb{B}$ \\
      \hline
     \end{tabular}
     \label{table:task_stop}
    \end{center}
    \vspace{-0.3cm}
   \end{table}

   \noindent The data in the stop notification signifies success or failure
   of task execution. In case of failure the user should probably be notified
   of the details of the failure using the display or the reporting facility
   both of which will be discussed shortly.
   
%%   A side remark on task
%%   execution: the controller has the responsibility to ensure that the inputs
%%   in a configuration exist prior to starting a task that depends on them. Also
%%   it must ensure that they remain unchanged (by the environment) during task
%%   execution. Likewise, the outputs must not exist or be modifiable by the tool
%%   prior to starting a task, and it must ensure that the environment leaves the
%%   outputs unchanged during task execution.

  \subsection{Reporting}

   The purpose of the reporting facility is to inform the user (through the
   controller) of individual task activities and their progress. A report may
   be sent from any context and signifies either a warning, error or just
   notification of some event. The facility is intended as secondary source of
   information (next to the display) that a user may consult to get more
   feedback on configuration or task execution. A report message looks as follows:
   
   \begin{figure}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       \multicolumn{2}{|l|}{\textbf{report notification}} \\
      \hline
       message type:   & \msg{report} \\
      \hline
       direction:      & tool to controller \\
       data:           & ReportType $\times$ Description \\
                       & \ ReportType = `notice' $|$ `warning' $|$ `error' \\
                       & \ Description = String \\
      \hline
     \end{tabular}
    \end{center}
   \end{figure}
   \vspace{-0.3cm}

   \noindent This facility is meant as an indirect method of communication with
   the user. The information from the reporting facility ends up in a log that
   is only visible when the user wants it. So the reporting facility must not
   be relied on as a part of the user regular user interface.  The reporting
   facility is intended as additional source of information for the user and
   \emph{not} an exception handling facility for the tool developer.

  \subsection{Termination}

   The termination facility allows the controller to terminate a tool in a
   controlled fashion.  In this way a tool is allowed to free resources
   and remove inconsistent outputs.
   
   \noindent A termination request is a message that looks as follows.

   \begin{figure}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       \multicolumn{2}{|l|}{\textbf{termination command}} \\
      \hline
       message type:    & \msg{termination} \\
      \hline
       direction:       & controller to tool \\
      \hline
     \end{tabular}
    \end{center}
   \end{figure}
   \vspace{-0.5cm}

   \noindent The response must be a termination notification, as shown in the
   table below, which signifies that the tool is shutting down and will
   terminate soon. A tool may send a termination notification from any context.

   \begin{figure}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       \multicolumn{2}{|l|}{\textbf{termination notification}} \\
      \hline
       message type:   & \msg{termination} \\
      \hline
       direction:      & tool to controller \\
       data:           & \\
      \hline
     \end{tabular}
    \end{center}
   \end{figure}
   \vspace{-0.5cm}

   \enlargethispage*{30pt}

   \noindent The message represents a general notification of termination e.g.
   it may be used by a tool terminates after an unrecoverable error.
   The following figure shows the communication behaviour with regard to
   termination command/notification behaviour.

   \begin{figure}[H]
    \begin{center}
     \includegraphics{termination.eps}
    \end{center}
    \vspace{-0.5cm}
    \caption{termination behaviour}
   \end{figure} 
   
   \noindent When a tool fails to respond to a termination request, the
   integration framework may force a tool to terminate by other means.

  \subsection{Display} \label{ss:user_interaction}

   The display facility represents the primary means of a tool to communicate
   with the user.  Think of it as an interactive bulletin board controlled by
   the tool. The bulletin board notifies the tool after any change a user
   makes. Of course the user is not allowed to make arbitrary changes to
   content. He or she can only add or change data as intended by the developer
   of the tool that owns the display.

   The display facility shows an arrangement of widgets (user interface
   primitives, e.g. a button), with which the user can interact. To keep it
   simple, widgets are chosen from a preselected set of the set of very basic
   widgets. A simple relative positioning scheme is used for widget arrangement
   on the space provided by the display. Such an arrangement of widgets, also
   called a layout, cannot be manipulated. The only manipulation allowed is
   the complete replacement of a layout by another one, and changes the state of
   individual widgets that are part of a layout.

   From the tool perspective using the display involves communication a layout
   (set of widgets and constraints for arranging them on the display).  A
   \textit{layout specification} is a description of a set of widgets and how
   they are positioned relative to each other on the space made available by
   the display. User interaction with widgets on the display is relayed to the
   associated tool immediately after the interaction took place. On the other
   hand a tool can change the internal state of widgets, e.g. change the label
   of a button from `okay' to `cancel'. In both cases information from
   individual widgets, called \textit{display data}, is exchanged between the
   communication partners.

   \begin{table}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       \multicolumn{2}{|l|}{\textbf{display change command}} \\
      \hline
       message type:   & \msg{display\_layout} \\
      \hline
       direction:      & tool to controller \\
       data:           & LayoutManager \\
                       & \ LayoutManager = BoxLayoutManager \\
                       & \ \ BoxLayoutManager = Direction $\times$ List(Properties $\times$ Id $\times$ LayoutElement)) \\
                       & \ \ \ Direction = `horizontal' $|$ `vertical' \\
                       & \ \ \ Properties = Visibility $\times$ Status $\times$ Margins $\times$ Alignment \\
                       & \ \ \ \ Visibility = `visible' $|$ `hidden' \\
                       & \ \ \ \ Status = `enabled' $|$ `disabled' \\
                       & \ \ \ \ Margins = Left $\times$ Top $\times$ Right $\times$ Bottom \\
                       & \ \ \ \ \ Left   = $\mathbb{N}$ \\
                       & \ \ \ \ \ Top    = $\mathbb{N}$ \\
                       & \ \ \ \ \ Right  = $\mathbb{N}$ \\
                       & \ \ \ \ \ Bottom = $\mathbb{N}$ \\
                       & \ \ \ \ Alignment = HorizontalAlignment $\times$ VerticalAlignment \\
                       & \ \ \ \ \ HorizontalAlignment = `left' $|$ `centre' $|$ `right' \\
                       & \ \ \ \ \ VerticalAlignment = `bottom' $|$ `middle' $|$ `top' \\
                       & \ \ \ LayoutElement = LayoutManager $|$ Control \\
                       & \ \ \ \ Widget = ProgressBar $|$ RadioButton $|$ Button $|$ Label $|$ TextField $|$ CheckBox \\
                       & \ \ \ \ \ ProgressBar = $\mathbb{N} \times \mathbb{N} \times \mathbb{N}$ \\
                       & \ \ \ \ \ RadioButton = $\mathbb{B}$ \\
                       & \ \ \ \ \ Button      = String \\
                       & \ \ \ \ \ Label       = String \\
                       & \ \ \ \ \ TextField   = String \\
      \hline
     \end{tabular}
    \end{center}
   \end{table}
   \vspace{-0.4cm}
   \noindent Every widget \emph{must} have an identifier ($Id$), that uniquely
   identifies it the layout. Communication of changes to the state of a widget
   rely on the identifier as widget specifier.  The $box$ and $properties$
   elements represent a set of constraints on the relative layout of elements
   contained in the layout manager (box layout manager in this case). A layout
   consists of set of nested box elements that contain widgets.  The horizontal
   or vertical direction of a box determines the way it lays out the elements
   it contains above respectively or beside each other respectively. The layout
   properties further affect layout of elements relative to each other or the
   containing box. Visibility determines whether a layout element is visible or
   not. Status determines whether a widget is active, i.e.  whether it allows
   user interaction, e.g. a text field that is disabled is read only for the
   user. Margins control the distance between the directly adjacent elements.
   For first and last elements this means the distance to the borders of the
   containing box. A box equally divides the amount of available space over the
   available widgets. When there is plenty of space after deduction of margins
   the alignment can be used to control either the vertical or horizontal
   position of a widget within the available space.

   To communicate changes to a widget on the display the following messages
   are used.

   \begin{table}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       \multicolumn{2}{|l|}{\textbf{display interaction notification}} \\
      \hline
       message type:   & \msg{display\_data} \\
      \hline
       direction:      & controller to tool \\
       data:           & Id $\times$ State \\
                       & \ State = String \\
      \hline
     \end{tabular}
    \end{center}
   \vspace{-0.4cm}
   \end{table}

   \noindent When a tool receives a display interaction notification it is
   interpreted as a state change of a widget that matches the identifier. When
   the identifier is not known the message must be ignored. The String type is
   used to represent the state of an arbitrary widget. So the state is actually
   either $\mathbb{N}\times\mathbb{N}\times\mathbb{N}, \mathbb{B}$ or String
   depending on the type of the associated widget.  Similarly a tool can
   request a change to a widget on the display using the following message.

   \begin{table}[H]
    \begin{center}
     \begin{tabular}{|ll|}
      \hline
       \multicolumn{2}{|l|}{\textbf{display manipulation command}} \\
      \hline
       message type:   & \msg{display\_data} \\
      \hline
       direction:      & tool to controller \\
       data:           & Id $\times$ State \\
                       & \ State = String \\
      \hline
     \end{tabular}
    \end{center}
   \vspace{-0.4cm}
   \end{table}

   \noindent When a controller receives such a message it is interpreted as a
   state change of a widget that matches the identifier. When the identifier is
   not known the message must be ignored. The state actually depends on the
   type of the widget identified by the identifier and is assumed to be
   representable as a string.  For example the structure of the state of a
   progress bar widget state is $ProgressBar$ or $\mathbb{N} \times \mathbb{N}
   \times \mathbb{N}$ (which can also be represented as String of course).

%    A tool can change the state of widgets on a display by means of their
%    identifier. The following message must be used for this purpose.

   The following figure shows the communication behaviour with regard to the
   use of the display.
   
   \begin{figure}[H]
    \begin{center}
     \includegraphics{display.eps}
    \end{center}
    \vspace{-0.4cm}
    \caption{Process of display manipulation}
    \label{figure:display_manipulation}
   \end{figure}

   \noindent Initially the display shows the empty layout. User interaction
   without widgets is not possible, so display interaction notification
   messages will not be sent by the controller and similarly display
   manipulation requests will not be sent by a tool (even though both are
   allowed behaviour according to Figure \ref{figure:display_manipulation}). A
   display manipulation command is ignored when the controller cannot identify
   the widget that was targeted or when the state is not a valid state
   description for the targeted widget. The display becomes non-empty when a
   layout change command with a valid non-empty layout specification is
   communicated.  A display interaction notification is ignored when the tool
   cannot identify the widget that was targeted or when the state is not a
   valid state description for the targeted widget. 
   
 \section{Implementation details} \label{s:protocol_implementation}

   Above, we presented a high level view of the communication protocol for
   controlling tools in our integration framework. This section focuses on the
   implementation details and addresses important design decisions.
   
   The communication protocol is the interface between a tool and the tool
   integration framework. An important design goal was to make the use of this
   interface as simple as possible e.g. to not restrict it's use to specific
   operating systems or programming languages. So for implementation we
   have only looked at established inter-process communication mechanisms
   available as part of standard facilities provided by operating system such
   as sockets and pipes.  To further simplify the use of the interface from
   other programming languages it was decided to create a text-based message
   format based on XML \cite{XML-1_0-4}.

%   Not explicitly mentioned so far, but very important in this section is that
%   we rely on the property that the order in which messages are sent is the
%   same as the order in which those messages are received (or actually
%   delivered). Another such property is that communication between partners
%   uses a notion of connection.
   Another important general design decision was to put little focus on protocol
   security aspects. We feel that security as well as performance are key
   aspects in the design of any system. By this we mean that, as is the case with
   performance, it is often not possible or very difficult to implement or to
   simply extend a design to add security at a later stage. Putting a focus on
   security would have slowed down the development process too much. The main
   goal has been on getting a proof-of-concept implementation of a
   communication interface on top of which to build the \squadt application.

   The OSI model \cite{Day1983} is a popular way of analysing and describing
   communication protocols. Our use of this model only serves to provide a
   frame of reference. The OSI model divides the communication into subproblems
   (using seven layers) that can be solved independently. Layers 1 through 5
   represent basic functionality covered by widely available standard
   communication protocols. Those five layers provide a data communication
   connection between applications along which data can be transported.  Our
   communication protocol covers the $6^{th}$ (presentation) layer. The
   integration framework that is used as part of the \squadt application covers
   the $7^{th}$ (application) layer.
   
  \subsection{Transport} \label{ss:transport}

   For transport of data layers 1 through 5 of the OSI model the internet (or
   TCP/IP) protocol suite is used (see \cite{rfc793} and \cite{rfc791} for
   TCP(-v4) respectively IP). The TCP/IP protocol provides reliable
   bi-directional order-preserving delivery of a byte stream (layers 1 through
   4 of OSI). TCP/IP also offers session functionality ($5^{th}$ layer OSI) or a
   connection between applications on top of which a messaging context can be
   implemented. As a result one-time tool identification (section
   \ref{s:instance_identification}) is possible, i.e. when a new messaging
   context is established. % The use of TCP/IP is widespread and modern
%   operating systems have built-in support. As a result usable from a wide variety of
%   programming languages.

%   An alternative is to use
%   standard input/output streams (or piping).  But the main disadvantage of
%   this facility is that there is not built-in support in many programming
%   languages to do non-blocking communication. This is a strict requirement
%   because of the asynchronous nature of the protocol.  A further disadvantage
%   over TCP/IP is that all communication is limited to the same machine.

%   The TCP/IP protocol suite is chosen as the recommended means of
%   transport. It is well-known and supported by a lot of programming languages.
%   The protocol requires connection-state, a tool is authenticated once and on
%   failure the connection is terminated. In addition, because meaning is
%   assigned to the order of messages, the protocol requires that messages are
%   delivered in the same order as which they were offered to the sender. All
%   requirements are all supported by TCP/IP, note that for UDP/IP this is not
%   the case.

  \subsection{Messaging}

   The presentation layer of the OSI model is about mapping between application
   level concepts (with their own syntax and semantics) and data representation
   in communication (data in messages). The topic of this subsection is the
   representation of the messages presented in section
   \ref{s:high_level_specification} and their interpretation in the domain of the
   application.
   
%   XMPP has the notion of a message that can be sent from client to client, on
%   top of it our protocol can be implemented.   Unfortunately no single
%   client/server side implementations exist at the time that are usable on all
%   target platforms without also introducing quite a number of other
%   dependencies. Creating our own implementation would have taken to much time,
%   especially when we would have implemented all of XMPP.  So we choose a lightweight
%   custom implementation, instead of using XMPP with 3rd-party client and
%   server implementations.

%   The choice for XML is obvious we aim for extensibility and XML to some
%   extend allows changes to the format extensions to the format there is wide
%   support in many programming languages. With XML it is possible to create a
%   good parser that is to some extent resistant to extensions, meaning it will
%   also work on future versions of the format that may contain additional
%   information.  Another benefit of using XML is it makes the messages
%   readable, making it easy to print and manually verify the structure and
%   contents.

   \subsubsection{Basic Structure: Envelope} \label{ss:structure}

    \noindent Messages are wrapped in the \textit{message} element. A mandatory
    attribute is \textit{type} that specifies the type of the message. The type
    attribute can occur only once and its value must be among those introduced
    in the previous section: \textit{identification}, \textit{capabilities},
    \textit{configuration}, \textit{display\_layout}, \textit{display\_data},
    \textit{termination}, \textit{task},
    \textit{report}. As an example consider the following message with type
    `termination'.
 
    \begin{verbatim}
     <message type="termination"><![CDATA[message content]]></message>\end{verbatim}

    \noindent The content of a message is wrapped in a so-called CDATA section. The
    contents of a CDATA section is treated as character-only data and not
    parsed as markup. This allows embedding arbitrary character data into XML
    documents. To deal with data that contains fragments that match the
    end-marker \verb']]>', any instance of \verb']]>' in the message content
    \textit{must} be replaced by \verb']]]><![CDATA[]>'.
    
    \noindent Below the message structure is specified for all the
    message types and for some interesting variations. Usually the structure
    of an XML document is (formally) specified using XML Document Type
    Definition (\cite{Sperberg-McQueen:06:EML}) or the XML Schema standard
    \cite{Malhotra:06:XSP}. An XML Schema specification for the complete set of
    messages is available in appendix \ref{subsection:xml_schema_messages}. Many people
    find DTD and XML schema difficult to read and understand; so here we use 
    XML fragments and text to illustrate the translation to the
    concrete representation.

%  \subsubsection{Authentication}

%   Instead of a full-featured authentication scheme we chose a simple instance
%   identification scheme. Of course security is something that should be part
%   of the design of the protocol. Security is not a main concern, so it is
%   postponed until it can be added as an extension somewhere in the future.
   
%   The only authentication that is of importance to the functioning of the
%   system that uses the protocol is identifying the peer as one of the tools
%   that was started. For this purpose the instance identification message,
%   described in section \ref{s:instance_identification} was devised. When
%   starting a tool the system must somehow pass the tool a token that can be
%   used later to uniquely identify it.

  \subsubsection{Capabilities}

   Capabilities are exchanged to inform each of the communication partners
   about the precise capabilities of the other. A request for capabilities
   looks is a message with type `\texttt{capabilities}' and no content.

   \small \begin{verbatim}
  <message type="capabilities"></message>\end{verbatim}
  \normalsize

   The response is a message with type `\texttt{capabilities}' and at least the
   following content when the request was made by a tool.

   \small \begin{verbatim}
  <capabilities>
   <protocol-version major="1" minor="0" />
  </capabilities>\end{verbatim}
  \normalsize

   \noindent When the request was made by the controller, the response must
   also contain the set of input-configurations. An input-configuration is
   represented by means of the \textit{input-configuration} element. The
   non-empty set is modelled as an non-empty ordered list without duplicates,
   meaning that elements with the same values for the category and format
   attributes are ignored. For example:

   \small \begin{verbatim}
  <capabilities>
   <protocol-version major="1" minor="0" />
   <input-configuration category="editing">
    <object id="mcrl2_in" format="text/mcrl2" />
   </input-configuration>
   <input-configuration category="visualisation">
    <object id="mcrl2_in" format="text/mcrl2" />
   </input-configuration>
   <input-configuration category="editing">
    <object id="lps_in" format="application/lps" />
   </input-configuration>
  </capabilities>\end{verbatim}
  \normalsize

   \noindent The attribute \textit{category} is mandatory and represents the
   category of functionality associated with this input configuration. The
   \textit{input-configuration} section contains an arbitrary amount of
   \textit{object} sections each representing a source of input. An
   \textit{object} element has two mandatory attributes: \textit{id} a unique
   identifier within the scope of an input-configuration section and
   \textit{format} a MIME-type (see Multipurpose Internet Mail Extensions,
   \cite{rfc2822}) that specifies the type of the input.

   For the example above the interpretation is as follows. As input the tool
   takes a file that either uses the text based format called mcrl2, then
   behaves either as an editor or as a visualiser, or it uses the binary lps
   format and behave as an editor.

  \subsubsection{Configuration} \label{ss:implementation_configuration}

%   The purpose of a configuration specification is to differentiate between
%   behaviours of a tool in order to allow for selection of behaviour. Depending
%   on the developer of a tool different behaviour can be observed from the
%   outside. It also depends on the developer to what extend this behaviour can
%   be selected before task execution is started.

   Traditionally most programs with a command line interface take arguments
   that are used to (re)produce a configured state non-interactively by means
   of a command which is a single specially formatted string. The model behind
   this method of expressing a task-specification is based on the idea that
   tasks consist of a sequence of operations or sub tasks each of which can be
   parametrised.  A configuration is a selection between available operations
   and values for the parameters for operations or the combinations thereof. On
   the command line such a configuration is represented as a string that
   consists of so-called options followed by values for the arguments of this
   option. Our approach of expressing a configuration follows the same pattern
   of options with arguments.

   The integration framework is oblivious to any data that is produced by tools
   other than a name (specified as URI) and storage format or the `type' of
   this data.  In particular the controller cannot inspect data in order to
   obtain more knowledge about the data.

   The integration framework is the only party with knowledge about available
   data sources. This knowledge is obtained from configurations and
   communication with the user. By means of a configuration a tool informs the
   framework on what data (and its type) are produced by the task. To represent
   the type of the data the MIME standard is used. The use of MIME is
   wide-spread among desktop applications and in other communication protocols.
   A configuration request sent by the controller is a message with type
   `\texttt{configuration}' and the following content:

   \small \begin{verbatim}
  <configuration interactive="true" category="debugging">
   <option id="-v">
    <argument type="integer">1</argument>
   </option>
   <object id="in" type="input" location="/dev/random" format="application/octet-stream"/>
   <object id="out" type="output" location="/tmp/out" format="application/octet-stream"/>
  </configuration>\end{verbatim}
  \normalsize

   \noindent The \textit{category} attribute is mandatory and should contain a
   short string that identifies a category that characterises the functionality
   of the tool that is used when a tool is configured accordingly.  The
   interactive attribute is optional and signifies a request for user
   interactive configuration when it is set to `true' . A
   \textit{configuration} element may contain an arbitrary number of
   \textit{object} and \textit{option} elements in any order, they represent
   data sources and options respectively.
   
   The \textit{id} attributes of \textit{option} and \textit{object} elements
   represent the identifiers and all must be unique within the context of a
   task specification (the containing \textit{configuration} element).  An
   \textit{object} element must contain the \textit{type} attribute, which
   specifies whether the tool takes it as input or produces it as output. The
   \textit{location} attribute must specify a URI (see \cite{rfc3305}), and the
   \textit{format} attribute contains a data format specifier using the MIME
   standard.  An \textit{option} element may contain an arbitrary number of
   \textit{argument} elements that each represent a single typed-argument to
   the option. A number of predefined types is available for arguments to
   options: string, integer, natural, positive, real.

   A configuration response is similar to the request but it has the interactive 

   A valid (initial) configuration can be obtained from an input configuration
   as follows.  Create an empty \textit{configuration} section and add an
   attribute \textit{interactive} set to true and add the contents of an
   input-configuration section (section \ref{ss:implementation_configuration}).

  \subsubsection{Display}

   Display manipulation was restricted to replacing the entire content of the
   display at once or modifying the state of individual widgets on the display.
   In particular it is not possible to manipulate the layout itself. More
   complete manipulation capabilities rapidly increase complexity. A
   conservative approach was chosen to keep initial complexity low and save on
   development time.

%%   A good example is the combination of HTML,
%%   CSS, and JavaScript because it essentially offers this flexibility by means
%%   of open standards. The complexity of these standards and lack of easy-to-use
%%   standard portable implementations make them unsuitable to directly rely on
%%   at this time.

   A small set of widgets is available for tool developers to choose from for
   constructing display layouts. Display layout construction and manipulation
   by itself are by far the most complex functionality the protocol has to
   offer.  The downside of this limited choice is that a tool developer has
   less means layout widgets on the display. Adding new widgets when need
   arises should be easy however. The protocol will have to be refined in order
   to support this.
   
%   The available elements are: \textit{box-layout-manager}, \textit{progress-bar},
%   \textit{radio-button}, \textit{button}, \textit{label}, \textit{checkbox},
%   \textit{text\_field}.  A detailed introduction of the individual widgets 
%   comes next followed by a description on how the widgets are positioned by
%   means of a layout specification.

   \paragraph{Widgets}

    We assume that the reader is familiar with the purpose and basic functions
    of each of the widgets presented earlier. Nowadays the use of graphical
    user interfaces today is ubiquitous that no further introduction should be
    needed.  The name and function of widgets and the way a layout is built are
    based on concepts and terminology used in Java Swing.  Every widget has a
    mandatory \textit{id} attribute that must be unique within the scope of the
    containing \textit{display-layout} section (introduced shortly).
   
    The following example shows a specification for a label, a button and a
    checkbox with text Cancel.
   
    \small \begin{verbatim}
  <label id="x"><![CDATA[Cancel]]></label>
  <button id="y"><![CDATA[Cancel]]></button>
  <checkbox id="z" checked="true"><![CDATA[Cancel]]></checkbox>\end{verbatim}
  \normalsize

    \noindent When the button is pressed or the checkbox is toggled this fact is
    communicated by sending a \msg{display\_data} message with the complete
    respective button or checkbox specification. The checkbox has a description
    and is always in one of two states: checked or not. A more complex example
    is the radio-button widget, because it is not a stand-alone widget.

    \small \begin{verbatim}
  <radio-button id="x" connected="y"><![CDATA[first]]></radio-button>
  <radio-button id="y" connected="x" selected="true"><![CDATA[second]]></radio-button>\end{verbatim}
  \normalsize

   \noindent Radio buttons are always grouped and only a single button in the
   group is selected (pressed).  By default the first radio button is selected,
   if another radio button should be selected then the \textit{select}
   attribute must have value true. The radio buttons are connected by means of
   the \textit{connected} attribute that contains the value of the \textit{id}
   attribute of another radio button in the group. Every radio button in the
   group can be found by repeatedly following the \textit{connected} attribute
   to find the connected radio-button by its identifier. If the selection
   changes then only the specification of the radio button that gets selected
   must be sent by means of a \msg{display\_data} message to inform the other
   side of this event.

   The text field displays an input widget for the user to input text. It is
   like the button widget, but it contains an element \textit{text} that
   holds the content of the widget. The following fragment shows example of
   the specification of a text field.
   
   \small \begin{verbatim}
  <text-field id="x"><text><![CDATA[100]]><text></text-field>\end{verbatim}
  \normalsize

   Input validation may be added in the future. The framework then has the means
   to check and inform the user whether the data entered by the user matches
   the expectations of the tool developer.  For example if the input box should
   contain a number then it can be automatically checked to not contain
   non-digit characters.

   The progress bar is used to show progress to a user. It models progress by
   means of a sub range of the integer domain, specified by a minimum and
   maximum value and shows progress by colouring part of this domain up to some
   `current' value that \emph{must} be in the domain $[ minimum \ldots
   maximum ]$. The example is self explanatory:

   \small \begin{verbatim}
  <progress-bar id="x" minimum="10" maximum="20" current="15"/>\end{verbatim}
  \normalsize

   \noindent Updates to the state of a widget are specified in the same way as
   in the layout specification. The \textit{id} attribute identifies the
   widget of which the state is to be updated. The attributes then specify the
   new value for the attribute with the same name and child elements specify
   other aspects of the state. When attributes are missing, their value remains
   unchanged.

   \paragraph{Layout}

   A display layout specification is represented by a \textit{display-layout}
   element that contains a single \textit{layout-manager} element, called the
   \textit{top layout manager}.

   \small \begin{verbatim}
  <display-layout>
   <layout-manager>
    <box-layout-manager variant="vertical" id="x">
     ...
    </box-layout-manager>
   </layout-manager>
  </display-layout>\end{verbatim}
  \normalsize

   \noindent The layout manager specifies the way in which elements are laid
   out across the display.  The \textit{box-layout-manager} has a
   \textit{variant} attribute that specifies the direction in which the
   elements directly contained in it are laid out on the available space.
   Child elements are laid out on the screen horizontally, or vertically and
   are expanded to fill space. The top layout manager completely fills the
   available space of the display. The following figure shows an example of how
   widgets can be laid out using nested layout managers.

   \begin{figure}[H]
    \begin{center}
     \includegraphics{example_layout.eps}
    \end{center}
    \caption{Example layout with annotation}
   \end{figure}

   \noindent The dotted lines mark the boundaries of space allocated to
   different layout managers at the same nesting level. The picture illustrates
   the use of layout properties and how they influence the layout. A complete
   listing of the XML specification that can be used to generate the layout in
   the picture will be given later after layout properties are discussed in
   more detail.

   A number of layout properties provide more control over how elements are
   positioned and if they are visible and active (enabled/disabled). The
   available properties are: alignment, margins (as pixels) one of (top, right,
   bottom, left), vertical alignment (top, middle, bottom),
   horizontal-alignment (left, center, right), element visibility and element
   activity.
   More attention is in order for element activity. Every widget can be
   enabled or disabled for user interaction. A widget is \textit{active} when
   the user can interact with it. This notion is extended to layout managers
   and thereby arbitrary elements as follows. If a layout manager is inactive
   all elements it widgets are inactive.
   
   Every element that is a child of a layout manager is associated with a value
   for each of the available layout properties. An implicit set of default
   values is assumed that can be used to reduce specification size.
   The default properties are as follows: alignment is left, no margins,
   elements are enabled and visible. The effective properties of an element are
   relative to that of the previous child. For example:

   \enlargethispage{-\baselineskip}

   \small \begin{verbatim}
 <box-layout-manager variant="vertical" id="">
  <properties margin-top="1" margin-bottom="1" horizontal-alignment="right" />
  <button><![CDATA[Ok]]></button>
  <properties />
  <button><![CDATA[Cancel]]></button>
 </box-layout-manager>\end{verbatim}
 \normalsize

   \noindent The layout properties for both buttons are the same, top and bottom margins
   are one pixel, vertical alignment is middle and horizontal alignment is right
   and both elements are visible and enabled. The \textit{properties} element
   directly preceding a widget specify the layout properties for that widget. If
   there is no properties element then the previous \textit{properties} element
   within the same layout manager defines the layout properties for that
   element.

   The following figures shows a non-trivial layout specification that belongs
   to the overview picture presented earlier.

   \small \begin{verbatim}
 <display-layout>
  <layout-manager>
   <box-layout-manager variant="horizontal" id="top">
    <box-layout-manager variant="vertical" id="top_top">
     <box-layout-manager variant="vertical" id="top_top_left">
      <properties margin-left="5" margin-top="10">
      <label id="alabel"><![CDATA[This is a label]]></label>
     </box-layout-manager>
     <box-layout-manager variant="vertical" id="top_top_right">
      <properties margin-left="0" margin-top="0" horizontal-alignment="center">
      <box-layout-manager variant="vertical" id="top_top_right_top">
       <properties horizontal-alignment="center">
       <button id="abutton"><![CDATA[B Button]]></button>
      </box-layout-manager>
      <box-layout-manager variant="vertical" id="top_top_right_bottom">
       <properties horizontal-alignment="left">
       <button id="abutton"><![CDATA[A Button]]></button>
      </box-layout-manager>
     </box-layout-manager>
    </box-layout-manager>
    <box-layout-manager variant="vertical" id="top_bottom">
     <properties horizontal-alignment="center">
     <progress-bar id="progress" minimum="0" maximum="1000" current="350" />
    </box-layout-manager>
   </box-layout-manager>
  </layout-manager>
 </display-layout>\end{verbatim}
  \normalsize

  \noindent Pay careful attention to the use of properties to control margins and
  alignment. Especially the default values of attributes relative to the
  previous \textit{properties} element.

  \subsection{Extensibility}

   Protocol extension is performed by increasing the major version number and
   introducing the changes. The increase in version number is supposed to make
   it easy to test whether additional functionality with respect to previous
   versions is available and/or to signal compatibility mode. The capabilities
   request-response mechanism can be used check finer degrees of compatibility.
   
  \section{Comparison}
  
   How does our approach measure up to other approaches to tool integration?  In
   Eucalyptus, the graphical front-end to CADP, detailed knowledge about the
   capabilities of individual tools as well as file formats seems to be
   integrated. Such coupling is very tight and limits its applicability. We set
   our target somewhat higher. We have chosen to avoid building in knowledge
   about particular tools or even file formats.
   
   Other approaches we know of are the electronic tool integration platform
   (ETI) \cite{RICVT} and repository (\cite{SFAV}). The former is a platform
   that uses web-services (using SOAP \cite{SOAP} and WSDL \cite{2001-WSDL})
   in order to loosely connect tools in a way very similar to ours. A tool can
   be connected by means of filling in a web-form that generates an XML file
   that represents the tools' interface.  This is very similar to the XML
   formatted message on tools capabilities. Connected tools are aware of the
   integration context and ETI offers facilities that are usable to tools via
   Java-specific remote procedure calls.
   
   Repository also uses web-services but in contrast to ETI, the connection
   between tool and framework is through specialised scripts. This puts it
   somewhere in between Eucalyptus and ETI. The tools are not aware of the
   integration context so a script is needed to make a tool behave properly in
   the integration context.
 
   For all of the above approaches it seems that tools communicate through
   files.  A serious consideration on our side was that files could grow very
   big and that you do not want to copy those files unnecessarily across a
   network. This does not necessarily preclude the use of web-services as
   interface between tools and an integration framework. But it does not make
   it the most logical candidate either. Truthfully the use of web-services was
   not considered until a protocol implementation was already available.

  \section{Afterthoughts}

   After work had started on implementation an new XML-based protocol called
   XMPP core came into view.  Quickly summarised: is a relatively compact open
   communication protocol that that relies on TCP/IP to transport two XML
   streams (one for each direction), also see \cite{Sperberg-McQueen:06:EML}.
   At some point XMPP core (Extensible Messaging and Presence Protocol,
   \cite{rfc3920}) even became an official standard. This protocol offers basic
   messaging functionality including a request-response and publish-subscribe
   mechanisms.
   
   In hind-sight we would have liked to take XMPP core as a basis and extend it
   to meet our purposes. It seems to be a perfect match and could have saved a
   lot of development work.

  \enlargethispage*{4pt}
  \bibliography{references}

  \section{Appendix}
  \pagestyle{empty}

  \subsection{Behavioural model}
   The following listing shows an mCRL2 model of the combined communication
   behaviour of the protocol. Besides communication tool start and termination
   only communications actions are visible. The model features a single
   controller and a single tool.

  \small \verbatiminput{protocol.mcrl2} \normalsize
%  \rotatebox{90}{\verbatiminput{protocol.mcrl2}}

  \pagebreak

  \subsection{Graphical Representation of Communication Behaviour}

   The following figure shows a graphical representation of the communication
   behaviour using the mCRL2 model presented previously. For presentation
   purposes the communication actions have been replaced by the names of the
   message they communicate.  The picture was generated with the ltsgraph tool
   after instantiating the state-space and and minimising modulo
   branching-bisimulation. The final result took some manual polishing.

  \begin{figure}[H]
   \includegraphics[width=\textwidth]{protocol.eps}
   \caption{Graphical representation of the state-space}
  \end{figure}

   The constraints as they are found in section
   \ref{s:high_level_specification} together make up the behaviour depicted
   above. What is visible is the intended pattern of communication. A protocol
   implementation must abort with an error condition for message sequences
   outside those allowed by the model.

  \pagebreak

  \subsection{XML Schema for Messages}
  \label{subsection:xml_schema_messages}

  A formal specification of the syntax of messages is given by the following
  XML schema listing. The main element is a message with a mandatory attribute
  type. The value of the message type attribute determines the contents of the
  message.

  \small \verbatiminput{protocol.xsd} \normalsize
%   The purpose of the protocol is make it possible for a user to control of a
%   tool through facilities offered by a separate system that acts as
%   intermediary. The protocol describes how a tool can be configured to perform
%   a task, how it can be made to perform this task and report the results.  A
%   task specification comes into being by interaction with the user through the
%   system. The protocol describes this process.  The most important
%   functionality offered by the protocol is repeatability of the configuration
%   process based on a previous configuration.
   
%   The deskSQuADT application currently uses the protocol as its only method
%   for controlling tools. The most important features provided by the current
%   version are:
%    \begin{itemize}
%     \item dependencies generated by application of tools on files are
%     visualised
%     \item change propagation through (semi-)automated task execution for
%     repeating tasks; changes in input are detected and tools are re-executed
%     on request to ensure up-to-date outputs
%     \item data consistency is guarded by avoiding concurrent execution of
%     tasks that share inputs or outputs
%    \end{itemize}
%   All of these features are the result of functionality purposefully built
%   into the protocol.
   
%   Experience so far has told us that the current ability to fill and
%   manipulate the display is rather limited. Interaction with the user would
%   improve with a broader choice in controls and more fine-grained control over
%   the layout. A good example of useful additional control over layout would be
%   hiding or disabling controls in a layout when they are not needed.

%   Since the decision was made to create a custom implementation for the
%   protocol, see section \ref{s:protocol_implementation}, the XMPP protocol has
%   been formalised by the Internet Engineering Task Force (IETF). This means it
%   is now an open internet standard. Because he notion of a message is
%   approximately the same for the protocols, It was (and remains) an option to
%   use our protocol on top of XMPP.

%   It is still interesting to consider implementing this protocol on top of
%   XMPP. The latter has additional functionality that can be used to help solve
%   other tool integration problems. An example of this is active communication
%   between multiple tools through a publish-subscribe mechanism.  A future
%   extension to the protocol or perhaps even another protocol can offer such
%   functionality.

\end{document}
