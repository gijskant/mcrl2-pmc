// Author(s): Muck van Weerdenburg
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//
/// \file ltsmin.cpp
/// \brief Based on bsim.c (revision 1.1.1.1) from the muCRL toolset

#define NAME "ltsmin"
#define AUTHOR "Muck van Weerdenburg"

#include "mcrl2/core/struct.h"
#include "mcrl2/utilities/aterm_ext.h"
#include "ltsmin.h"
#include "mcrl2/core/messaging.h"
#include "mcrl2/utilities/command_line_interface.h" // after messaging.h and rewrite.h

#ifdef __cplusplus
using namespace mcrl2::utilities;
using namespace mcrl2::core;
#endif

int traceLevel = 0, optimal = 0, classes = 0, add_state_parameter = 0; 

struct t_tool_options {
  std::string inputname;
  std::string outputname;
  int         task;
};

t_tool_options parse_command_line(int ac, char** av) {
  using namespace mcrl2::utilities;

  interface_description clinterface(av[0], NAME, AUTHOR, "[OPTION]... INFILE OUTFILE\n"
    "Minimise the LTS in the SVC format from INFILE using bisimulation reduction and save the resulting LTS to OUTFILE.\n"
    "\n"
    "Note that the input SVC file must have been generated by lps2lts.");

  clinterface.
    add_option("strong",
      "minimise using strong bisimulation (default)", 's').
    add_option("branching",
      "minimise using branching bisimulation", 'b').
    add_option("add",
      "do not minimise but save a copy of the original LTS extended with a "
      "state parameter indicating the bisimulation class a state belongs to ", 'a').
    add_option("tau", make_mandatory_argument("ACTNAME"),
        "consider action with name ACTNAME to be an internal (tau) action");

  command_line_parser parser(clinterface, ac, av);

  t_tool_options options;

  options.task = CMD_REDUCE;

  if (0 < parser.options.count("verbose") + parser.options.count("debug")) {
    traceLevel=1;
  }
  if (0 < parser.options.count("branching") && 0 < parser.options.count("strong")) {
    parser.error("Error options -b/--branching and -s/--strong cannot be used together");
  }
  else if (0 < parser.options.count("strong")) {
    options.task = CMD_REDUCE;
  }
  else if (0 < parser.options.count("branching")) {
    options.task = CMD_BRANCH_REDUCE;
  }
  if (0 < parser.options.count("add")) {
    add_state_parameter = 1;
  }
  if (0 < parser.options.count("tau")) {
    add_tau_action(strdup(parser.option_argument("tau").c_str()));
  }

  if (0 < parser.arguments.size()) {
    options.inputname = parser.arguments[0].c_str();
  }
  if (1 < parser.arguments.size()) {
    options.outputname = parser.arguments[1];
  }
  if (parser.arguments.size() != 2) {
    parser.error("incorrect number of arguments");
  }
  if (options.inputname == options.outputname) {
    parser.error("input file and output file are not allowed to be the same");
  }

  return options;
}

int doReduce(t_tool_options const& options);
int doBranchReduce(t_tool_options const& options);

int main(int argc, char *argv[])
{
  MCRL2_ATERM_INIT(argc, argv)

  gsWarningMsg("the use of this tool is deprecated; use ltsconvert instead\n");

  try {
    t_tool_options options(parse_command_line(argc, argv));

    SVCbool indexed = SVCfalse;

    if ( SVCopen(inFile, const_cast < char* > (options.inputname.c_str()), SVCread, readIndex) )
    {
      throw std::runtime_error(options.inputname + ": " + std::string(SVCerror(SVCerrno)));
    } else {
      if ( SVCopen(outFile, const_cast < char* > (options.outputname.c_str()), SVCwrite, &indexed) )
      {
        throw std::runtime_error(options.outputname + ": " + std::string(SVCerror(SVCerrno)));
      } else {
        SVCsetVersion(outFile , MCRL2_VERSION); 
      }
    }

    if (options.task == CMD_BRANCH_REDUCE) {
      return doBranchReduce(options);
    }

    return doReduce(options);
  }
  catch (std::exception& e) {
    std::cerr << e.what() << std::endl;
  }

  return EXIT_FAILURE;
} /* main */

int doReduce(t_tool_options const& options) 
  {
  SVCstateIndex initState = ReadData(); 
  Reduce();
  if ( add_state_parameter )
  {
    SVCbool b;
    SVCfile inf;
    SVCopen(&inf, const_cast < char* > (options.inputname.c_str()), SVCread, &b);
    WriteDataAddParam(&inf,initState,WITH_TAULOOPS);
  } else {
    WriteData(initState,WITH_TAULOOPS);
  }
  return 0; 
  }
  
int doBranchReduce(t_tool_options const& options) 
  {
  SVCstateIndex initState = ReadData();
  SCC();
//  initState = ReturnEquivalenceClasses(initState, DELETE_TAULOOPS);
  /* ATwarning("Number of states after deletion of tau loops: %d\n", nstate); */
  ReduceBranching();  
  if ( add_state_parameter )
  {
    SVCbool b;
    SVCfile inf;
    SVCopen(&inf, const_cast < char* > (options.inputname.c_str()), SVCread, &b);
    WriteDataAddParam(&inf,initState,DELETE_TAULOOPS);
  } else {
    WriteData(initState, DELETE_TAULOOPS);
  }
  return 0; 
  } 
   /* doCompare */
int doCompare(void) 
  {
  SVCstateIndex init1, init2;
  ReadCompareData(&init1, &init2);
  if (Compare(init1, init2)) return EXIT_NOTOK;
  if (traceLevel) ATwarning("Transition systems are strongly bisimilar\n");
  return EXIT_OK; 
  }
   /* doCompare */
int doBranchCompare(void) 
  {
  SVCstateIndex init1, init2;
  ReadCompareData(&init1, &init2);
  if (CompareBranching(init1, init2)) return EXIT_NOTOK;
  if (traceLevel) ATwarning("Transition systems are branching bisimilar\n");
  return EXIT_OK; 
  } /* doCompare */
