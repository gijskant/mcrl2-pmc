sort Anno = struct at(_cp: CP, _do: List(CP)) | at_s(_cp_s: CP);
map
  AnnoDY: Anno;
  AnnoNone: Anno;
var
  vs: Values;
  a, a': Anno;
eqn
  AnnoDY   = at_s(CPDY);
  AnnoNone = at_s(UCP);

sort Values = List(Value);

sort Ciphertext = struct Cpair(_vs: List(Value), _a: Anno);


sort Value = struct
    N (_n: Name)?is_N
  | C (_c: Ciphertext)?is_C
  ;

map
% more intuitive names for ciphertext elements

  encrypt: Values # Value # Anno -> Value;
  encrypt: Values # Value -> Value;
  encrypt: Values # Anno -> Value;
  encrypt: Values -> Value;
var 
  c: Ciphertext;
  v, k: Value;
  vs: Values;
  ad: Anno;
eqn
  encrypt(vs, k, ad) = C(Cpair(k |> vs, ad));
  encrypt(vs, k)     = C(Cpair(k |> vs, AnnoNone));
  encrypt(vs, ad)    = C(Cpair(vs, ad));
  encrypt(vs)        = C(Cpair(vs, AnnoNone));  
  


map 
  matchDO: Anno#Anno -> Bool;
var 
  o, d: CP;
  O, D: List(CP);
eqn
  matchDO(at(d, D), at(o, O)) = (d in O) && (o in D);
  matchDO(at_s(d),  at(o, O)) = (d in O);
  matchDO(at(d, D), at_s(o))  = (o in D);
  matchDO(at_s(d),  at_s(o))  = true;

act 
  send, recv, c: List(Value);
  FAIL: Value # Value # Anno;
  zero;
  

proc decrypt(x: Value, p: Value, ao: Anno) =
  ((is_C(x)) && (_vs(_c(x)) == _vs(_c(p)))) ->
  (
    matchDO(_a(_c(x)), ao) -> 
      tau
    <>
      FAIL(x, p, ao).delta 
  ) 
  <> 
  delta;

% end of preamble.