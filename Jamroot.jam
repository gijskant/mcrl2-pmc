# Author(s): Jeroen van der Wulp
#
#  Copyright (C) 2008 Eindhoven University of Technology.
#
# Distributed under the Boost Software License, Version 1.0.
# (See accompanying file LICENSE_1_0.txt or copy at
# http://www.boost.org/LICENSE_1_0.txt)
# 
# Main build description containing custom rules to make project descriptions more compact.
#
#  Options:
#
#   Build:
#
#    --enable-debug                 sets: debug-symbols=on runtime-debugging=on
#   
#    --enable-profile               sets: profiling=on
#
#    --enable-optimisation          sets: optimization=speed inlining=full
#
#    --disable-squadt-support       disables squadt support in tools
#   
#    --enable-experimental          activates building/installing of tools that are marked experimental
#
#    --enable-deprecated            activates building/installing of tools that are marked deprecated
#
#   Installation:
#
#    --prefix                       directory relative to which tools/libraries, documentation and examples
#                                   are installed, unless one of the following options is also specified
#
#    --bindir                       directory where binaries are installed
#
#    --libdir                       directory where libraries are installed
#
#    --includedir                   directory where header files are installed
#
#    --datadir                      directory where data is installed
#
#    --destdir                      direcory that is prepended to all of the above paths for installation,
#                                   the built takes place as-if everything would be installed according to
#                                   be above arguments (for binary packaging)
#

import set ;
import path ;
import feature ;
import property ;
import package ;
import feature ;
import option ;
import regex ;

# Constants for commonly used paths
path-constant TOP             : . ;
path-constant BUILD_TOOLS     : ./build/boost_build.v2 ; # Common build directory
path-constant BUILD_TOP       : ./build/bin ;            # Common build directory
path-constant BOOST_ROOT      : ./3rd-party/boost ;      # Boost prefix (packaged sources)

# Activate header cache
modules.poke : HCACHEFILE : $(BUILD_TOP)/.jamdeps ;

# The known sub projects
use-project /site-config               : build ;
use-project /boost                     : 3rd-party/boost ;
use-project /libraries                 : libraries ;
use-project /workarounds               : build/workarounds ;

include $(TOP)/build/config.jam ;

# Helper rules for regession testing
include $(BUILD_TOOLS)/testing.jam ;

# Gets option arguments from options passed on the command line primarily and
# otherwise the BUILD_OPTIONS variable
rule get_option ( name : default ) {
  local result = [ MATCH --$(name)=(.*) : [ modules.peek : ARGV ] $(BUILD_OPTIONS) ] ;

  if $(result) {
    return $(result[1]) ;
  }
  else {
    return $(default) ;
  }
}

rule is_option ( name : default ) {
  local result = [ MATCH --($(name)) : [ modules.peek : ARGV ] $(BUILD_OPTIONS) ] ;

  if $(result) {
    return $(result[1]) ;
  }
  else {
    return $(default) ;
  }
}

# Extract build requirements from command line options
for option in [ modules.peek : ARGV ] {
  local temporary = [ MATCH ([^=]+)= : $(option) ] ;

  if $(temporary) {
    value  = [ MATCH [^=]+=([^=]+)$ : $(option) ] ;

    if ! [ MATCH ^(-).* : $(option) ] {
      build-options += <$(temporary)>$(value) ;
    }
  }
}
# Extract build requirements imported from build/config.jam
for option in $(BUILD_OPTIONS) {
  local temporary = [ MATCH ([^=]+)= : $(option) ] ;

  if $(temporary) {
    if ! [ feature.get-values $(temporary) : $(build-options) ] {
      value = [ MATCH [^=]+=([^=]+)$ : $(option) ] ;
     
      if ! [ MATCH ^(-).* : $(option) ] {
        build-options += $(value:G=<$(temporary)>) ;
      }
    }
  }
}

local link-variant = [ feature.get-values link : $(build-options) <link>shared ] ;

# Make sure the build tag variable is defined
if ! $(BUILD_TAG) {
  local revision = [ SHELL "svnversion -n \"$(TOP)\"" ] ;

  if ! $(revision) {
    $(revision) = "unknown" ;
  }

  BUILD_TAG = "$(revision)-$(link-variant[1])" ;
}
 
prefix = $(TOP)/build/stage ;

# Set installation/stage locations
if install in [ MATCH "^-?-?(install)" : [ modules.peek : ARGV ] ] {
  if [ get_option prefix : no ] = no {
    ECHO "Warning: missing final installation path!" ;
    ECHO "" ;
    ECHO "  This path information is needed for several tools e.g. xsim and squadt." ;
    ECHO "" ;
    ECHO "Hint: Use --prefix=<directory> argument." ;
    ECHO "" ;
  }

  prefix     = [ get_option prefix     : $(prefix) ] ;
  bindir     = [ get_option bindir     : $(prefix)/bin ] ;
  libdir     = [ get_option libdir     : $(prefix)/lib/mcrl2 ] ;
  includedir = [ get_option includedir : $(prefix)/include/mcrl2 ] ;
  datadir    = [ get_option datadir    : $(prefix)/share/mcrl2 ] ;
}
else {
  bindir = $(prefix) ;
  libdir = $(prefix)/lib ;
}

# Feature for building/installing optional tools/libraries
feature.feature install : no yes ;

# Enable/disable squadt connectivity code in tools
feature.feature squadt-support : yes no ;

# Feature to mark tools as basic experimental or deprecated
feature.feature status : basic experimental deprecated : composite ;

# Specifies that squadt connectivity is implemented in a tool
feature.feature squadt-connectivity : none implemented : incidental composite ;

# Top project
project toolset
       : build-dir $(BUILD_TOP)
       : requirements
          <define>_FILE_OFFSET_BITS=64
          <toolset>msvc:<pch>off
          <use>/workarounds//configuration
          <link>static,<squadt-support>yes:<threading>multi
          <toolset>gcc,<link>static:<linkflags>-export-dynamic
          $(build-options)
          <dll-path>$(libdir)
       : default-build
          <link>$(link-variant)
       ;

# Only from the root of the source tree
if [ path.exists ./tools ] {
  if [ is_option enable-experimental : no ] = no {
    ECHO "Notice: not building experimental tools!" ;
  
    feature.compose <status>experimental : <install>no ;
  }
  if [ is_option enable-deprecated : no ] = no {
    ECHO "Notice: not building deprecated tools!" ;
  
    feature.compose <status>deprecated : <install>no ;
  }
  
  if [ is_option disable-squadt-support : no ] = no {
    feature.feature squadt-interface : enabled disabled : symmetric optional ;
  
    feature.compose <squadt-connectivity>implemented
          : <squadt-interface>enabled
            <threading>multi
            <library>/libraries/utilities//squadt_interface
          ;
  }
  else {
    ECHO "Notice: not building squadt support in tools!" ;
  
    feature.set-default squadt-support : no ;
  
    feature.feature squadt-interface : disabled enabled : implicit incidental ;
  
    feature.compose <squadt-connectivity>implemented
          : <squadt-interface>disabled
          ;
  }
   
  root  = [ path.make $(TOP) ] ; 
  tools = [ MATCH $(root)/tools/(.*)/.* : [ glob $(TOP)/tools/*/Jamfile.v2 ] ] ;

  local targets  = [ set.intersection [ MATCH "^([0-9a-zA-Z_]+)$" : [ modules.peek : ARGV ] ] : $(tools) ] ;
  local disabled = [ MATCH "^--disable-tools=([,0-9a-zA-Z_]+)$" : [ modules.peek : ARGV ] ] ;

  if ! $(targets) {
    targets = $(tools) ;
  }
  if $(disabled) {
    targets = [ set.difference $(targets) : [ regex.split "$(disabled)" "," ] ] ;
  }

  # Register tool projects
  for tool in $(targets) {
    # Register tool projects
    use-project /tools/$(tool) : tools/$(tool) ;
  }

  # Install when requested
  if ! install in [ MATCH "^-?-?(install)" : [ modules.peek : ARGV ] ] {
    # Introduce tool targets
    for tool in $(targets) {
      alias $(tool) : stage ;
    }

    if ! $(tools) in $(targets) {
      ECHO "Building selected tools :" $(targets) ;
    }

    targets = /tools/$(targets)//stage ;

    alias stage : $(targets) : <location>build/stage ;
  }
  else {
    feature.set-default install : yes ;

    # Add prefix for packaging
    if [ get_option destdir : no ] != no {
      local destdir  = [ get_option destdir : "" ] ;
 
      prefix     = $(destdir)$(prefix) ;
      bindir     = $(destdir)$(bindir) ;
      libdir     = $(destdir)$(libdir) ;
      includedir = $(destdir)$(includedir) ;
      datadir    = $(destdir)$(datadir) ;
    }

    if ! $(tools) in $(targets) {
      ECHO "Installing selected tools only :" $(targets) ;

      # Introduce tool targets
      for tool in $(targets) {
        alias $(tool) : install ;
      }

      targets = /tools/$(targets)//install ;
    }
    else {
      # Complete install
      targets = /tools/$(tools)//install /libraries//install-all install-examples ;

      # General examples
      install install-examples
              : [ path.glob-tree $(TOP)/examples : *.txt *.mcrl2 *.pnml *.mcf *.fsm *.trc project.xml : .svn ]
              : <location>$(datadir)
                <install-source-root>.
              ;
    }

    alias install : $(targets) ;
  }
}

rule install-tools ( executables * : requirements * ) {
  local rule-name   = install ;
  local destination = $(bindir) ;
  local targets ;

  if [ feature.defaults <install> ] != <install>yes {
    rule-name   = stage ;
    destination = $(TOP)/build/stage ;
  }

  if $(executables) {
    if [ modules.peek : NT ] {
      install shared-libraries : $(executables) : <install-dependencies>on <install-type>SHARED_LIB <location>$(bindir) ;
    }
    else {
      install shared-libraries : $(executables) : <install-dependencies>on <install-type>LIB <location>$(libdir) ;
    }

    targets = shared-libraries ; 
  }

  # OS X bundle installation
  if [ modules.peek : OS ] = MACOSX {
    import build/macosx/mac-bundle ;

    # wxWidgets support is activated, so creation of application bundles may be required
    bundles = [ MATCH (.*).plist : [ glob *.plist ] ] ;

    # Create bundle targets
    for bundle in $(bundles) {
      mac-bundle $(bundle).app
           : $(bundle)
             $(bundle).plist
             $(bundle).icns
           : <location>$(prefix)
           ;
    }

    executables = [ set.difference $(executables) : $(bundles) ] ;

    if $(bundles) && $(WX_CPPFLAGS) {
      targets += $(bundles).app ;
    }
  }

  if $(executables) {
    install other : $(executables) : $(requirements) <install-dependencies>off <install-type>EXE <location>$(destination) ;

    if [ property.select source : $(requirements) ] && [ feature.get-values link : $(build-options) ] != static {
      local plugin-targets = [ feature.get-values source : $(requirements) ] ;

      targets += $(plugin-targets)//$(rule-name) ;
    }

    targets += other ;
  }

  alias $(rule-name) : $(targets) ;

  local c = [ project.current ] ;

  module [ $(c).project-module ] {
    explicit stage install ;
  }
}

rule install-libraries ( libraries * : requirements * ) {
  local headers = [ glob-tree *.h *.hpp *.ipp : .svn build* test* source* example* ] ;

  if [ feature.defaults <install> ] = <install>yes {
    # Get install location information
    if ! [ property.select location : $(requirements) ] {
      if [ modules.peek : NT ] {
        requirements += <location>$(libdir) ;
      }
      else {
        requirements += <location>$(bindir) ;
      }
    }

    install install-library : $(libraries) : <install-type>LIB $(requirements) ;

    requirements = [ property.change $(requirements) : <location> $(includedir) ] ;

    # Instal header files
    if [ MATCH $(root)/.*(include/mcrl2/.*) : $(headers) ] {
      # filter out headers not in mcrl2 directory
      headers = [ MATCH (.*/include/mcrl2/.*) : $(headers) ] ;

      requirements += <install-source-root>../include/mcrl2 ;
    }
    else {
      headers = [ MATCH (.*/include/$(libraries)/.*) : $(headers) ] ;

      requirements += <install-source-root>../include ;
    }

    install install-headers : [ MATCH $(root)/.*(include/.*) : $(headers) ] : $(requirements) ;

    alias install : install-headers install-library ;
  }
  else {
    install stage : $(libraries) : <location>$(TOP)/build/stage ;
  }

  local c = [ project.current ] ;

  module [ $(c).project-module ] {
    explicit stage install install-library ;
  }
}

# For plugins (dynamic linked libraries)
rule plugin ( name : sources * : requirements * : defaults * : usage-requirements * ) {
  local make_alias = false ;

  if [ feature.get-values link : $(build-options) ] = static {
    make_alias = true ;
  }
  if [ property.select opengl : $(requirements) ] {
    if [ feature.get-values opengl : $(requirements) ] = yes {
      if $(OPENGL_NAME) {
        make_alias = true ;
      }
    }
  }
  if [ property.select wx : $(requirements) ] {
    if [ feature.get-values wx : $(requirements) ] = yes {
      if ! $(WX_CPPFLAGS) {
        make_alias = true ;
      }
    }
  }

  requirements = [ property.remove opengl status wx : $(requirements) ] ;

  if $(make_alias) = true {
    alias $(name) ;

    # For incomplete builds (for instance without wxWidgets dependent tools)
    alias install ;
    alias stage ;
  }
  else {
    lib $(name) : $(sources) : $(requirements) <link>shared <toolset>darwin:<bundle>yes : $(defaults) : $(usage-requirements) ;

    install-libraries $(name) : <location>$(libdir)/plugins ;
  }
}

# Target for a tool in the mcrl2 toolset
rule tool ( name : sources * : requirements * : defaults * : usage-requirements * ) {
  local make_alias = false ;
  local additional-requirements = <define>PREFIX=\"\\\"$(prefix)\\\"\"
                                  <define>PLUGINDIR=\"\\\"$(libdir)/plugins\\\"\"
                                  <define>MCRL2_REVISION=\"\\\"$(BUILD_TAG)\\\"\" ;

  if [ property.select status : $(requirements) ] {
    # do not install if the expanded property set contains <install>
    if [ property.select install : [ feature.expand [ property.select status : $(requirements) ] ] ] {
      make_alias = true ;
    }
  }
  if [ property.select opengl : $(requirements) ] {
    if [ feature.get-values opengl : $(requirements) ] = yes {
      if $(OPENGL_NAME) {
        make_alias = true ;
      }
    }
  }
  if [ property.select wx : $(requirements) ] {
    if [ feature.get-values wx : $(requirements) ] = yes {
      if ! $(WX_CPPFLAGS) {
        make_alias = true ;
      }
    }

    additional-requirements += <toolset>darwin:<linkflags>"-undefined dynamic_lookup" 
                               <os>NT,<toolset>gcc:<linkflags>"-Wl,-subsystem:windows -mwindows"
                               <os>CYGWIN:<linkflags>"-Wl,-subsystem:windows -mwindows" ;
  }

  requirements = [ property.remove opengl status wx : $(requirements) ] ;

  if $(make_alias) = true {
    alias $(name) ;
  }
  else {
    exe $(name) : $(sources) : $(requirements) $(additional-requirements) : $(defaults) : $(usage-requirements) ;
  }
}

# Target for a library that is part of the big mcrl2 library when link=static
rule mcrl2-library ( name : sources * : requirements * : defaults * : usage-requirements * ) {
  if $(sources) {
    if [ feature.get-values link : $(build-options) ] != static {
      # build target for inclusion by mcrl2 library
      alias $(name).alias : $(sources) : $(requirements) : $(defaults) : $(requirements) ;

      # shared library target
      alias $(name) : /libraries//mcrl2 : <link>shared : : $(requirements) ;
    }
    else {
      # static library target
      lib $(name) : $(sources) : $(requirements) : $(defaults) : $(requirements) $(usage-requirements) ;

      alias $(name).alias ;
    }
  }
  else {
    alias $(name) : : : : $(requirements) ;
    alias $(name).alias ;
  }

  alias headers : : $(requirements) : : $(requirements) ;

  install-libraries $(name) ;

  local c = [ project.current ] ;

  module [ $(c).project-module ] {
    explicit $(name).alias $(name) headers ;
  }
}
