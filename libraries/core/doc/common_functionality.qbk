[chapter Common Functionality
    [quickbook 1.4]
    [authors [Wesselink, Wieger]]
    [copyright 2005-2010 Technische Universiteit Eindhoven]
    [category string-text]
    [purpose
       - 
    ]
]

The mCRL2 Library contains some algorithms that are applicable to several libraries.
The most prominent example is a traversal framework and a family of find functions
that has been implemented on top of that. This chapter discusses some of these
algorithms.

[include algorithms.qbk]

[section: Generic programming techniques]

The file =mcrl2/data/detail/container_utility.h= contains two utility functions
`enable_if_container` and `disable_if_container` for determining if a type is a container type.
It can be used to create an interface that does different things for containers and for
other types:

    template <typename Container>
    void operator()(const Container& t, typename data::detail::enable_if_container<Container>::type* = 0)
    {
      traverse_container(t);
    }

    template <typename Term>
    void operator()(const Term& t, typename data::detail::disable_if_container<Term>::type* = 0)
    {
      traverse(t);
    }

[endsect]

[section: Static polymorphism]

For the traversal functions in the mCRL2 a technique called static
polymorphism is used, see also [@ http://en.wikipedia.org/wiki/Template_metaprogramming#Static_polymorphism].

Below an example is given how static polymorphism can in principle be
used to implement find functions in the mCRL2 Library.
In this case, A models data::detail::traverser, B models lps::detail::traverser
and C models data::detail::find_helper.
  
  #include <iostream>
  
  // base class
  template <typename Derived>
  struct A
  {
    void a()
    {
      std::cout << "A::a()" << std::endl;
    }
  };
  
  // extended class
  template <typename Derived>
  struct B: public A<Derived>
  {
    void b()
    {
      std::cout << "B::b()" << std::endl;
      static_cast<Derived&>(*this).a();
    } 
  };
  
  // override the a() function
  template <template <class> class T>
  struct override: public T<override<T> >
  {
    void a()
    {
      std::cout << "override::a()" << std::endl;
    }
  };
  
  int main()
  { 
    override<B> f;
    f.a();
    f.b();
  
    return 0;
  }

[endsect]

[include concepts.qbk]
