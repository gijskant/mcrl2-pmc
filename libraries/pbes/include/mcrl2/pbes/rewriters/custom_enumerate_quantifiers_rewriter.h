// Author(s): Wieger Wesselink
// Copyright: see the accompanying file COPYING or copy at
// https://svn.win.tue.nl/trac/MCRL2/browser/trunk/COPYING
//
// Distributed under the Boost Software License, Version 1.0.
// (See accompanying file LICENSE_1_0.txt or copy at
// http://www.boost.org/LICENSE_1_0.txt)
//
/// \file mcrl2/pbes/rewriters/custom_enumerate_quantifiers_rewriter.h
/// \brief add your file description here.

#ifndef MCRL2_PBES_REWRITERS_CUSTOM_ENUMERATE_QUANTIFIERS_REWRITER_H
#define MCRL2_PBES_REWRITERS_CUSTOM_ENUMERATE_QUANTIFIERS_REWRITER_H

#include "mcrl2/data/enumerator.h"
#include "mcrl2/pbes/detail/enumerate_quantifiers_builder.h"
#include "mcrl2/pbes/pbes_expression_with_variables.h"

namespace mcrl2 {

namespace pbes_system {

namespace detail {

// inserts elements of c into s
template <typename T, typename Container>
void set_insert(std::set<T>& s, const Container& c)
{
  for (auto i = c.begin(); i != c.end(); ++i)
  {
    s.insert(*i);
  }
}

// removes elements of c from s
template <typename T, typename Container>
void set_remove(std::set<T>& s, const Container& c)
{
  for (auto i = c.begin(); i != c.end(); ++i)
  {
    s.erase(*i);
  }
}

template <typename PbesRewriter>
class quantifier_enumerator1
{
  protected:
    PbesRewriter& pbesr;
    const data::data_enumerator& datae;

    typedef typename core::term_traits<pbes_expression> tr;

    /// Exception that is used as an early escape of the foreach_sequence algorithm.
    struct stop_early
      {};

    /// Joins a sequence of pbes expressions with operator and
    struct join_and
    {
      /// \brief Returns the conjunction of a sequence of pbes expressions
      /// \param first Start of a sequence of pbes expressions
      /// \param last End of a sequence of pbes expressions
      /// \return The conjunction of the expressions
      template <typename FwdIt>
      pbes_expression operator()(FwdIt first, FwdIt last) const
      {
        return std::accumulate(first, last, core::term_traits<pbes_expression>::true_(), &utilities::optimized_and<pbes_expression>);
      }
    };

    /// Joins a sequence of pbes expressions with operator or
    struct join_or
    {
      /// \brief Returns the disjunction of a sequence of pbes expressions
      /// \param first Start of a sequence of pbes expressions
      /// \param last End of a sequence of pbes expressions
      /// \return The disjunction of the expressions
      template <typename FwdIt>
      pbes_expression operator()(FwdIt first, FwdIt last) const
      {
        return std::accumulate(first, last, core::term_traits<pbes_expression>::false_(), &utilities::optimized_or<pbes_expression>);
      }
    };

    /// The assign operation used to create sequences in the foreach_sequence algorithm
    template <typename SubstitutionFunction>
    struct sequence_assign
    {
      typedef typename SubstitutionFunction::variable_type variable_type;
      typedef typename SubstitutionFunction::expression_type pbes_expression;

      SubstitutionFunction& sigma_;

      sequence_assign(SubstitutionFunction& sigma)
        : sigma_(sigma)
      {}

      /// \brief Function call operator
      /// \param v A variable
      /// \param t A term
      void operator()(const data::variable& v, const pbes_expression& t)
      {
        sigma_[v] = t;
      }
    };

    /// The action that is triggered for each sequence generated by the
    /// foreach_sequence algorithm. It is invoked for every sequence of
    /// substitutions of the set Z in the algorithm.
    template <typename SubstitutionFunction, typename StopCriterion>
    struct sequence_action
    {
      std::set<pbes_expression>& A_;
      PbesRewriter& r_;
      const pbes_expression& phi_;
      SubstitutionFunction& sigma_;
      const std::set<data::variable>& v_;
      bool& is_constant_;
      StopCriterion stop_;

      /// \brief Determines if the unordered sequences s1 and s2 have an empty intersection
      /// \param s1 A sequence
      /// \param s2 A sequence
      /// \return True if the intersection of s1 and s2 is empty
      template <typename Sequence, typename Set>
      bool empty_intersection(const Sequence& s1, const Set& s2)
      {
        for (auto i = s1.begin(); i != s1.end(); ++i)
        {
          if (s2.find(*i) != s2.end())
          {
            return false;
          }
        }
        return true;
      }

      sequence_action(std::set<pbes_expression>& A,
                      PbesRewriter& r,
                      const pbes_expression& phi,
                      SubstitutionFunction& sigma,
                      const std::set<data::variable>& v,
                      bool& is_constant,
                      StopCriterion stop
                     )
        : A_(A), r_(r), phi_(phi), sigma_(sigma), v_(v), is_constant_(is_constant), stop_(stop)
      {}

      /// \brief Function call operator
      void operator()()
      {
        pbes_expression c = r_(phi_, sigma_);
        std::set<data::variable> FV_c = pbes_system::find_free_variables(c);

#ifdef MCRL2_ENUMERATE_QUANTIFIERS_BUILDER_DEBUG
        mCRL2log(log::verbose) << "        Z = Z + " << pbes_system::pp(c) << (empty_intersection(c.variables(), v_) ? " (constant)" : "") << " sigma = " << data::print_substitution(sigma_) << " dependencies = " << print_term_container(v_) << std::endl;
#endif
        if (stop_(c))
        {
          throw stop_early();
        }
        else if (empty_intersection(FV_c, v_))
        {
#ifdef MCRL2_ENUMERATE_QUANTIFIERS_BUILDER_DEBUG
          mCRL2log(log::verbose) << "        A = A + " << pbes_system::pp(c) << std::endl;
#endif
          A_.insert(c);
        }
        else
        {
          is_constant_ = false;
        }
      }
    };

    /// Convenience function for generating a sequence action
    template <typename SubstitutionFunction, typename StopCriterion>
    sequence_action<SubstitutionFunction, StopCriterion>
    make_sequence_action(std::set<pbes_expression>& A,
                         PbesRewriter& r,
                         const pbes_expression& phi,
                         SubstitutionFunction& sigma,
                         const std::set<data::variable>& v,
                         bool& is_constant,
                         StopCriterion stop
                        )
    {
      return sequence_action<SubstitutionFunction, StopCriterion>(A, r, phi, sigma, v, is_constant, stop);
    }

    /// \brief Prints debug information to standard error
    /// \param x A sequence of variables
    /// \param phi A term
    /// \param sigma A substitution function
    /// \param stop_value A term
    template <typename SubstitutionFunction>
    void print_arguments(data::variable_list x, const pbes_expression& phi, SubstitutionFunction& sigma, pbes_expression stop_value) const
    {
      mCRL2log(log::verbose) << "<enumerate>"
                             << (tr::is_false(stop_value) ? "forall " : "exists ")
                             << data::pp(x) << ". "
                             << pbes_system::pp(phi)
                             << data::print_substitution(sigma) << std::endl;
    }

    /// \brief Returns a string representation of D[i]
    /// \param Di A sequence of data terms
    /// \param i A positive integer
    /// \return A string representation of D[i]
    std::string print_D_element(const std::vector<data::data_expression_with_variables>& Di, std::size_t i) const
    {
      std::ostringstream out;
      out << "D[" << i << "] = " << print_term_container(Di) << std::endl;
      return out.str();
    }

    /// \brief Prints debug information to standard error
    /// \param D The sequence D of the algorithm
    void print_D(const std::vector<std::vector<data::data_expression_with_variables> >& D) const
    {
      for (size_t i = 0; i < D.size(); i++)
      {
        mCRL2log(log::verbose) << "  " << print_D_element(D[i], i);
      }
    }

    /// \brief Returns a string representation of a todo list element
    /// \param e A todo list element
    /// \return A string representation of a todo list element
    std::string print_todo_list_element(const boost::tuple<data::variable, data::data_expression_with_variables, std::size_t>& e) const
    {
      // const data::variable& xk = boost::get<0>(e);
      const data::data_expression_with_variables& y = boost::get<1>(e);
      std::size_t k = boost::get<2>(e);
      return "(" + data::pp(y) + ", " + boost::lexical_cast<std::string>(k) + ")";
    }

    /// \brief Prints a todo list to standard error
    /// \param todo A todo list
    void print_todo_list(const std::deque<boost::tuple<data::variable, data::data_expression_with_variables, std::size_t> >& todo) const
    {
      mCRL2log(log::verbose) << "  todo = [";
      for (auto i = todo.begin(); i != todo.end(); ++i)
      {
        mCRL2log(log::verbose) << (i == todo.begin() ? "" : ", ") << print_todo_list_element(*i);
      }
      mCRL2log(log::verbose) << "]" << std::endl;
    }

    template <typename SubstitutionFunction, typename VariableMap>
    void redo_substitutions(SubstitutionFunction& sigma, const VariableMap& v)
    {
      for (auto i = v.begin(); i != v.end(); ++i)
      {
        sigma[i->first] = i->second;
      }
    }

    template <typename SubstitutionFunction, typename StopCriterion, typename PbesTermJoinFunction>
    pbes_expression enumerate(data::variable_list x,
                        const pbes_expression& phi,
                        SubstitutionFunction& sigma,
                        StopCriterion stop,
                        pbes_expression stop_value,
                        PbesTermJoinFunction join
                       )
    {
      // Undo substitutions to quantifier variables
      std::map<data::variable, data::data_expression_with_variables> undo;
      for (auto i = x.begin(); i != x.end(); ++i)
      {
        pbes_expression sigma_i = sigma(*i);
        if (sigma_i != *i)
        {
          undo[*i] = sigma_i;
          sigma[*i] = *i;
        }
      }

#ifdef MCRL2_ENUMERATE_QUANTIFIERS_BUILDER_DEBUG
      print_arguments(x, phi, sigma, stop_value);
#endif
      pbes_expression Rphi = pbesr(phi, sigma);
      if (tr::is_constant(Rphi))
      {
        redo_substitutions(sigma, undo);
        return Rphi;
      }

      std::set<pbes_expression> A;
      std::vector<std::vector<data::data_expression_with_variables> > D;
      std::set<data::variable> dependencies;

      // For an element (v, t, k) of todo, we have the invariant v == x[k].
      // The variable v is stored for efficiency reasons, it avoids the lookup x[k].
      std::deque<boost::tuple<data::variable, data::data_expression_with_variables, std::size_t> > todo;

      // initialize D and todo
      std::size_t j = 0;
      for (auto i = x.begin(); i != x.end(); ++i)
      {
        data::data_expression_with_variables t = core::term_traits<data::data_expression_with_variables>::variable2term(*i);
        D.push_back(std::vector<data::data_expression_with_variables>(1, t));
        todo.push_back(boost::make_tuple(*i, t, j++));
        set_insert(dependencies, t.variables());
      }

      try
      {
        while (!todo.empty())
        {
          boost::tuple<data::variable, data::data_expression_with_variables, std::size_t> front = todo.front();
#ifdef MCRL2_ENUMERATE_QUANTIFIERS_BUILDER_DEBUG
          print_D(D);
          print_todo_list(todo);
          mCRL2log(log::verbose) << "    (y, k) = " << print_todo_list_element(front) << std::endl;
#endif
          todo.pop_front();
          const data::variable& xk = boost::get<0>(front);
          const data::data_expression_with_variables& y = boost::get<1>(front);
          std::size_t k = boost::get<2>(front);
          bool is_constant = true;

          D[k].erase(std::find(D[k].begin(), D[k].end(), y));
          set_remove(dependencies, y.variables());

          // save D[k] in variable Dk, as a preparation for the foreach_sequence algorithm
          std::vector<data::data_expression_with_variables> Dk = D[k];
          std::vector<data::data_expression_with_variables> z = datae.enumerate(y);
          for (auto i = z.begin(); i != z.end(); ++i)
          {
#ifdef MCRL2_ENUMERATE_QUANTIFIERS_BUILDER_DEBUG
            mCRL2log(log::verbose) << "      e = " << data::pp(*i) << std::endl;
#endif
            set_insert(dependencies, i->variables());
            sigma[xk] = *i;
            D[k].clear();
            D[k].push_back(*i);
            utilities::foreach_sequence(D,
                                   x.begin(),
                                   make_sequence_action(A, pbesr, phi, sigma, dependencies, is_constant, stop),
                                   sequence_assign<SubstitutionFunction>(sigma)
                                  );
            if (!is_constant)
            {
              Dk.push_back(*i);
#ifdef MCRL2_ENUMERATE_QUANTIFIERS_BUILDER_DEBUG
              mCRL2log(log::verbose) << "        " << print_D_element(Dk, k) << std::endl;
#endif
              if (!core::term_traits<data::data_expression_with_variables>::is_constant(*i))
              {
                todo.push_back(boost::make_tuple(xk, *i, k));
              }
              else
              {
                set_remove(dependencies, i->variables());
              }
            }
          }

          // restore D[k]
          D[k] = Dk;
        }
      }
      catch (stop_early&)
      {
        // remove the added substitutions from sigma
        for (auto j = x.begin(); j != x.end(); ++j)
        {
          sigma[*j] = *j; // erase *j
        }
#ifdef MCRL2_ENUMERATE_QUANTIFIERS_BUILDER_DEBUG
        mCRL2log(log::verbose) << "<return>stop early: " << pbes_system::pp(stop_value) << std::endl;
#endif
        redo_substitutions(sigma, undo);
        return stop_value;
      }

      // remove the added substitutions from sigma
      for (auto i = x.begin(); i != x.end(); ++i)
      {
        sigma[*i] = *i; // erase *i
      }
      pbes_expression result = join(A.begin(), A.end());
#ifdef MCRL2_ENUMERATE_QUANTIFIERS_BUILDER_DEBUG
      mCRL2log(log::verbose) << "<return> " << pbes_system::pp(result) << std::endl;
#endif
      redo_substitutions(sigma, undo);
      return result;
    }

  public:
    quantifier_enumerator1(PbesRewriter& r, const data::data_enumerator& e)
      : pbesr(r), datae(e)
    {}

    /// \brief Enumerates a universal quantification
    /// \param x A sequence of variables
    /// \param phi A term
    /// \param sigma A substitution function
    /// \return The enumeration result
    template <typename SubstitutionFunction>
    pbes_expression enumerate_universal_quantification(const data::variable_list& x, const pbes_expression& phi, SubstitutionFunction& sigma)
    {
      return enumerate(x, phi, sigma, tr::is_false, tr::false_(), join_and());
    }

    /// \brief Enumerates an existential quantification
    /// \param x A sequence of variables
    /// \param phi A term
    /// \param sigma A substitution function
    /// \return The enumeration result
    template <typename SubstitutionFunction>
    pbes_expression enumerate_existential_quantification(data::variable_list x, pbes_expression phi, SubstitutionFunction& sigma)
    {
      return enumerate(x, phi, sigma, tr::is_true, tr::true_(), join_or());
    }
};

// Simplifying PBES rewriter that eliminates quantifiers using enumeration.
/// \param SubstitutionFunction This must be a MapSubstitution.
template <typename SubstitutionFunction>
struct custom_enumerate_quantifiers_builder: public simplify_rewrite_builder<pbes_expression, data::rewriter, SubstitutionFunction>
{
  typedef custom_enumerate_quantifiers_builder<SubstitutionFunction> self;
  typedef simplify_rewrite_builder<pbes_expression, data::rewriter, SubstitutionFunction> super;
  typedef core::term_traits<pbes_expression> tr;

  const data::data_enumerator& m_data_enumerator;

  /// If true, quantifier variables of infinite sort are enumerated.
  bool m_enumerate_infinite_sorts;

  /// If true, data expressions are not rewritten.
  bool m_skip_data;

  /// \brief Constructor.
  /// \param r A data rewriter
  /// \param enumerator A data enumerator
  /// \param enumerate_infinite_sorts If true, quantifier variables of infinite sort are enumerated as well
  custom_enumerate_quantifiers_builder(const data::rewriter& r, const data::data_enumerator& enumerator, bool enumerate_infinite_sorts = true, bool skip_data = false)
    : super(r), m_data_enumerator(enumerator), m_enumerate_infinite_sorts(enumerate_infinite_sorts), m_skip_data(skip_data)
  { }


  /// \brief Visit forall node
  /// Visit forall node.
  /// \param x A term
  /// \param variables A sequence of variables
  /// \param phi A term
  /// \param sigma A substitution function
  /// \return The result of visiting the node
  pbes_expression visit_forall(const pbes_expression& /* x */, const data::variable_list& variables, const pbes_expression& phi, SubstitutionFunction& sigma)
  {
#ifdef MCRL2_ENUMERATE_QUANTIFIERS_BUILDER_DEBUG
    mCRL2log(log::verbose) << "<visit_forall>" << tr::pp(forall(variables, phi)) << std::endl;
#endif
    pbes_expression result;
    if (m_enumerate_infinite_sorts)
    {
      result = quantifier_enumerator1<self>(*this, m_data_enumerator).enumerate_universal_quantification(variables, phi, sigma);
    }
    else
    {
      data::variable_list finite;
      data::variable_list infinite;
      split_finite_variables(variables, m_data_enumerator.data(), finite, infinite);
      if (finite.empty())
      {
        result = utilities::optimized_forall(infinite, super::visit(phi, sigma));
      }
      else
      {
        result = utilities::optimized_forall_no_empty_domain(infinite, quantifier_enumerator1<self>(*this, m_data_enumerator).enumerate_universal_quantification(finite, phi, sigma));
      }
    }
#ifdef MCRL2_ENUMERATE_QUANTIFIERS_BUILDER_DEBUG
    mCRL2log(log::verbose) << "<visit_forall_result>" << tr::pp(result) << std::endl;
#endif
    return result;
  }

  /// \brief Visit exists node
  /// Visit exists node.
  /// \param x A term
  /// \param variables A sequence of variables
  /// \param phi A term
  /// \param sigma A substitution function
  /// \return The result of visiting the node
  pbes_expression visit_exists(const pbes_expression& /* x */, const data::variable_list& variables, const pbes_expression& phi, SubstitutionFunction& sigma)
  {
#ifdef MCRL2_ENUMERATE_QUANTIFIERS_BUILDER_DEBUG
    mCRL2log(log::verbose) << "<visit_exists>" << tr::pp(exists(variables, phi)) << std::endl;
#endif
    pbes_expression result;
    if (m_enumerate_infinite_sorts)
    {
      result = quantifier_enumerator1<self>(*this, m_data_enumerator).enumerate_existential_quantification(variables, phi, sigma);
    }
    else
    {
      data::variable_list finite;
      data::variable_list infinite;
      split_finite_variables(variables, m_data_enumerator.data(), finite, infinite);
      if (finite.empty())
      {
        result = utilities::optimized_exists(infinite, super::visit(phi, sigma));
      }
      else
      {
        result = utilities::optimized_exists_no_empty_domain(infinite, quantifier_enumerator1<self>(*this, m_data_enumerator).enumerate_existential_quantification(finite, phi, sigma));
      }
    }
#ifdef MCRL2_ENUMERATE_QUANTIFIERS_BUILDER_DEBUG
    mCRL2log(log::verbose) << "<visit_exists_result>" << tr::pp(result) << std::endl;
#endif
    return result;
  }

  /// \brief Visit data_expression node
  /// Visit data expression node.
  /// \param x A term
  /// \param d A data term
  /// \param sigma A substitution function
  /// \return The result of visiting the node
  pbes_expression visit_data_expression(const pbes_expression& x, const data::data_expression& d, SubstitutionFunction& sigma)
  {
    if (m_skip_data)
    {
      return x;
    }
    else
    {
      return super::visit_data_expression(x, d, sigma);
    }
  }
};

} // namespace detail

/// \brief An attempt for improving the efficiency.
class custom_enumerate_quantifiers_rewriter
{
  protected:
    /// \brief A data rewriter
    data::rewriter m_rewriter;

    /// \brief A data enumerator
    data::data_enumerator m_enumerator;

    /// \brief If true, quantifier variables of infinite sort are enumerated.
    bool m_enumerate_infinite_sorts;

    /// If true, data expressions are not rewritten.
    bool m_skip_data;

  public:
    /// \brief Constructor
    /// \param r A data rewriter
    /// \param e A data enumerator
    /// \param enumerate_infinite_sorts If true, quantifier variables of infinite sort are enumerated.
    /// \param skip_data If false, data expressions are also rewritten. If true,
    ///        only PBES expressions are rewritten, and the data expressions are not.
    custom_enumerate_quantifiers_rewriter(const data::rewriter& r, const data::data_enumerator& e, bool enumerate_infinite_sorts = true, bool skip_data = false)
      : m_rewriter(r), m_enumerator(e), m_enumerate_infinite_sorts(enumerate_infinite_sorts), m_skip_data(skip_data)
    {}

    /// \brief Rewrites a pbes expression.
    /// \param x A term
    /// \return The rewrite result.
    pbes_expression operator()(const pbes_expression& x) const
    {
      data::mutable_map_substitution<> sigma;
      detail::custom_enumerate_quantifiers_builder<data::mutable_map_substitution<> > R(m_rewriter, m_enumerator, m_enumerate_infinite_sorts, m_skip_data);
      return R(x, sigma);
    }

    /// \brief Rewrites a pbes expression.
    /// \param x A term
    /// \param sigma A substitution function
    /// \return The rewrite result.
    template <typename SubstitutionFunction>
    pbes_expression operator()(const pbes_expression& x, SubstitutionFunction& sigma) const
    {
      detail::custom_enumerate_quantifiers_builder<SubstitutionFunction> R(m_rewriter, m_enumerator, m_enumerate_infinite_sorts, m_skip_data);
      return R(x, sigma);
    }
};

} // namespace pbes_system

} // namespace mcrl2

#endif // MCRL2_PBES_REWRITERS_CUSTOM_ENUMERATE_QUANTIFIERS_REWRITER_H
