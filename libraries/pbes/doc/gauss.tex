
\documentclass{article}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{fullpage}
\usepackage{fullpage}

\setcounter{MaxMatrixCols}{10}
%TCIDATA{OutputFilter=LATEX.DLL}
%TCIDATA{Version=5.50.0.2890}
%TCIDATA{<META NAME="SaveForMode" CONTENT="1">}
%TCIDATA{BibliographyScheme=Manual}
%TCIDATA{Created=Tuesday, January 15, 2008 14:02:49}
%TCIDATA{LastRevised=Tuesday, January 22, 2008 14:43:51}
%TCIDATA{<META NAME="GraphicsSave" CONTENT="32">}
%TCIDATA{<META NAME="DocumentShell" CONTENT="Standard LaTeX\Blank - Standard LaTeX Article">}
%TCIDATA{CSTFile=40 LaTeX article.cst}

\newtheorem{theorem}{Theorem}
\newtheorem{acknowledgement}[theorem]{Acknowledgement}
\newtheorem{algorithm}[theorem]{Algorithm}
\newtheorem{axiom}[theorem]{Axiom}
\newtheorem{case}[theorem]{Case}
\newtheorem{claim}[theorem]{Claim}
\newtheorem{conclusion}[theorem]{Conclusion}
\newtheorem{condition}[theorem]{Condition}
\newtheorem{conjecture}[theorem]{Conjecture}
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{criterion}[theorem]{Criterion}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{example}[theorem]{Example}
\newtheorem{exercise}[theorem]{Exercise}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{notation}[theorem]{Notation}
\newtheorem{problem}[theorem]{Problem}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{solution}[theorem]{Solution}
\newtheorem{summary}[theorem]{Summary}
\newenvironment{proof}[1][Proof]{\noindent\textbf{#1.} }{\ \rule{0.5em}{0.5em}}
\begin{document}


\section{Gau\ss\ Elimination}

A predicate formula $\varphi $ is defined by the following grammar:%
\begin{equation*}
\varphi ::=b|X(e)|\lnot \varphi |\varphi \wedge \varphi |\varphi \vee
\varphi |\varphi \rightarrow \varphi |\forall d:D.\varphi |\exists
d:D.\varphi |\top |\bot
\end{equation*}%
where $b$ is a data term of sort $\mathbb{B}$, $X$ is a predicate variable, $%
d$ is a data variable of sort $D$, $e$ is a data term, $\top $ represents $%
true$, and $\bot $ represents $false$.

\begin{definition}
(Predicate Variable Substitution) Let $\varphi ,\psi $ be predicate formulae
and $X$ a predicate variable. Then we define $\psi \lbrack \varphi /X]$ as
the result of applying the substitution $X:=\varphi $ to the formula $\psi $%
. To make this more precise: suppose $X$ is declared as $X(d:D)$, then any
occurrence $X(\overline{d})$ in $\psi $ is replaced by $\varphi \lbrack d:=%
\overline{d}]$.
\end{definition}

\begin{lemma}
(Substitution) Let $\mathcal{E}$ be an equation system for which $X,Y\notin
bnd(\mathcal{E})$, then:%
\begin{equation*}
(\sigma X(d:D)=\varphi )\mathcal{E}(\sigma ^{\prime }Y(e:E)=\psi )\equiv
(\sigma X(d:D)=\varphi )[\psi /Y]\mathcal{E}(\sigma ^{\prime }Y(e:E)=\psi )
\end{equation*}
\end{lemma}

\begin{definition}
(Approximation) Let $\varphi ,\psi $ be predicate formulae and $X$ a
predicate variable. We inductively define $\psi \lbrack \varphi /X]^{k}$ as
follows:%
\begin{eqnarray*}
&&\psi \lbrack \varphi /X]^{0}\overset{def}{=}\varphi \\
&&\psi \lbrack \varphi /X]^{k+1}\overset{def}{=}\psi \lbrack \varphi /X]^{k}
\end{eqnarray*}
\end{definition}

Thus, $\psi \lbrack \varphi /X]^{k}$ represents the result of recursively
substituting $\varphi $ for $X$ in $\psi $.

\begin{lemma}
(Approximants as Solutions) Let $\varphi $ be a predicate formula and $k\in 
\mathbb{N}$ be a natural number. Then%
\begin{eqnarray*}
(\mu X(d &:&D)=\varphi \lbrack \bot /X]^{k})\Rrightarrow (\mu X(d:D)=\varphi
) \\
(\nu X(d &:&D)=\varphi )\Rrightarrow (\nu X(d:D)=\varphi \lbrack \top
/X]^{k})
\end{eqnarray*}
\end{lemma}

\begin{lemma}
(Stable Approximants as Solutions) Let $\varphi $ be a predicate formula and 
$k\in \mathbb{N}$ be a natural number. Then%
\begin{eqnarray*}
\text{if }\varphi \lbrack \bot /X]^{k} &\longleftrightarrow &\varphi \lbrack
\bot /X]^{k+1}\text{ then }(\mu X(d:D)=\varphi \lbrack \bot /X]^{k})\equiv
(\mu X(d:D)=\varphi ) \\
\text{if }\varphi \lbrack \top /X]^{k} &\longleftrightarrow &\varphi \lbrack
\top /X]^{k+1}\text{ then }(\nu X(d:D)=\varphi \lbrack \top /X]^{k})\equiv
(\nu X(d:D)=\varphi )
\end{eqnarray*}
\end{lemma}

\newpage

\subsection{Gau\ss\ Elimination Algorithm}

Let $\mathcal{E}$ be an equation system of the form%
\begin{equation*}
\mathcal{E=(}\sigma _{1}X_{1}(d_{1}:D_{1})=\varphi _{1})\cdots (\sigma
_{n}X_{n}(d_{n}:D_{n})=\varphi _{n})
\end{equation*}%
Then we define%
\begin{equation*}
\begin{array}{l}
\begin{array}{l}
\text{\textsc{Approximate(}}\sigma ,X,\varphi \text{\textsc{)}} \\ 
j:=0 \\ 
\text{\textbf{if }}\sigma =\nu \text{ \textbf{then} }\psi _{0}:=\top \text{ 
\textbf{else} }\psi _{0}:=\bot  \\ 
\text{\textbf{repeat}} \\ 
\qquad \psi _{j+1}:=\varphi \lbrack \psi _{j}/X] \\ 
\qquad j:=j+1 \\ 
\text{\textbf{until }}(\psi _{j}=\psi _{j+1}) \\ 
\text{\textbf{return }}\psi _{j}%
\end{array}
\\ 
\\ 
\begin{array}{l}
\text{\textsc{Gau\textsc{\ss\ }Elimination(}}\mathcal{E}\text{\textsc{)}} \\ 
i:=n \\ 
\text{\textbf{while} \textbf{not} }i=0 \\ 
\text{\textbf{do}} \\ 
\qquad \varphi _{i}:=\text{\textsc{Approximate(}}\sigma _{i},X_{i},\varphi
_{i}\text{\textsc{)}} \\ 
\qquad \text{\textbf{for }}k=1\text{ \textbf{to }}i-1\text{ \textbf{do }}%
\varphi _{k}:=\varphi _{k}[\varphi _{i}/X_{i}]\text{ \textbf{od}} \\ 
\qquad i:=i-1 \\ 
\text{\textbf{od}} \\ 
\text{\textbf{return }}\mathcal{E}%
\end{array}%
\end{array}%
\end{equation*}

\end{document}
