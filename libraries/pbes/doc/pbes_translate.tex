\pagebreak
\section{pbes\_translate algorithm}

In this section we define the algorithm pbes\_translate that generates a PBES from
a state formula and an LPD. Let $\tuple{D_p, d_0, P}$ be the LPD given by

\[\begin{tightarray}{lrl}
\mathbf{proc}~ P(x{:}D_p) & = &
  \sum_{i \in I}\sum_{y:E_i} c_i(x,y) \rightarrow a_i(f_i(x,y))\at t_i(x,y) \cdot P(g_i(x,y))\\
 & + &\sum_{j \in J}\sum_{y:E_j} c_j(x,y) \rightarrow \delta \at t_j(x,y);
\end{tightarray}\]
%
where $a_i(f_i(x,y))$ is a multiset of actions. Then we define
\[
\mathbf{pbes\_translate}(\sigma X(x_f:D_f := d).~\varphi, \tuple{D_p, d_0, P}) = \mathbf{E}(\varphi),
\]
%
where the function $\mathbf{E}$ is inductively defined using the tables below.
The function $\varphi$ has to be in positive normal form, i.e. it may not contain
any $\neg$ or $\Rightarrow$ symbols. This is done using the function $h$, as
given below.
There is also an untimed variant of the algorithm, which can be obtained by
removing all time references. A formula $\varphi$ not of the form
$\sigma X(x_f:D_f := d).~\varphi$ is first translated into $\nu X().~\varphi$.
We assume that $T: \snnreal$ is a unique fresh time variable that is generated
by the algorithm.

\newpage

%-------------------------------------%
%           function h
%-------------------------------------%
\begin{table}[htb]
{\centering\small
$\begin{tightarray}{lll}

% not <DataExpr>
h (\neg c) & \isdef  &
\neg c \\

% not StateTrue
h (\neg \strue) & \isdef &
\sfalse \\

% not StateFalse
h (\neg \sfalse) & \isdef &
\strue \\

% not StateNot
h (\neg \neg \varphi) & \isdef  & h (\varphi) \\

% not StateAnd
h (\neg (\varphi \wedge \psi)) & \isdef &
h (\neg \varphi) \vee h (\neg \psi) \\

% not StateOr
h (\neg (\varphi \vee \psi)) & \isdef &
h (\neg \varphi) \wedge h (\neg \psi) \\

% not StateImp
h (\neg (\varphi \Rightarrow \psi)) & \isdef &
h (\varphi) \wedge h (\neg \psi) \\

% not StateForall
h (\neg \forall{x {:} D}. \varphi) & \isdef &
\exists{x {:} D}. h(\neg \varphi)   \\

% not StateExists
h (\neg \exists{x {:} D}. \varphi) & \isdef &
\forall{x {:} D}. h(\neg \varphi)   \\

% not StateMust
h (\neg [\alpha] \varphi) & \isdef &
   [\alpha] h(\neg \varphi) \\

% not StateMay
h ( \neg \langle \alpha \rangle \varphi) & \isdef &
   \langle \alpha \rangle h(\neg \varphi) \\

% not StateYaled
h (\neg \nabla) & \isdef &
   \Delta \\

% not StateYaledTimed
h (\neg \nabla(t)) & \isdef &
   \Delta(t) \\

% not StateDelay
h (\neg \Delta) & \isdef &
   \nabla \\

% not StateDelayTimed
h (\neg \Delta(t)) & \isdef &
   \nabla(t) \\

% not StateVar
h (\neg X(d)) & \isdef &
undefined \\

% not StateMu
h (\neg \mu X(x {:}D:=d).~ \varphi)~~~ & \isdef~~~ &
\nu X(x {:}D:=d).~ h(\neg \varphi[X := \neg X])
\footnote{This substitution is only applied to
propositional variables.} \\

% not StateNu
h (\neg \nu X(x {:}D:=d).~ \varphi)~~~ & \isdef~~~ &
\mu X(x {:}D:=d).~ h(\neg \varphi[X := \neg X]) \\

% <DataExpr>
h(c) & \isdef  &
c \\

% StateTrue
h (\strue) & \isdef &
\strue \\

% StateFalse
h (\sfalse) & \isdef &
\sfalse \\

% StateNot
% \\

% StateAnd
h (\varphi \wedge \psi) & \isdef &
h (\varphi) \wedge h (\psi) \\

% StateOr
h (\varphi \vee \psi) & \isdef &
h (\varphi) \vee h (\psi) \\

% StateImp
h (\varphi \Rightarrow \psi) & \isdef &
h (\neg \varphi) \vee h (\psi) \\

% StateForall
h (\forall{x {:} D}. \varphi) & \isdef &
\forall{x {:} D}. h(\varphi)   \\

% StateExists
h (\exists{x {:} D}. \varphi) & \isdef &
\exists{x {:} D}. h(\varphi)   \\

% StateMust
h ([\alpha] \varphi) & \isdef &
   [\alpha] h(\varphi) \\

% StateMay
h ( \langle \alpha \rangle \varphi) & \isdef &
   \langle \alpha \rangle h(\varphi) \\

% StateYaled
h (\nabla) & \isdef &
   \nabla \\

% StateYaledTimed
h (\nabla(t)) & \isdef &
   \nabla(t) \\

% StateDelay
h (\Delta) & \isdef &
   \Delta \\

% StateDelayTimed
h (\Delta(t)) & \isdef &
   \Delta(t) \\

% StateVar
h (X(d)) & \isdef &
   X(d) \\

% StateMu
h (\mu X(x {:}D:=d).~ \varphi)~~~ & \isdef~~~ &
  \mu X(x {:}D:=d).~ h(\varphi)
\\

% StateNu
h (\nu X(x {:}D:=d).~ \varphi)~~~ & \isdef~~~ &
  \nu X(x {:}D:=d).~ h(\varphi)
\end{tightarray}
$}
\caption{normalization of a state formula}
\end{table}

%-------------------------------------%
%           function E
%-------------------------------------%
\begin{table}[htb]
{\centering\small\[\begin{tightarray}{lll}

% <DataExpr>
{\mathbf{E}} (c) & \isdef  & \epsilon \\

% StateTrue
{\mathbf{E}} (\strue) & \isdef  & \epsilon \\

% StateFalse
{\mathbf{E}} (\sfalse) & \isdef  & \epsilon \\

% StateNot
{\mathbf{E}} (\neg \varphi) & \isdef &
   {\mathbf{E}} (\varphi) \\

% StateAnd
{\mathbf{E}} (\varphi \wedge \psi) & \isdef &
   {\mathbf{E}} (\varphi)
   {\mathbf{E}} (\psi) \\

% StateOr
{\mathbf{E}} (\varphi \vee \psi) & \isdef &
   {\mathbf{E}} (\varphi)
    {\mathbf{E}} (\psi) \\

% StateImp
{\mathbf{E}} (\varphi \Rightarrow \psi) & \isdef &
   {\mathbf{E}} (\varphi)
   {\mathbf{E}} (\psi) \\

% StateForall
{\mathbf{E}} (\forall{x {:} D}. \varphi) & \isdef &
   {\mathbf{E}}(\varphi) \\

% StateExists
{\mathbf{E}} (\exists{x {:} D}. \varphi) & \isdef &
   {\mathbf{E}}(\varphi) \\

% StateMust
{\mathbf{E}} ([ \alpha ] \varphi) & \isdef &
   {\mathbf{E}}(\varphi) \\

% StateMay
{\mathbf{E}} ( \langle \alpha \rangle \varphi) & \isdef &
   {\mathbf{E}}(\varphi) \\

% StateYaled
{\mathbf{E}} (\nabla) & \isdef &
   \epsilon \\

% StateYaledTimed
{\mathbf{E}} (\nabla(t)) & \isdef &
   \epsilon \\

% StateDelay
{\mathbf{E}} (\Delta) & \isdef &
   \epsilon \\

% StateDelayTimed
{\mathbf{E}} (\Delta(t)) & \isdef &
   \epsilon \\

% StateVar
{\mathbf{E}} (X(d)) & \isdef & \epsilon \\

% StateMu / StateNu
{\mathbf{E}} (\sigma X(x_f {:}D_f:=d).~ \varphi)~~~ & \isdef~~~ &
        (\sigma \tilde X(T: \snnreal, x_f {:}D_f, x_p {:} D_p,
            \mathbf{Par}_{X,[]}(\varphi_0)) =
           {\mathbf{RHS}} (\varphi)~ )~ {\mathbf{E}} (\varphi) \\

\end{tightarray}\]}
\end{table}

%-------------------------------------%
%           function RHS
%-------------------------------------%
\begin{table}[htb]
{\centering\small\[\begin{tightarray}{lll}

{\mathbf{RHS}} (c) & \isdef  &  c \\

%{\mathbf{RHS}} (\strue) & \isdef  &  \strue \\

%{\mathbf{RHS}} (\sfalse) & \isdef  &  \sfalse \\

{\mathbf{RHS}} (\neg \varphi) & \isdef &
   \neg~ \mathbf{RHS}(\varphi) \\

%%% AND/OR/IMP
{\mathbf{RHS}} (\varphi \wedge \psi) & \isdef &
   {\mathbf{RHS}} (\varphi) \wedge
    {\mathbf{RHS}} (\psi) \\

{\mathbf{RHS}} (\varphi \vee \psi) &\isdef &
   {\mathbf{RHS}} (\varphi) \vee
    {\mathbf{RHS}} (\psi)\\

{\mathbf{RHS}} (\varphi \Rightarrow \psi) &\isdef &
   {\mathbf{RHS}} (\varphi) \Rightarrow
    {\mathbf{RHS}} (\psi)\\

%%% QUANTIFIERS
{\mathbf{RHS}}(\forall{x {:} D}. \varphi) & \isdef &
   \forall{x {:} D}. {\mathbf{RHS}} (\varphi) \\

{\mathbf{RHS}}(\exists{x {:} D}. \varphi) & \isdef &
   \exists{x {:} D}. {\mathbf{RHS}} (\varphi) \\

%%% BOX
{\mathbf{RHS}} ([ \alpha ] \varphi) & \isdef &
   \bigwedge_{i {\in} I} \forall_{y {:} E_i}((
        \mathbf{Sat}_\top(a_i(f_i(x_p,y)) \at t_i(x_p,y), \alpha)\ \wedge \\
& & \phantom{\bigwedge_{i {\in} I} \forall_{y {:} E_i}(}
         c_i(x_p,y) \wedge t_i(x_p,y) > T\ ) \Rightarrow \\
& & \phantom{\bigwedge_{i {\in} I} \forall_{y {:} E_i}(}
        {\mathbf{RHS}} (\varphi)[T := t_i(x_p,y)][x_p := g_i(x_p,y)]) \\

%%% DIAMOND
{\mathbf{RHS}}(\langle \alpha \rangle \varphi) &\isdef&
   \bigvee_{i {\in} I} \exists_{y {:} E_i}(
        \mathbf{Sat}_\top(a_i(f_i(x_p,y)) \at t_i(x_p,y), \alpha)\ \wedge \\
& & \phantom{\bigvee_{i {\in} I} \exists_{y {:} E_i}(}
         c_i(x_p,y) \wedge t_i(x_p,y) > T\ \wedge \\
& & \phantom{\bigvee_{i {\in} I} \exists_{y {:} E_i}(}
        {\mathbf{RHS}} (\varphi)[T := t_i(x_p,y)] [x_p := g_i(x_p,y)]) \\

%%% PROPOSITIONAL VARIABLES
{\mathbf{RHS}} (X(d)) & \isdef & \tilde{X}(T,d,x_p,
                                 \mathbf{Par}_{X,[]}(\varphi_0)) \\

%%% FIXPOINTS
{\mathbf{RHS}}(\sigma X(x_f \ap D_f := d) .~ \varphi) &
     \isdef~~~ &
     \tilde X(T, d,x_p, \mathbf{Par}_{X,[]}(\varphi_0)) \\

%%% DELAY
{\mathbf{RHS}}(\nabla(t)) & \isdef &
   \bigwedge_{i {\in} I \cup J} \forall_{y {:} E_i}
        (\neg c_i(x_p,y) \vee t > t_k(x_p,y)) \wedge t > T)\\

{\mathbf{RHS}}(\Delta(t)) & \isdef &
   \bigvee_{i {\in} I \cup J} \exists_{y {:} E_i}
         (c_i(x_p,y) \wedge t \le t_k(x_p,y)) \vee t \le T

\end{tightarray}\]}
\end{table}

\pagebreak

Let $a=\{a_{1},\ldots ,a_{n}\}$ and $b=\{b_{1},\ldots ,b_{n}\}$ be two multi actions.
Let $A$ be the set of all permutations $[i_{1},\ldots ,i_{n}]$ of $%
[1,\ldots n]$ such that $name(a_{k})=name(b_{i_{k}})$ for $k=1\ldots n$.
Then we define the functions $\mathbf{Sat}_\top$ and $\mathbf{Sat}_\bot$ as
follows:

%-------------------------------------%
%           function Sat_top/bot
%-------------------------------------%
\begin{table}[htb]
{\small
$
\begin{tightarray}{lll}
\mathbf{Sat}_\top(a \at t, b)
& \isdef & \left\{
\begin{array}{cc}
  \dbigvee\limits_{\lbrack i_{1},\ldots ,i_{n}]\in
  A}\dbigwedge\limits_{k=1\ldots n}(a_{k}=b_{i_{k}}) & \text{if }A\neq
  \emptyset  \\
  false & \text{otherwise}%
\end{array}%
\right.  \\
\mathbf{Sat}_\top(a \at t, c)
& \isdef & c\\
\mathbf{Sat}_\top(a \at t, \alpha \at u)
& \isdef & \mathbf{Sat}_\top(a \at t, \alpha)
  \wedge t \approx u\\
\mathbf{Sat}_\top(a \at t, \neg \alpha)
& \isdef & \neg \mathbf{Sat}_\top(a \at t, \alpha)\\
\mathbf{Sat}_\top(a \at t, \alpha \wedge \beta)
& \isdef & \mathbf{Sat}_\top(a \at t, \alpha) \wedge \mathbf{Sat}_\top(a \at t, \beta)\\
\mathbf{Sat}_\top(a \at t, \alpha \vee \beta)
& \isdef & \mathbf{Sat}_\top(a \at t, \alpha) \vee \mathbf{Sat}_\top(a \at t, \beta)\\
\mathbf{Sat}_\top(a \at t, \alpha \Rightarrow \beta)
& \isdef & \mathbf{Sat}_\top(a \at t, \alpha) \Rightarrow \mathbf{Sat}_\top(a \at t, \beta)\\
\mathbf{Sat}_\top(a \at t, \forall{x {:} D}. \alpha)
& \isdef & \forall{y {:} D}. (\mathbf{Sat}_\top(a \at t, \alpha[x := y])\\
\mathbf{Sat}_\top(a \at t, \exists{x {:} D}. \alpha)
& \isdef & \exists{y {:} D}. (\mathbf{Sat}_\top(a \at t, \alpha[x := y])\\
% \\
% \mathbf{Sat}_\bot(a \at t, b)
% & \isdef & \left\{%
% \begin{array}{cc}
% \dbigwedge\limits_{\lbrack i_{1},\ldots ,i_{n}]\in
% A}\dbigvee\limits_{k=1\ldots n}(a_{k}\neq b_{i_{k}}) & \text{if }A\neq
% \emptyset  \\
% true & \text{otherwise}%
% \end{array}%
% \right.\\
% \mathbf{Sat}_\bot(a \at t, c)
% & \isdef & \neg c\\
% \mathbf{Sat}_\bot(a \at t, \alpha \at u)
% & \isdef & \mathbf{Sat}_\bot(a \at t, \alpha) \vee t \not\approx u\\
% \mathbf{Sat}_\bot(a \at t, \neg \alpha)
% & \isdef & \mathbf{Sat}_\top(a \at t, \alpha)\\
% \mathbf{Sat}_\bot(a \at t, \alpha \wedge \beta)
% & \isdef & \mathbf{Sat}_\bot(a \at t, \alpha) \vee \mathbf{Sat}_\bot(a \at t, \beta)\\
% \mathbf{Sat}_\bot(a \at t, \alpha \vee \beta)
% & \isdef & \mathbf{Sat}_\bot(a \at t, \alpha) \wedge \mathbf{Sat}_\bot(a \at t, \beta)\\
% \mathbf{Sat}_\bot(a \at t, \forall{x {:} D}. \alpha)
% & \isdef & \exists{y {:} D}. \mathbf{Sat}_\bot(a \at t, \alpha[x := y])\\
% \mathbf{Sat}_\bot(a \at t, \exists{x {:} D}. \alpha)
% & \isdef & \forall{y {:} D}. \mathbf{Sat}_\bot(a \at t, \alpha[x := y])\\
\end{tightarray}
$
}
\end{table}

%-------------------------------------%
%           function Par
%-------------------------------------%
\begin{table}[htb]
{\small $
\begin{tightarray}{lll}
\mathbf{Par}_{X,l}(c)
& \isdef & [] \\
%\mathbf{Par}_{X,l}(\strue)
%& \isdef & []\\
%\mathbf{Par}_{X,l}(\sfalse)
%& \isdef & []\\
\mathbf{Par}_{X,l}(\neg \varphi)
& \isdef & \mathbf{Par}_{X,l}(\varphi)\\
\mathbf{Par}_{X,l}(\varphi \wedge \psi)
& \isdef & \mathbf{Par}_{X,l}(\varphi) \concat \mathbf{Par}_{X,l}(\psi)\\
\mathbf{Par}_{X,l}(\varphi \vee \psi)
& \isdef & \mathbf{Par}_{X,l}(\varphi) \concat \mathbf{Par}_{X,l}(\psi) \\
\mathbf{Par}_{X,l}(\varphi \Rightarrow \psi)
& \isdef & \mathbf{Par}_{X,l}(\varphi) \concat \mathbf{Par}_{X,l}(\psi) \\
\mathbf{Par}_{X,l}([\alpha]\varphi)
& \isdef & \mathbf{Par}_{X,l}(\varphi) \\
\mathbf{Par}_{X,l}(\langle \alpha \rangle \varphi)
& \isdef & \mathbf{Par}_{X,l}(\varphi)\\
\mathbf{Par}_{X,l}(\forall{x \ap D}. \varphi)
& \isdef & \mathbf{Par}_{X,l \concat [x \ap D]}(\varphi) \\
\mathbf{Par}_{X,l}(\exists{x \ap D}. \varphi)
& \isdef & \mathbf{Par}_{X,l \concat [x \ap D]}(\varphi) \\
\mathbf{Par}_{X,l}(Y(d_f))
& \isdef & [] \\
\mathbf{Par}_{X,l}(\sigma Y(x_f \ap D_f:= d). \varphi)
& \isdef & \left\{%
  \begin{tightarray}{l@{\quad}L}
    l                                            & if $Y =    X$\\[0ex]
    %appending [0ex] is a LaTeX hack to make sure the beginning of the next is not parsed as an optional argument
    \mathbf{Par}_{X,l \concat [x_f \ap D_f]}(\varphi) & if $Y \neq X$\\
  \end{tightarray}\right.\\
\mathbf{Par}_{X,l}(\nabla(t))
& \isdef & [] \\
\mathbf{Par}_{X,l}(\Delta(t))
& \isdef & [] \\
\end{tightarray}
$}
\end{table}
