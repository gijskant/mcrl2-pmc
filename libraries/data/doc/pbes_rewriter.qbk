[section: PBES rewriters]

There are several rewriters available that operate on PBES expressions. The class
=simplifying_rewriter= is a rewriter that applies a few straightforward rules to
simplify expressions, like [^x && true -> x]. Full details about that can be found in the
document [@http://www.mcrl2.org/wiki/images/6/6c/Pbes_implementation_notes.pdf PBES Implementation Notes].
An example of applying this rewriter is given below. The interface of PBES rewriters is
exactly the same as the one for data expression. They must also satisfy the requirements of the
Rewriter Concept.

    data::rewriter datar = data::default_data_rewriter();
    simplifying_rewriter<pbes_expression, data::rewriter> r(datar);

    std::string var_decl =
      "datavar         \n"
      "                \n"
      "predvar         \n"
      "  X(p: Pos);    \n"
      ;

    pbes_expression d1 = parse_pbes_expression("X(1) || (false || X(1))", var_decl);
    pbes_expression d2 = parse_pbes_expression("X(1)", var_decl);
    assert(r(d1) == r(d2));

Another PBES rewriter is the =enumerate_quantifiers_rewriter= that attempts to
eliminate quantifier expressions using an enumerator. This is illustrated in the
following example.

    data::data_specification data_spec = default_data_specification();
    data::rewriter datar(data_spec);
    data::number_postfix_generator generator("UNIQUE_PREFIX");
    data::data_enumerator<data::rewriter, data::number_postfix_generator> datae(data_spec, datar, generator);
    enumerate_quantifiers_rewriter<pbes_expression, data::rewriter, data::data_enumerator<> > r(datar, datae);

    pbes_expression d1 = parse_pbes_expression("exists m:Nat.val(m > 3)");
    pbes_expression d2 = parse_pbes_expression("true");
    assert(r(d1) == r(d2));

Although the type =Nat= is infinite, the =enumerate_quantifiers_rewriter= is able to
successfully eliminate the quantification [^exists m:Nat.val(m > 3)].

[important Currently the =enumerate_quantifiers_rewriter= rewriter is not guaranteed to
terminate if the enumerator produces an infinite number of terms for a quantifier
expression.]

Note that these PBES rewriters have a pbes expression as their first template argument.
For the =simplifying_rewriter= the type =pbes_expression= is the most likely candidate.
For the =enumerate_quantifiers_rewriter= the type =pbes_expression_with_variables= is
more appropiate. This is because the data enumerator that is supplied by the mCRL2 Library
expects data expressions that maintain their own set of free variables.

[note In the example above the =enumerate_quantifiers_rewriter= is instantiated with
=pbes_expression=. This is possible because a specialization for =pbes_expression= is
available that internally computes with the term type =pbes_expression_with_variables=.]

In general the term type for PBES rewriters must supply a specialization of the
=term_traits= class, containing all of its properties and operations.

[note Constructing an =enumerate_quantifiers_rewriter= is currently quite cumbersome.
Constructors with appropriate default values need to be added to alleviate this.
]

PBES rewriters also support substitution functions, which is illustrated in the following
example.

    data::rewriter datar = data::default_data_rewriter();
    pbes_system::simplifying_rewriter<pbes_system::pbes_expression, data::rewriter> r(datar);

    data::rewriter_map<atermpp::map<data::data_variable, pbes_system::pbes_expression> > sigma;
    sigma[data::parse_data_expression("m", "m: Pos;")] = r(data::parse_data_expression("3"));
    sigma[data::parse_data_expression("n", "n: Pos;")] = r(data::parse_data_expression("4"));

    std::string var_decl =
      "datavar         \n"
      "  m, n:  Pos;   \n"
      "                \n"
      "predvar         \n"
      "  X: Pos;       \n"
      ;
    pbes_system::pbes_expression d1 = pbes_system::parse_pbes_expression("X(m+n)", var_decl);
    pbes_system::pbes_expression d2 = pbes_system::parse_pbes_expression("X(7)", var_decl);
    assert(r(d1, sigma) == r(d2));

[note The =enumerate_quantifiers_rewriter= rewriters only support substitution
functions with a map interface (as provided by =data::rewriter_map=).
]

[endsect] [/ Data rewriters]
