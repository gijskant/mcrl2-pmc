[section: Sort aliases and sort normalisation]

Sort aliases are used to give an alternative name to a sort or a sort
expression. Typical examples are (expressed in MCRL2):

    sort Time=Nat;
         L=List(List(Bool));
         Tree=struct leaf(Nat) | node(Tree,Tree);
         F=Nat->List(Nat);

Sort aliases are used to give alternative names or shorthands for existing
sorts. Moreover, they allow to define recursive structured sorts. Note that
at the left of a sort alias there is a `basic_sort`, and at the right there
is a `sort_expression`.

An alias is declared as follows:

    #include "mcrl2/data/alias.h"
    #include "mcrl2/data/container_sort.h"

    using namespace mcrl2::data;

    void alias_demo()
    {
      basic_sort b("sort_id");
      container_sort c(bag,sort_nat::sort_nat());
      
      alias a(b,c);

      std::cout << "Alias name: " << a.name() << " Alias rhs: " << pp(a.reference()) << "\n";
    }

An important consequence of the use of aliases is that different sort
expressions can denote the same sort. In the example above, Time and
Nat denote the same sort. So, the variables x:Time and x:Nat are the
same object. It is time consuming to continuously calculate whether sorts are 
the same, which is undesirable if it comes to verification. Therefore, we
require that all sorts in expressions that are equal modulo sort aliases
are represented by a unique sort expression. This process is called sort
normalisation. Note that sort normalisation is dependent on a particular
specification; the sorts in one expression can be normalised differently
for two different data specifications.  

More concretely, for a sort alias

    sort A=B;

sort A and B are equal. Sort normalisation will rewrite each sort B to A, except
if B is a Bool, Pos, Nat, Int or Real.  
In case there are more aliases referring to the same sort, as in the
example below there are more options for the unique sort.

    sort A1=List(B);
         A2=List(B);

In this case either A1, or A2 is chosen as the representation for List(B).

Sort normalisation takes place automatically inside a data specification.
Functions, sorts, equations, etc. that are added using for instance
add_equation are automatically normalised. Aliases that
are added are also automatically applied to all elements in the data type.
If the elements of a data type are requested, e.g. the sorts, constructors,
mappings and equations of a data type, then these are provided with 
normalised sorts. The functions user_defined_aliases, user_defined_sorts, etc.
are provided to extract the aliases, sorts, mappings, constructors and equations
in exactly the form they were added to the specification using the add_.... functions.

However, objects outside the data specification are not automatically normalised.
These must be normalized explicitly. Normalisation functions, normalise_sort, exist for all types
that derive from terms, such as data_expressions, assignments, sort_expressions, data_equations, etc.,
as well as for lists of these types.

    #include mcrl2/data/data_specification.h
    #include "mcrl2/data/alias.h"
    #include "mcrl2/data/function_symbol.h"

    using namespace mcrl2::data;

    void normalise_sort_demo()
    {
      data_specification spec;
      const basic_sort a("A");
      const basic_sort b("B");
      spec.add_alias(alias(a,b));
   
      const function_symbol f("f",b));

      // An example of normalising a function symbol explicitly. 
      std::cout << "Not normalised: " << pp(f) << " has sort " << pp(f.sort()) << "\n";
      const function_symbol normalised_f=spec.normalise(f);
      std::cout << "Normalised: " << pp(normalised_f) << " has sort " << pp(normalised_f.sort()) << "\n";
   
      spec.add_mapping(function_symbol);

      // Get the mapping and the sorts, which are normalised. So, f:A is replaced by f:B.
      mappings_const_range m=mappings();
      for(function_symbol::const_iterator i=m.begin(); i!=m.end(); ++i)
      { std::cout << "Function symbol " << pp(*i) << " has sort " << pp(i->sort()) << "\n";
      }
    }

Given a particular sort, it is sometimes useful to find the sort it represents. E.g.
suppose that sort F is defined by F=A->B. Then from sort F alone it cannot be seen
that F is actually a function sort. The function unalias yields the structure of an 
alias. So, in this particular case data_spec.unalias(F) yields A->B. As aliases may be
recursive, as in sort E=struct nil | insert(Nat,E), unalias will only unfold an alias
until it cannot be unfolded further, or until a type with a type constructing operator
occurs. 

[endsect] [/ Sort aliases and sort normalisation]
