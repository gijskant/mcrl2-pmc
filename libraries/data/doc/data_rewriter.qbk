[section: Data rewriters]

A data rewriter is a function that rewrites data expressions using a number of rewrite rules.
In the mCRL2 toolset a class =data::rewriter= is available that is initialized using a
data specification. The equations of the data specification are used as rewrite rules from
left to right. An example is given below. The function `default_data_rewriter` returns a
rewriter containing rewrite rules for all predefined data types.

    // rewrite two data expressions, and check if they are the same
    rewriter r = default_data_rewriter();
    data_expression d1 = parse_data_expression("2+7");
    data_expression d2 = parse_data_expression("4+5");
    assert(d1 != d2);
    assert(r(d1) == r(d2));

[tip
Rewriters can be used to determine equivalence between data expressions. In general this
problem is undecidable. Only if [^r(d1) == r(d2)] one can conclude that the expressions =d1=
and =d2= are equivalent, otherwise the answer is unknown.
]

For efficiency reasons a rewriter can be invoked with an optional substitution function
__sigma as a second argument, where __sigma maps data variables to data expressions. The
function __sigma must satisfy the property

    r(d,__sigma) == r(__sigma(d)).

Note that in general the
computation of [^r(d,__sigma)] can be done much more efficiently than the computation of
[^r(__sigma(d))]. In the mCRL2 toolset substition functions are used that take constant time.

[important
The class `data::rewriter` does not truly support substitution functions.
Instead one can pass a sequence of substitutions as a second argument. Limitations of the
=Rewriter= class that is used for the implementation of =rewriter= prevent to make __sigma
a generic substitution function. Below an example of the current interface is given:
]

  rewriter r = default_data_rewriter();

  // Create a substitution sequence sigma with two substitutions: [m:=3, n:=4]
  std::string var_decl = "datavar m, n: Pos;\n";
  atermpp::vector<rewriter::substitution> sigma;
  sigma.push_back(rewriter::substitution(r, parse_data_expression("m", var_decl), parse_data_expression("3")));
  sigma.push_back(rewriter::substitution(r, parse_data_expression("n", var_decl), parse_data_expression("4")));

  // Rewrite two data expressions, and check if they are the same
  data::data_expression d1 = parse_data_expression("m+n", var_decl);
  data::data_expression d2 = parse_data_expression("7");
  assert(r(d1, sigma) == r(d2));

[/
  struct substitution_function
  {
    const std::map<data::data_variable, data::data_expression>& s; 

    substitution_function(const std::map<data::data_variable, data::data_expression>& s_)
      : s(s_)
    {}
  
    data::data_expression operator()(data::data_variable v) const
    {
      std::map<data::data_variable, data::data_expression>::const_iterator i = s.find(v);
      return i == s.end() ? v : *i;
    }
  };

  // precompute substitutions
  std::string var_decl = "var m, n: Pos;\n";
  std::map<data::data_variable, data::data_expression> m;
  m[parse_data_expression("m", var_decl)] = parse_data_expression("3"));
  m[parse_data_expression("n", var_decl)] = parse_data_expression("4"));
  substitution_function sigma(m);

  data::data_expression d1 = r(parse_data_expression("m+n"), sigma);
  data::data_expression d2 = r(parse_data_expression("7"));
  assert(d1 == d2);
]

[caution
The current implementation of rewriting with substitutions to data variables is
inefficient, since a lot of unnecessary copying takes place. The interface of the
underlying =Rewriter= class needs to be improved to get rid of these inefficiencies.
]

[endsect] [/ Data rewriters]
