[section: Data specifications]

Data specifications contains the declaration of data types.
It contains sorts, sort aliases, constructors, mappings and conditional equations.

A specification can straightforwardly be constructed by declaring
the required objects and adding them to a specification. The elements
that are added to the specification are not checked.

   #include "mcrl2/data/data_specification.h"
   #include "mcrl2/data/basic_sort.h"
   #include "mcrl2/data/function_symbol.h"
   #include "mcrl2/data/variable.h"
   #include "mcrl2/data/data_equation.h"

   using namespace mcrl2::data;
   
   data_specification spec;
   basic_sort D("D");                                          // sort D
   spec.add_sort(D);
   function_symbol m("m",D);                                   // map  m:D;
   function_symbol c1("c1",D);                                 // cons c1:D;
   function_symbol c2("c2",function_sort(D,D));                //      c2:D->D;
   spec.add_mapping(m);
   spec.add_constructor(c1);
   spec.add_constructor(c2);
   variable x("x", D);                                         // var  x:D;
   data_application e1(c2,x);
   data_equation e(make_vector(x), sort_bool::true_(), e1, m); // eqn  true -> c1(x)=m;
   spec.add_equation(e);
   basic_sort E("E");                                          // sort E=D; (add a sort alias)
   spec.add_alias(E,D);

For any specification it is possible to retrieve the elements that have been added to the
specification as follows:

   sorts_const_range s=spec.user_defined_sorts();
   constructors_const_range c=spec.user_defined_constructors();
   mappings_const_range m=spec.user_defined_mappings();
   equations_const_range e=spec.user_defined_equations();
   ltr_aliases_mapping a=spec.user_defined_aliases();

If sorts are added to a data specification, automatically certain functions,
mappings and in some cases even derived sorts are added to the specification. 
For every sort D, there functions if then else (if:Bool#D#D->D), equality (==:D#D->Bool), 
inequality (!=:D#D->Bool) and inequalities (<,<=,>=,>:D#D->Bool) are added.
For structured sorts (e.g. sort Tree=struct leaf(Nat) | node(Nat,Nat)) the constructors,
projection functions and recognizers are added to the specification. For container sorts
(List(D), Set(D) and Bag(D) for arbitrary sort D) all standard functions for these 
sorts are also added automatically to the specification. The same holds for standard
sorts Bool (booleans),
Pos (Positive numbers), Nat (Natural numbers), Int (Integers) and Real (Real numbers).

Standards sorts cannot explicitly
be added to a specification. In order to indicate that certain sorts must be present
in a data specification, these must be added explicitly to the context sorts.
The sort Bool is always present in a specification. Sorts that occur
in other sorts, constructors and mappings are automatically defined. 
For instance, if the sort Real and its operations should be made available in a specification, it
is sufficient to add Real to the context sorts as follows:

    add_context_sort(sort_real::real());

The function context_sorts gives a list of sorts added to the context.

In order to retrieve all sorts, constructors, mappings or equations in 
a specification (including those that are automatically generated), 
there are functions listed below. As generally these functions are of
interest, instead of their counterparts which only define the user_defined
elements, they have the shorter and more natural names.

   sorts_const_range s=spec.sorts();
   constructors_const_range c=spec.constructors();
   mappings_const_range m=spec.mappings();
   equations_const_range e=spec.equations();
   ltr_aliases_mapping a=spec.aliases();

When adding sort aliases to a specification, the names of sorts are not
unique anymore. When declaring in mCRL2

   sort Time=Nat;
        D=list(Nat);
        E=struct f(E)|g;
  
the sorts Time and Nat, as well as D and list(Nat) and even
E and struct f(E)|g are pairwise equal. In a specification it is not very
inefficient to have different names for equal sorts. Therefore the sorts
in a specification are made unique. The algorithm that is used maps every
structured and container sort for which an alias is introduced to the
sort alias at the left hand side. Every sort alias between basic sorts
is mapped to the right hand side. In the example above every occurrence
of Time is replaced by Nat, and occurrences of list(Nat) and struct f(E)|g
are replaced by D and E respectively.

The method sort_alias_map() delivers a mapping from sorts to sorts giving
for each sort the unique name. Using the function template <class T> T normalise_sorts(T t)
the sorts in each object t can be renamed to their unique representation.
If this is not done, objects can be equal except for their types, and this
will not be recognized. This is particularly problematic when using the
rewriter. Eg. in the following process specification

  sort Time=Nat;
  map too_late:Time->Bool;
  var t:Time;
  eqn too_late(t) = t>10;
  proc P(u:Time)=too_late(u) -> a.delta;
  init P(9);

the data specification will normalise the equation too_late(t)= t>10 to
such that t has sort Nat as all occurrences of the sort Time are replaced
by Nat. When this is not done in process P, the parameter u still has sort
Time and too_late(u) will not be rewritten as the sorts do not match.
Therefore, it is necessary to apply normalise_sorts to any object used
in the context of a specification. If sort aliases are added to a
data specification, all sorts in the context of this specification
must be renormalised.

There are a few utility functions that help to determine the nature
of sorts. The function bool is_certainly_finite(const sort_expression) indicates
that a sort has a finite number of elements. This is in general an undecidable
property, but in certain cases it can be determined that there are at most
a finite number of elements in a sort. 

The function bool is_constructor_sort(const sort_expression s) indicates
whether there is a constructor with target sort s. If so, the sort is
called a constructor sort.

[endsect] [/Data specifications]
