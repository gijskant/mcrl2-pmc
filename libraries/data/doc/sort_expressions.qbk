[section: Sort expressions]

Except for the untyped identifiers, all expressions in the Data Library
are typed. There are many different kinds of sorts in the mCRL2 language, all
of which can be represented in the data library.

[table Sort expressions
    [ [Type]                        [Meaning]]
    [ [ `basic_sort` ]              [ basic sort    ]]
    [ [ `function_sort` ]           [ function sort ]]
    [ [ `structured_sort` ]         [ structured sort ]]
    [ [ `container_sort` ]          [ container sort ]]
    [ [ `multiple_possible_sorts` ] [ expression matching any of multiple sorts ]]
    [ [ `unknown_sort` ]            [ unknown sort expression ] ]
]

[warning =multiple_possible_sorts= and =unknown_sort= should not be used
after type checking]

These sort expressions correspond to the grammar

     S ::= Sb | Sc | S x ... x S -> S | Sstruct,

where =Sb= is a given set of basic sorts, always including the booleans
(sort =Bool=). S x ... x S -> S denotes the function sorts, where -> is right
associative. =Sc= is the set of container sorts, and Sstruct is the set of
structured sorts.

The set of container sorts =Sc= is defined as follows.

     Sc ::= List(S) | Set(S) | FSet(S) | Bag(S) | FBag(S)
     
Where =FSet(S)= and =FBag(S)= represent finite sets and finite bags
respectively.

The syntax of structured sorts Sstruct is defined as follows
(where p is a string):

     Sstruct ::= p(proj*)?p
     
in which proj has the following syntax:
   
     proj ::= S | p:S
     
In general, structured sorts have the following form (with =n= a positive number,
=ki= a natural number with =1 <= i <= n=):
 
     struct c1(pr1,1:S1,1, ..., pr1,k1:S1,k1)?is_c1 |
            c2(pr2,1:S2,1, ..., pr2,k2:S2,k2)?is_c2 |
            ...
            cn(prn,1:Sn,1, ..., prn,kn:Sn,kn)?is_cn;
 
We refer to =ci= as the constructors of the structured sort. =Si,j= are the
sorts of the arguments of the constructors. =pri,j= are names for optional
projection functions, retrieving the corresponding argument for a constructor.
=is_ci= are the names of optional recognizer functions, returning a boolean
value.

As an example of some of the introduced concepts, consider the following code
snippet that constructs a structured sort

  struct c1(p0:S0, S1)?is_c1 |
         c2(p0:S0);
         
The construction of this structured sort is as follows, assuming that also all
of the subexpressions still need to be defined:
         
  basic_sort s0("S0");                               /* Name for the sort S0 */
  basic_sort s1("S1");                               /* Name for the sort S1 */
  structured_sort_constructor_argument p0(s0, "p0"); /* Constructor argument p0: S0 */
  structured_sort_constructor_argument p1(s1);       /* Constructor argument S1 */

  structured_sort_constructor_argument_vector a1;    /* p0: S0, S1 */
  a1.push_back(p0);
  a1.push_back(p1);
  structured_sort_constructor_argument_vector a2;    /* p0 */
  a2.push_back(p0);
  
  structured_sort_constructor c1("c1", a1, "is_c1"); /* c1(p0:S0, S1)?is_c1 */
  structured_sort_constructor c2("c2", a2);          /* c2(p0:S0) */
  
  structured_sort_constructor_vector cs;             /* c1(p0:S0, S1)?is_c1 | c2(p0:S0) */
  cs.push_back(c1);
  cs.push_back(c2);

  structured_sort s(cs);                             /* struct c1(p0:S0, S1)?is_c1 | c2(p0:S0) */

[endsect] [/ Sort expressions]
