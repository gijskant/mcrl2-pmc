\documentclass{article}
\usepackage{a4wide}
\usepackage{latexsym}
\usepackage{times}
%\usepackage{here}
\usepackage{theorem}
\usepackage{url}
\usepackage{pstricks,pst-node,pst-grad,pst-plot,pst-coil}
\usepackage[english]{babel}
\usepackage[final]{graphics}
\usepackage{amsmath,amssymb}
\usepackage{amsfonts}
\usepackage{array}
\usepackage{calc}
\usepackage{xspace}
\usepackage{color}
\usepackage{epsfig}
\usepackage{subfigure}
\usepackage{float}
\usepackage{stmaryrd}
\pagestyle{plain}

\newcommand{\Bool}{{\mathbb B}}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Nat}{\mathbb{N}}
\newcommand{\Pos}{\mathbb{N^{+}}}
\newcommand{\Int}{\mathbb{Z}}

\newcolumntype{L}{>{$}l<{$}}%stopzone%stopzone%stopzone
\newcolumntype{C}{>{$}c<{$}}%stopzone%stopzone%stopzone
\newcolumntype{R}{>{$}r<{$}}%stopzone%stopzone%stopzone

\newenvironment{mcrl2}%
{\begin{trivlist}
\item\begin{tabular}{@{}>{\bf}p{2.3em}L@{\ }L@{\ }L@{\ }L@{\ }L@{\ }L@{\ }L@{\ }L}}%
{\end{tabular}\end{trivlist}}

\title{An algorithm to find a representant for sorts in the context of sort aliases and
recursive sorts}
\author{Jan Friso Groote}
\date{May 4, 2010}
\begin{document}
\maketitle
%\section{Type equivalence}
\noindent%
In mCRL2 it is possible to define sort aliases, which have the form
$A=B$. This means that sort $A$ and sort $B$ are considered the same,
and are completely exchangeable. 

Typical examples of sort aliases are
\begin{mcrl2}
sort&{\it Time}=\Nat;\\
    &F=C\rightarrow D;\\
    &L=List(C);\\
    &{\it Complex}={\it Bag}(A{\rightarrow}{\it Set}(B)); 
\end{mcrl2}
It is also possible to define
structured sorts that can be recursive (contrary to function sorts, lists, sets, 
and bags above, which cannot be recursive). 

A structured sort has the shape:
\begin{mcrl2}
sort & A={\bf struct}
    &c_{1}({\it pr}_{1,1}: A_{1,1}, & \ldots & , {\it pr}_{1,k_{1}}: A_{1,k_{1}})
      ?{\it isC_{1}}\\
&\hfill |
    &c_{2}({\it pr}_{2,1}: A_{2,1}, & \ldots & , {\it pr}_{2,k_{2}}: A_{2,k_{2}})
      ?{\it isC_{2}}\\
&                                 & \multicolumn{1}{c}{\vdots}\\
&\hfill |
    &c_{n}({\it pr}_{n,1}: A_{n,1}, & \ldots & , {\it pr}_{n,k_{n}}: A_{n,k_{n}})
      ?{\it isC_{n}}\\
\end{mcrl2}
This declares sort $A$ to consists of 
$n$ constructors $c_i$, projection functions ${\it pr}_{i,j}$ and
recognisers ${\it isC_i}$. All the $A_{i,j}$ are sorts. The $A_{i,j}$ are
can be equal to $A$, in which case $A$ is a recursive structured sort.

A very well known example is that of a tree data structure in which natural 
numbers can be stored.
\begin{mcrl2}
sort& {\it Tree}=
{\bf struct}~{\it node}({\it left}:{\it Tree},{\it right}:{\it Tree})~|~{\it leave}(\Nat)?
{\it is\_leave};
\end{mcrl2}

By combining aliases and structured sorts, 
it is possible to have very different looking sort expressions that denote
the same sorts. Two such expressions are equal if by folding and unfolding the definitions in
sort aliases and in structured sorts, 
the sort expressions can be rewritten to each other. 
When manipulating terms it is inconvenient
to be forced to perform folding and unfolding to determine equivalences of sorts. Therefore, it
is useful to replace all equivalent sorts by a single unique representation, reducing the check
for equivalency of sorts to checking whether the sorts are syntactically equal. This process
is called {\it sort normalisation}. Note that normalisation depends on a data specification.
Adding one sort alias or one structured sort can change the outcome of the 
normalisation procedure. 


Below we give an algorithm to perform normalisation which is used in the mCRL2 tool suite.

The algorithm is performed in three steps.
First, the set of aliases is checked for recursive definitions
in all sorts except the structured sorts. This can be done using 
a simple depth first algorithm.
 
Second, the set of aliases is stored from right to
left in a map $\it sort\_aliases\_to\_be\_investigated$.
So, if $A=B$ is declared, then ${\it sort\_aliases\_to\_be\_investigated}(B)=A$.
The name of this map uses the word `{\it investigated}' because it
must be investigated whether these rewrite rules are confluent.
There is one exception, namely, if in an alias $A=B$ the sort $B$ equals
$\Bool$, $\Pos$, $\Nat$, $\Int$ or $\Real$ the rule is stored from left
to right. This has as a consequence that the basic sorts cannot
be normalized to other sorts.

As a third step the sort aliases are taken as rewrite rules, and 
a form of Knuth-Bendix completion is applied to them, to transform them
into a confluent term rewriting system, guaranteeing unique representations.

So, if there are two overlapping left hand sides in the rewrite system, this
means that one term is a subterm of the other. So, we have a rule 
$f(g(t))\rightarrow u_1$ and a term $g(t)\rightarrow u_2$. So, the term
$f(g(t))$ can rewrite to both $u_1$ and $f(u_2)$. In this case we simply add
a rewrite rule $f(u_2)\rightarrow N(u_1)$ where $N(u_1)$ is the normal form
of $u_1$. Note that the terms at the left and
the right hand side do not become more complex. Therefore, given that there
are a finite number of sorts, there is an upperbound on the number of equations,
and this procedure is guaranteed to terminate.

In more detail, we have two sets of rewrite rules. One that is definitive
${\it m\_normalised\_sort\_aliases}$ and $\it sort\_aliases\_to\_be\_investigated$ 
that contains sort rewrite rules
still to be investigated. Initially, all rules are in 
$\it sort\_aliases\_to\_be\_investigated$. Each rewrite rule $t_1\rightarrow u_1$
in $\it sort\_aliases\_to\_be\_investigated$ is checked with
each rule $t_2\rightarrow u_2$ in ${\it m\_normalised\_sort\_aliases}$.
If $t_1$ is a subterm of $t_2$ (i.e.\ $t_2=f(t_1)$) and 
$N(u_2)$ and $f(u_1)$ do not have the same normal forms, then a rule $f(u_1)\rightarrow
N(u_2)$ is added to $\it sort\_aliases\_to\_be\_investigated$ where $N(u_2)$ is
the normal form of $u_2$ under application of $\it sort\_aliases\_to\_be\_investigated$ and
${\it m\_normalised\_sort\_aliases}$.
If $t_2$ is a subterm of $t_1$ a symmetric sequence of steps is done.
After all rewrite rules $t_1\rightarrow u_1$ in ${\it m\_normalised\_sort\_aliases}$
have been investigated, $t_2\rightarrow u_2$ is added to 
${\it m\_normalised\_sort\_aliases}$.

The resulting rewrite system is terminating, provided that the original rewrite system
was terminating. Each new rule that is added has the shape $C = a$, where $C$ is
a basic or complex type, and $a$ is a basic type, which is a normal form in the
rewrite system. The only way that there is non termination, is when there
is an infinite sequence of basic sorts $a_1$, $a_2,\ldots$, such that $a_i$ rewrites
to $a_{i+1}$. This loop came into existence by adding some rewrite rule $a=a'$ at
some moment in time, where $a'$ was not a normal form. But this cannot happen,
because by construction $a'$ is a normal form.

After constructing the normal forms, the content of ${\it m\_normalised\_sort\_aliases}$
is copied into {\it m\_normalised\_aliases}, where every right hand side is normalised,
to speed up rewriting when applied to concrete sorts.

Normalisation of concrete sorts is now very simple. Every sort which equals a
left hand side of a sort alias is replaced by the right hand side. This is repeated
until no such substitution can be applied. This can be done using a simple 
innermost rewriting procedure. This rewriter has been implemented in 
{\it normalise\_sorts\_helper}. Actually, because very often the same sorts must
be rewritten, for every sort $t$ that is rewritten to a sort $u$, a rewrite
rule $t=u$  is added to {\it m\_normalised\_aliases}. As we know that {\it m\_normalised\_aliases}
only contains normal forms at the right hand side, it allows to first see
whether {\it m\_normalised\_aliases} defines a normal form for a term, before starting
with relatively time consuming innermost rewriting.

As a side note, we mention that after sort normalisation, it is not possible
anymore to recognize the structure of a sort by direct investigation. With the following
alias
\begin{mcrl2}
sort&F=A\rightarrow B;
\end{mcrl2}
then it can become non obvious that the sort $F$ represents a function. 
So, in this case the aliases must be unfolded to find the sort expression
that it represents. The utility function {\it unalias} is provided for this.
\end{document}
