\documentclass{article}
\usepackage{a4wide}
\usepackage{latexsym}
\usepackage{times}
%\usepackage{here}
\usepackage{theorem}
\usepackage{url}
\usepackage{pstricks,pst-node,pst-grad,pst-plot,pst-coil}
\usepackage[english]{babel}
\usepackage[final]{graphics}
\usepackage{amsmath,amssymb}
\usepackage{amsfonts}
\usepackage{array}
\usepackage{calc}
\usepackage{xspace}
\usepackage{color}
\usepackage{epsfig}
\usepackage{subfigure}
\usepackage{float}
\usepackage{stmaryrd}
\pagestyle{plain}

\newcommand{\Bool}{{\mathbb B}}
\newcommand{\Real}{\mathbb{R}}
\newcommand{\Nat}{\mathbb{N}}
\newcommand{\Pos}{\mathbb{N^{+}}}
\newcommand{\Int}{\mathbb{Z}}

\newcolumntype{L}{>{$}l<{$}}%stopzone%stopzone%stopzone
\newcolumntype{C}{>{$}c<{$}}%stopzone%stopzone%stopzone
\newcolumntype{R}{>{$}r<{$}}%stopzone%stopzone%stopzone

\newenvironment{mcrl2}%
{\begin{trivlist}
\item\begin{tabular}{@{}>{\bf}p{2.3em}L@{\ }L@{\ }L@{\ }L@{\ }L@{\ }L@{\ }L@{\ }L}}%
{\end{tabular}\end{trivlist}}

\title{An algorithm to find a representant for sorts in the context of sort aliases and
recursive sorts}
\author{Jan Friso Groote and Jeroen van der Wulp}
\date{September 6, 2009}
\begin{document}
\maketitle
%\section{Type equivalence}
\noindent%
In mCRL2 it is possible to define structured sorts, sort aliases and 
recursive sorts.
A structured sort has the shape:
\begin{mcrl2}
sort & A={\bf struct}
    &c_{1}({\it pr}_{1,1}: A_{1,1}, & \ldots & , {\it pr}_{1,k_{1}}: A_{1,k_{1}})
      ?{\it isC_{1}}\\
&\hfill |
    &c_{2}({\it pr}_{2,1}: A_{2,1}, & \ldots & , {\it pr}_{2,k_{2}}: A_{2,k_{2}})
      ?{\it isC_{2}}\\
&                                 & \multicolumn{1}{c}{\vdots}\\
&\hfill |
    &c_{n}({\it pr}_{n,1}: A_{n,1}, & \ldots & , {\it pr}_{n,k_{n}}: A_{n,k_{n}})
      ?{\it isC_{n}}\\
\end{mcrl2}
This declares sort $A$ to consists of 
$n$ constructors $c_i$, projection functions ${\it pr}_{i,j}$ and
recognisers ${\it isC_i}$. All the $A_{i,j}$ are sorts. The $A_{i,j}$ are
can be equal to $A$, in which case $A$ is a recursive structured sort.

A very well known example is that of a tree data structure in which natural 
numbers can be stored.
\begin{mcrl2}
sort& {\it Tree}=
{\bf struct}~{\it node}({\it left}:{\it Tree},{\it right}:{\it Tree})~|~{\it leave}(\Nat)?
{\it is\_leave};
\end{mcrl2}

Using sort aliases it is possible to declare that certain sorts are equal. E.g.,
in order to use the sortname ${\it Time}$ to refer to $\Nat$, one can write
\begin{mcrl2}
sort &{\it Time}=\Nat;
\end{mcrl2}
From this point on, the sorts ${\it Time}$ and $\Nat$ can be used interchangeably.
They are considered as the same sorts.

By combining aliases and structured sorts, 
it is possible to have very different looking sort expressions that denote
the same sorts. Two such expressions are equal if by folding and unfolding the definitions in
sort aliases and in structured sorts, 
the sort expressions can be rewritten to each other. 
When manipulating terms it is inconvenient
to be forced to perform folding and unfolding to determine equivalences of sorts. Therefore, it
is useful to replace all equivalent sorts by a single unique representant, reducing the check
for equivalency of sorts to checking whether the sorts are syntactically equal. This process
is called normalisation. Note that normalisation depends on a data specification.
Adding one sort alias or one structured sort can change the outcome of the normalisation procedure. Below we give an algorithm to perform normalisation, yielding the
most compact sort expression as the representant of a set of equivalent sort expressions.

The algorithm is performed in two steps. First a set of rules for structured sorts and    aliases
is normalized, subsequently sort expressions are reduced using this normalized set of rules.
First consider a set of rules defining sorts.
\begin{enumerate}
\item
Replace for every sort alias where $B$ is a single sortname
\begin{mcrl2}
sort&A=B;
\end{mcrl2}
the sort $A$ by $B$ in the right hand sides of sort aliases in this set of rules. 
Afterwards, $A$ does not occur anymore, except in this rule.
Whenever in this process a sort alias occurs of the form ${\bf sort}~A=A$ there was
a loop in the definition of sort aliases, which is not allowed. If no alias is applicable anymore, proceed to step 2.
\item
For all aliases with equal structured sorts in the right hand side, 
remove one of the definitions
and introduce a sort alias expressing that the left hand sides are equal. Concretely,
sort definitions
\begin{mcrl2}
sort &A={\bf struct}~{\rm sort~definition};\\
     &B={\bf struct}~{\rm sort~definition};
\end{mcrl2}
are replaced by
\begin{mcrl2}
sort &A={\bf struct}~{\rm sort~definition};\\
     &B=A;
\end{mcrl2}
If a sort alias is introduced, go back to step 1. Otherwise proceed to the phase below
where concrete sorts are reduced.
\end{enumerate}
Normalisation of concrete sorts is now very simple. Every sort which equals a
left hand side of a sort alias is replaced by the right hand side. This is repeated
until no such substitution can be applied. Afterwards, every
sort expression that matches the right hand side of a structured sort definition, is
replaced by its left hand side until no more of such substitutions can be performed
either. For correctness it is not even required that the alias definitions are applied
first.

The correctness of our procedure is formulated as follows. Whenever two sort expressions
can be transformed to each other by folding and unfolding definitions of sort aliases and structured
sorts, then both expressions have the same normal form.

The proof follows from the observation that if one folding or unfolding step is
performed, both sides have the same normal form.

First note that the normalisation procedure is terminating as sort aliases
are removed and expressions are shortened in each step. Furthermore, the normalisation
procedure is confluent, as there are no critical pairs. So, normalisation yields exactly
one representant for each sort expression.

Consider two sort expressions $t_1$ and $t_2$ where $t_1$ is applied by replacing a sort $A$
by a sort $B$ because the data specification contains a sort alias definition $A=B$. This means
that the normalized specification either has a sort alias $A=B$, or it has sort aliases
$A=C$ and $B=C$ for some sort name $C$. In both cases we see that $t_1$ and $t_2$ can be rewritten
to an equal sort expression using these rules, and hence they have the same representant.

Now consider two sort expressions $t_1$ and $t_2$ where $t_1$ is obtained by replacing
a sort $A$ by a structured sort expression $e$ in $t_2$ as the data specification contains
a sort expression $A=e$. During normalisation the sort expression $e$ has been replaced by
sort aliases to become $e'$. So, there is either a sort definition $A=e'$ in the normalized
specification, or there is a sort definition $B=e'$ and an alias $A=B$. As we can normalize
the sort expression $e$ in $t_1$ to $e'$ and then replace it by $B$, (or $A$ in the first case),
and we can replace  $A$ by $B$ in $t_2$ normalisation can make these expressions equal, and
hence they have the same representant.

As a consequence, all expressions that can be transformed to each other
by folding and unfolding definitions of sort aliases and structured sorts have the
same representant.



\end{document}
