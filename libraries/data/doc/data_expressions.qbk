[section: Data expressions]
The class =data_expression= represents expressions like =true=,
[^x > 3] and [^forall n:Nat. f(n) < 5]. Each data expression =d= has a type or
sort =d.sort()= of type =sort_expression=. 
Let's look at a simple example
that constructs the numbers two and three, and builds the expression 2 + 3:

    #include "mcrl2/data/data.h"
    #include "mcrl2/atermpp/aterm_init.h"
    #include <cassert>

    using namespace mcrl2::data;

    int main(int argc, char* argv[])
    {
      MCRL2_ATERMPP_INIT(argc, argv)

      data_expression two   = sort_nat::nat(2);
      data_expression three = sort_nat::nat(3);
      data_expression five  = sort_nat::plus(two, three);

      assert(five.sort() == sort_nat::nat());
      return 0;
    }

[table Data Expressions
  [ [Expression] [Meaning] ]
  [ [`data_expression`] [any data expression] ]
  [ [`function_symbol`] [function symbol] ]
  [ [`variable`] [variable] ]
  [ [`abstraction`] [expression with variable binding] ]
  [ [`lambda`] [lambda abstraction] ]
  [ [`forall`] [universal quantification] ]
  [ [`exists`] [existential quantification] ]
  [ [`where_clause`] [where clause] ]
  [ [`application`] [function application ] ]
  [ [`identifier`] [untyped identifier (not to be used after type checking)] ]
 ]

[warning =identifier= should not be used after type checking, as it entails an
untyped sort expression, whereas all libraries and tools in the toolset in
general assume fully typed expressions.]

An overview of all data expressions in the Data Library is given in the table
above. More detailed, data expressions are divided into function symbols, represented
by the class =function_symbol=, variables, represented by =variable=,
abstractions, represented by the class =abstraction=, where clauses,
represented by =where_clause=, and applications of expressions to expressions,
represented by =application=. Furthermore, when used in the initial phases
of parsing and type checking, the use of untyped identifiers, represented
by =identifier= is allowed.

Abstractions provide a mechanism for variable binding. As such, they are
further subdivided into lambda abstraction, represented by =lambda=,
and universal and existential quantifications, represented by
=forall= and =exists= respectively.

More formally, data expressions =e=, with sort expression =S= and variable names
=x= correspond to the following grammar:

  e ::= x | n | e(e, ..., e) | lambda x:S, ..., x:S . e |
        forall x:S, ..., x:S. e | exists x:S, ..., x:S. e |
        e whr x = e, ..., x = e end
        
 Here =e(e,...,e)= denotes application of data expressions, =lambda x:S, ..., x:S . e=
 denotes lambda abstraction, =forall x:S, ..., x:S . e= and =exists x:S, ..., x:S . e=
 denote universal and existential quantification.
       
[endsect] [/ Data expressions]