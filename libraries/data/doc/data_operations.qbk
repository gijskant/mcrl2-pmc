[section: Operations on data expressions]

[section: Default operations]
For all sorts, a number of operations is available by default. The corresponding
functions can be found in `standard.h`.

Let =b= be a data expressions of sort =Bool=, and let =x=
and =y= be two data expressions with the same sort. Then the following
operations are supported:

[table Operations on all data types
    [[Expression] [Syntax] [Meaning]]
    [ [ `equal_to(x, y)    `] [[^ x == y ]    ] [equality                  ]]
    [ [ `not_equal_to(x, y)`] [[^ x != y ]    ] [inequality                ]]
    [ [ `if_(b, x, y)      `] [[^ if(b,x,y)]  ] [conditional expression    ]]
    [ [ `less(x,y)         `] [[^ x < y ]     ] [less than                 ]]
    [ [ `less_equal(x,y)   `] [[^ x <= y ]    ] [less than or equal to     ]]
    [ [ `greater(x,y)      `] [[^ x > y ]     ] [greater than              ]]
    [ [ `greater_equal(x,y)`] [[^ x >= y ]    ] [greater than or equal to  ]]
]

For the predefined sorts, the most important operations are also available
by default.
[endsect] [/ Default operations]

[note In all definitions of operations on predefined sorts, elements of which
the syntax starts with @ cannot directly be entered by the user when writing
an mCRL2 specification. The @ means that the specified operation is
implementation specific. Printing such an expression as feedback to the user
should be prevented at all times.]

[section: Booleans]
All standard operations for the Booleans are available in `bool.h`, and can be
found in the namespace =data::sort_bool=. First of all
the two constants =true= and =false= can be constructed.

[table Constructors for sort Bool
  [ [Expression] [Syntax]         [Meaning] ]
  [ [`true()  `] [ [^ true  ] ]   [ true  ] ]
  [ [`false() `] [ [^ false ] ]   [ false ] ]
]

Furthermore the following functions are available on Booleans (for details
about the allowed types also see bool.spec). Let =b= and =c= be Boolean expressions.
[table Functions for sort Bool
  [ [Expression] [Syntax]         [Meaning] ]
  [ [`not_(b,c)  `] [ [^ !b  ] ]   [ negation  ] ]
  [ [`and_(b,c) `]  [ [^ b && c] ]   [ conjunction ] ]
  [ [`or_(b,c) `]  [ [^ b || c ] ]   [ disjunction ] ]
  [ [`implies(b,c) `]  [ [^ b => c] ]   [ implication ] ]
]

[endsect] [/ Booleans]

[section: Positive numbers]
All standard operations for positive numbers are available in `pos.h`, and can
be found in the namespace =data::sort_pos=. The positive numbers have two
constructors, facilitating an encoding with size logarithmic in the number
that is represented.
Let =b= be a Boolean expression, and =p= be a positive expression.

[table Constructors for sort Pos
  [ [Expression] [Syntax]         [Meaning] ]
  [ [`c1()  `] [ [^ @1  ] ]   [ 1  ] ]
  [ [`cdub(b,p) `] [ [^ @cDub(b,p) ] ]   [ 2*p + b ] ]
]

Furthermore the standard operations are available on Positive numbers.
Let =b= and =c= be Boolean expressions, and =p=, =q=, and =r= be positive
numbers.
[table Functions for sort Pos
  [ [Expression] [Syntax]         [Meaning] ]
  [ [`max(p,q)  `] [ [^ max(p,q)  ] ]   [ maximum  ] ]
  [ [`min(p,q) `]  [ [^ min(p,q) ] ]   [ minimum ] ]
  [ [`abs(p) `]  [ [^ abs(p) ] ]   [ absolute value ] ]
  [ [`succ(p) `]  [ [^ succ(p)] ]   [ successor ] ]
  [ [`plus(p,q) `]  [ [^ p+q ] ]   [ addition ] ]
  [ [`add_with_carry(b,p,q) `]  [ [^ @addc(b,p,q) ] ]   [ addition with carry (p + q + b) ] ]
  [ [`multir(b,p,q,r) `]  [ [^ @multir(b,p,q,r) ] ]   [ multiplication with intermediate result ] ]
]

[endsect] [/ Positive numbers]

[section: Natural numbers]
All standard operations for natural numbers are available in `nat.h`, and can
be found in the namespace =data::sort_nat=. The natural numbers have two
constructors, representing =0= and a positive number interpreted as a
natural number.

Let =p= be a positive expression.

[table Constructors for sort Nat
  [ [Expression] [Syntax]         [Meaning] ]
  [ [`c0()  `] [ [^ @0  ] ]   [ 0  ] ]
  [ [`cnat(p) `] [ [^ @cNat(p) ] ]   [ p interpreted as natural number ] ]
]

Furthermore the standard operations are available on Natural numbers.
Let =b= and =c= be Boolean expressions, =p=, =q= be positive numbers,
and =n=, =m=, =u=, =v= be natural numbers.
[table Functions for sort Nat
  [ [Expression] [Syntax]         [Meaning] ]
  [ [`Pos2Nat(p)  `] [ [^ Pos2Nat(p) ] ]   [ explicit conversion of =p= to sort Nat ] ]
  [ [`Nat2Pos(n)  `] [ [^ Nat2Pos(n) ] ]   [ explicit conversion of =n= to sort Pos ] ]
  [ [`max(p,n) `]  [ [^ max(p,n) ] ]   [ maximum ] ]
  [ [`max(n,p) `]  [ [^ max(n,p) ] ]   [ maximum ] ]
  [ [`max(m,n) `]  [ [^ max(m,n) ] ]   [ maximum ] ]
  [ [`min(m,n) `]  [ [^ min(m,n) ] ]   [ minimum ] ]
  [ [ [`abs(n) `]  [ [^ abs(n) ] ]   [ absolute value ] ]
  [ [`succ(n) `]  [ [^ succ(n)] ]   [ successor ] ]
  [ [`pred(n) `]  [ [^ pred(n)] ]   [ predecessor ] ]
  [ [`dub(b,n) `]  [ [^ @dub(b,n)] ]   [ ??? ] ]
  [ [`plus(p,n) `]  [ [^ p+n ] ]   [ addition ] ]
  [ [`plus(n,p) `]  [ [^ n+p ] ]   [ addition ] ]
  [ [`plus(m,n) `]  [ [^ m+n ] ]   [ addition ] ]
  [ [`gtesubt(p,q) `] [ [^ @gtesubt(p,q) ] ] [ =p - q=, if =p >= q= ] ]
  [ [`gtesubt(m,n) `] [ [^ @gtesubt(m,n) ] ] [ =m - n=, if =m >= n= ] ]
  [ [`gtesubtb(b,p,q) `] [ [^ @gtesubtb(b,p,q) ] ] [ substraction with borrow ] ]
  [ [`times(m,n) `]  [ [^ m*n ] ]   [ multiplication ] ]
  [ [`div(p,q) `]  [ [^ p div q ] ]   [ integer division ] ]
  [ [`div(m,p) `]  [ [^ m div p ] ]   [ integer division ] ]
  [ [`mod(p,q) `]  [ [^ p mod q ] ]   [ modulus ] ]
  [ [`mod(m,p) `]  [ [^ m mod p ] ]   [ modulus ] ]
  [ [`exp(p,n) `]  [ [^ p^n ] ]   [ exponentiation ] ]
  [ [`exp(m,n) `]  [ [^ m^n ] ]   [ exponentiation ] ]
  [ [`even(n) `]  [ [^ @even(n)] ]   [ predicate to indicate =n= is even ] ]
  [ [`monus(m,n) `]  [ [^ @monus(m,n) ] ]   [ =(m-n) max 0= ] ]
  [ [`swap_zero(m,n) `]  [ [^ @swap_zero(m,n) ] ]   [ ??? ] ]
  [ [`swap_zero_add(m,n,u,v) `]  [ [^ @swap_zero_add(m,n,u,v) ] ]   [ ??? ] ]
  [ [`swap_zero_min(m,n,u,v) `]  [ [^ @swap_zero_min(m,n,u,v) ] ]   [ ??? ] ]
  [ [`swap_zero_monus(m,n,u,v) `]  [ [^ @swap_zero_monus(m,n,u,v) ] ]   [ ??? ] ]
  [ [`swap_zero_lte(m,n,u,v) `]  [ [^ @swap_zero_lte(m,n,u,v) ] ]   [ ??? ] ]
]

To facilitate efficient rewriting, also a sort =@NatPair= is available. Code
for this is also present in =nat.h=, in namespace =data::sort_nat=.

Let =m=, =n= be expressions of sort Nat.
[table Constructors for sort @NatPair
  [ [Expression] [Syntax]         [Meaning] ]
  [ [`cpair(m,n) `] [ [^ @cPair(m,n) ] ]   [ tuple (m,n) ] ]
]

Also functions for these pairs are available.
Let =b= be a Boolean expression, =p=, =q= be positive numbers,
and =n=, =m=, =u=, =v= be natural numbers.
[table Functions for sort @NatPair
  [ [Expression] [Syntax]         [Meaning] ]
  [ [`first(cpair(m,n)) `] [ [^ @first(@cPair(m,n)) ] ]   [ projection of first argument ] ]
  [ [`second(cpair(m,n)) `] [ [^ @second(@cPair(m,n)) ] ]   [ projection of second argument ] ]
  [ [`divmod(p,q) `] [ [^ @divmod(p,q) ] ]   [ simultaneous division and modulus ] ]
  [ [`gdivmod(pair(m,n), b, p) `] [ [^ @gdivmod(@pair(m,n), b, p) ] ]   [ generalised simultaneous division and modulus ] ]
  [ [`ggdivmod(m, n, p) `] [ [^ @ggdivmod(m ,n, p) ] ]   [ doubly generalised simultaneous division and modulus ] ]
]

[endsect] [/ Natural numbers]

[section: Integers]
All standard operations for integers are available in `int.h`, and can
be found in the namespace =data::sort_int=. The integers have two
constructors, one interpreting a natural number as integer, and one
interpreting a positive number as a negative integer.

Let =p= be a positive expression, and =n= be a natural number.

[table Constructors for sort Int
  [ [Expression] [Syntax]         [Meaning] ]
  [ [`cint(n)  `] [ [^ @cInt(n)  ] ]   [ =n= interpreted as an integer ] ]
  [ [`cneg(p) `] [ [^ @cNeg(p) ] ]   [ =p= interpreted as the integer =-p= ] ]
]

Furthermore the standard operations are available on Natural numbers.
Let =b= be a Boolean expression, =p=, =q= be positive numbers,
=n=, =m= be natural numbers, and =x=, =y= be integers.
[table Functions for sort Int
  [ [Expression] [Syntax]         [Meaning] ]
  [ [`Nat2Int(n)  `] [ [^ Nat2Int(n) ] ]   [ explicit conversion of =n= to sort Int ] ]
  [ [`Int2Nat(x)  `] [ [^ Int2Nat(x) ] ]   [ explicit conversion of =x= to sort Nat ] ]
  [ [`Pos2Int(p)  `] [ [^ Pos2Int(p) ] ]   [ explicit conversion of =p= to sort Int ] ]
  [ [`Int2Pos(x)  `] [ [^ Int2Pos(x) ] ]   [ explicit conversion of =x= to sort Pos ] ]
  [ [`max(p,x) `]  [ [^ max(p,x) ] ]   [ maximum ] ]
  [ [`max(x,p) `]  [ [^ max(x,p) ] ]   [ maximum ] ]
  [ [`max(n,x) `]  [ [^ max(n,x) ] ]   [ maximum ] ]
  [ [`max(x,n) `]  [ [^ max(x,n) ] ]   [ maximum ] ]
  [ [`max(x,y) `]  [ [^ max(x,y) ] ]   [ maximum ] ]
  [ [`min(x,y) `]  [ [^ min(x,y) ] ]   [ minimum ] ]
  [ [ [`abs(x) `]  [ [^ abs(x) ] ]   [ absolute value ] ]
  [ [ [`negate(p) `]  [ [^ -p ] ]   [ unary minus ] ]
  [ [ [`negate(n) `]  [ [^ -n ] ]   [ unary minus ] ]
  [ [ [`negate(x) `]  [ [^ -x ] ]   [ unary minus ] ]
  [ [`succ(x) `]  [ [^ succ(x)] ]   [ successor ] ]
  [ [`pred(n) `]  [ [^ pred(n)] ]   [ predecessor ] ]
  [ [`pred(x) `]  [ [^ pred(x)] ]   [ predecessor ] ]
  [ [`dub(b,x) `]  [ [^ @dub(b,x)] ]   [ ??? ] ]
  [ [`plus(x,y) `]  [ [^ x+y ] ]   [ addition ] ]
  [ [`minus(p,q) `]  [ [^ p-q ] ]   [ subtraction ] ]
  [ [`minus(n,m) `]  [ [^ n-m ] ]   [ subtraction ] ]
  [ [`minus(x,y) `]  [ [^ x-y ] ]   [ subtraction ] ]
  [ [`times(x,y) `]  [ [^ x*y ] ]   [ multiplication ] ]
  [ [`div(x,p) `]  [ [^ x div p ] ]   [ integer division ] ]
  [ [`mod(x,p) `]  [ [^ x mod p ] ]   [ modulus ] ]
  [ [`exp(x,n) `]  [ [^ x^n ] ]   [ exponentiation ] ]
]

[endsect] [/ Integers]

[section: Real numbers]
All standard operations for real numbers are available in `real.h`, and can
be found in the namespace =data::sort_real=. The real numbers do not have
any constructors, because they cannot be finitely enumerated.

Standard functions for real are available however.
Let =p=, =q= be positive numbers,=n=, =m= be natural numbers, =x=, =y= be integers,
and =r=, =s= be real numbers.
[table Functions for sort Real
  [ [Expression] [Syntax]         [Meaning] ]
  [ [`Pos2Real(p)  `] [ [^ Pos2Real(p) ] ]   [ explicit conversion of =p= to sort Real ] ]
  [ [`Nat2Real(n)  `] [ [^ Nat2Real(n) ] ]   [ explicit conversion of =n= to sort Real ] ]
  [ [`Int2Real(x)  `] [ [^ Int2Real(x) ] ]   [ explicit conversion of =x= to sort Real ] ]
  [ [`Real2Pos(r)  `] [ [^ Real2Pos(r) ] ]   [ explicit conversion of =r= to sort Pos ] ]
  [ [`Real2Nat(r)  `] [ [^ Real2Nat(r) ] ]   [ explicit conversion of =r= to sort Nat ] ]
  [ [`Real2Int(r)  `] [ [^ Real2Int(r) ] ]   [ explicit conversion of =r= to sort Int ] ]
  [ [`max(r,s) `]  [ [^ max(r,s) ] ]   [ maximum ] ]
  [ [`min(r,s) `]  [ [^ min(r,s) ] ]   [ minimum ] ]
  [ [`abs(r) `]  [ [^ abs(r) ] ]   [ absolute value ] ]
  [ [`negate(r) `]  [ [^ -r ] ]   [ unary minus ] ]
  [ [`succ(r) `]  [ [^ succ(r)] ]   [ successor ] ]
  [ [`pred(r) `]  [ [^ pred(r)] ]   [ predecessor ] ]
  [ [`plus(r,s) `]  [ [^ r+s ] ]   [ addition ] ]
  [ [`minus(r,s) `]  [ [^ r-s ] ]   [ subtraction ] ]
  [ [`times(r,s) `]  [ [^ r*s ] ]   [ multiplication ] ]
  [ [`divides(p,q) `]  [ [^ p / q ] ]   [ division ] ]
  [ [`divides(m,n) `]  [ [^ m / n ] ]   [ division ] ]
  [ [`divides(x,y) `]  [ [^ x / y ] ]   [ division ] ]
  [ [`divides(r,s) `]  [ [^ r / s ] ]   [ division ] ]
  [ [`floor(r) `]  [ [^ floor(r)] ]   [ floor ] ]
  [ [`ceil(r) `]  [ [^ ceil(r)] ]   [ ceil ] ]
  [ [`round(r) `]  [ [^ round(r)] ]   [ round ] ]
  [ [`redfrac(x,y) `]  [ [^ @redfrac(x,y)] ]   [ reduce fraction x/y w.r.t. lowest common multiple ] ]
  [ [`redfracwhr(p,x,n) `]  [ [^ @redfracwhr(p,x,n)] ]   [ ??? ] ]
  [ [`redfrachlp(r,x) `]  [ [^ @redfrachlp(r,x)] ]   [ ??? ] ]
]

[important The sorts that are allowed as arguments to the functions for numeric sorts
are exactly the ones that correspond to the sorts of the variables in the tables
with functions. Note that e.g. `sort_real::max(p,q)` is also allowed, and the
correct result sort of =Pos= will automatically be inferred.]

[endsect] [/ Real numbers]

[section: Lists]
All standard operations for lists are available in `list.h`, and can
be found in the namespace =data::sort_list=. The lists have two
constructors, the empty list ([]), and inserting an element into a list (|>).

Let =x= be an element of sort =S=, and =l= of sort =List(S)=.
[table Constructors for sort List(S)
  [ [Expression] [Syntax]         [Meaning] ]
  [ [`nil(S)  `] [ [^ \[\] ] ]   [ The empty list of sort =S= ] ]
  [ [`cons(S,x,l) `] [ [^ x |> l ] ]   [ The list =l= prefixed with =x= ] ]
]

Also, the following functions operating on lists are available. Again,
let =x= be an element of sort =S=, =l= of sort =List(S)=, and =n= of sort Nat.
[table Functions for sort List(S)
  [ [Expression] [Syntax]         [Meaning] ]
  [ [`in(S,x,l)  `] [ [^ x in l ] ]   [ Test whether =x= is an element of =l= ] ]
  [ [`count(S,l) `] [ [^ #l ] ]   [ The size of =l= ] ]
  [ [`snoc(S,l,x) `] [ [^ l <| x ] ]   [ The list =l= suffixed with =x= ] ]
  [ [`element_at(S,l,n)  `] [ [^ l.n ] ]   [ The element at position =n= in =l= ] ]
  [ [`head(S,l) `] [ [^ head(l) ] ]   [ The first element of =l= ] ]
  [ [`tail(S,l) `] [ [^ tail(l) ] ]   [ =l= from which the first element has been removed ] ]
  [ [`rhead(S,l) `] [ [^ rhead(l) ] ]   [ The last element of =l= ] ]
  [ [`rtail(S,l) `] [ [^ rtail(l) ] ]   [ =l= from which the last element has been removed ] ]
]

[endsect] [/ Lists]

[section: Finite sets]
The finite sets quite closely resemble lists. For sort =FSet(S)= the following
constructors are available, assuming a sort =S=, an element =x= of sort =S=, and
=t= being of sort =FSet(S)=.
[table Constructors for sort FSet(S)
  [ [Expression] [Syntax]         [Meaning] ]
  [ [`fset_empty(S)  `] [ [^ @fset_empty() ] ]   [ The empty finite set of sort =s= ] ]
  [ [`fset_cons(S,x,t) `] [ [^ @fset_cons ] ]   [ The finite set =t= extended with =x= ] ]
]

Let =b= be a Boolean, =x= an element of sort =S=, =f=,=g= be functions of sort
=S -> Bool=, and =s=,=t= be of sort =FSet(S)=. The operations of finite
sets are defined as follows.
[table Functions for sort FSet(S)
  [ [Expression] [Syntax]         [Meaning] ]
  [ [`fsetinsert(S,x,s)  `] [ [^ @fsetinsert(x,s) ] ]   [ Insert =x= into =s= ] ]
  [ [`fsetcinsert(S,x,b,s)  `] [ [^ @fsetinsert(x,b,s) ] ]   [ ??? ] ]
  [ [`fsetin(S,x,s)  `] [ [^ @fsetin(x,s) ] ]   [ Test whether =x= is in =s= ] ]
  [ [`fsetlte(S,f,s,t)  `] [ [^ @fsetlte(f,s,t) ] ]   [ =s= is a subset of =t= ] ]
  [ [`fsetunion(S,f,g,s,t)  `] [ [^ @fsetunion(f,g,s,t) ] ]   [ Union of =s= and =t= ] ]
  [ [`fsetintersection(S,f,g,s,t)  `] [ [^ @fsetinter(f,g,s,t) ] ]   [ Intersection of =s= and =t= ] ]
]

[endsect] [/ Finite sets]

[section: Finite bags]
Finite bags are defined in a similar vein as finite sets.
For sort =FBag(S)= the following
constructors are available, assuming a sort =S=, an element =x= of sort =S=,
=p= being a positive number, and
=b= being of sort =FBag(S)=.
[table Constructors for sort FSet(S)
  [ [Expression] [Syntax]         [Meaning] ]
  [ [`fbag_empty(S)  `] [ [^ @fbag_empty() ] ]   [ The empty finite bag of sort =s= ] ]
  [ [`fbag_cons(S,x,p,b) `] [ [^ @bag_cons(x,p,b) ] ]   [ The finite bag =b=, extended with =p= occurrences of =x= ] ]
]

Let =x= an element of sort =S=, =f=,=g= be functions of sort
=S -> Nat=, =t= of sort =FSet(S)=, and =b=,=c= be elements of sort =FBag(S)=.
The operations on finite bags are defined as follows.
[table Functions for sort FSet(S)
  [ [Expression] [Syntax]         [Meaning] ]
  [ [`fbaginsert(S,x,p,b)  `] [ [^ @fbag_insert(x,p,b) ] ]   [ Insert =p= occurrences of =x= into =b= ] ]
  [ [`fsetcinsert(S,x,n,b)  `] [ [^ @fbag_cinsert(x,n,b) ] ]   [ ??? ] ]
  [ [`fbagcount(S,x,b)  `] [ [^ @fbag_count(x,b) ] ]   [ Test count the number of occurrences of =x= in =b= ] ]
  [ [`fbagin(S,x,b)  `] [ [^ @fbag_in(x,b) ] ]   [ Test whether =x= is in =b= ] ]
  [ [`fbaglte(S,f,b,c)  `] [ [^ @fbag_lte(f,b,c) ] ]   [ =b= is a subset of =c= ] ]
  [ [`fbagjoin(S,f,g,b,c)  `] [ [^ @fbag_join(f,g,b,c) ] ]   [ Join of =b= and =c= ] ]
  [ [`fbagintersect(S,f,g,b,c)  `] [ [^ @fbag_inter(f,g,b,c) ] ]   [ Intersection of =b= and =c= ] ]
  [ [`fbagdifference(S,f,g,b,c)  `] [ [^ @fbag_diff(f,g,b,c) ] ]   [ Difference of =b= and =c= ] ]
  [ [`fset2fbag(S,t)  `] [ [^ @fset2fbag(t) ] ]   [ Convert =t= to a finite bag ] ]
]

[endsect] [/ Finite bags]

[section: Sets]
Like the Real numbers, sets and bags do not have
constructors. This means that elements of these sorts are built using functions,
as well as their more simple counterparts, the finite sets and bags.

For sets the following functions are available. Let =d=, =e= be of sort Set(S),
=x= be of sort =S=, =s= be of sort =FSet(S)=, and =f= and =g= be function of
sort =S -> Bool=.
[table Functions for sort Set(S)
  [ [Expression] [Syntax]         [Meaning] ]
  [ [`setconstructor(S, f, s)`] [ [^ @set(f,s) ] ] [ Construct a set from a function and a finite set ] ]
  [ [`emptyset(S)`] [ [^ {} ] ] [ Empty set of sort S ] ]
  [ [`setfset(S, s)`] [ [^ @setfset(s) ] ] [ Interpret finite set s as a set ] ]
  [ [`setcomprehension(S, f)`] [ [^ @setcomp(f) ] ] [ The set of all elements of sort =S= satisfying =f= ] ]
  [ [`in(S,x,d)  `] [ [^ x in d ] ]   [ Test whether =x= is an element of =d= ] ]
  [ [`setcomplement(S,d)  `] [ [^ !d ] ]   [ Set complement of =d= ] ]
  [ [`setunion_(S,d,e)  `] [ [^ d + e ] ]   [ Union of =d= and =e= ] ]
  [ [`setintersection(S,d,e)  `] [ [^ d * e ] ]   [ Intersection of =d= and =e= ] ]
  [ [`setdifference(S,d,e)  `] [ [^ d - e ] ]   [ Difference of =d= and =e= ] ]
  [ [`false_function(S) `] [ [^ @false_ ] ] [ The constant function returning false ] ]
  [ [`true_function(S) `] [ [^ @true_ ] ] [ The constant function returning true ] ]
  [ [`false_function(S) `] [ [^ @false_ ] ] [ The constant function returning false ] ]
  [ [`not_function(S,f) `] [ [^ @not_(f) ] ] [ The function returning =!f(x)= for all elements =x= in =S= ] ]
  [ [`and_function(S,f,g) `] [ [^ @and_(f,g) ] ] [ The function returning =f(x) && g(x)= for all elements =x= in =S= ] ]
  [ [`or_function(S,f,g) `] [ [^ @or_(f,g) ] ] [ The function returning =f(x) || g(x)= for all elements =x= in =S= ] ]
]

Note that the *_function operations are used as implementation details
for representing sets.

[endsect] [/ Sets]

[section: Bags]
For bags the following functions are available. Let =b=, =c= be of sort =FBag(S)=,
=e= of sort =S=, =f=,=g=, of sort =S -> Nat=, =h= of sort =S -> Bool=, =s= of sort
=FSet(S)=, and =x=,=y= of sort =Bag(S)=.
[table Functions for sort Bag(S)
  [ [Expression] [Syntax]         [Meaning] ]
  [ [`bagconstructor(S, f, b)`] [ [^ @bag(f,b) ] ] [ Construct a bag from a function and a finite bag ] ]
  [ [`emptybag(S)`] [ [^ {} ] ] [ Empty bag of sort S ] ]
  [ [`bagfbag(S, b)`] [ [^ @bagfset(b) ] ] [ Interpret finite bag =b= as a bag ] ]
  [ [`bagcomprehension(S, f)`] [ [^ @bagcomp(f) ] ] [ The bag of all elements of sort =S= given by =f= ] ]
  [ [`bagcount(S,e,x)  `] [ [^ count(e,x) ] ]   [ The number of occurrences of =e= in =x= ] ]
  [ [`bagin(S,e,x)  `] [ [^ in(e,x) ] ]   [ Determine whether =e= occurs in =x= ] ]
  [ [`bagjoin(S,x,y)  `] [ [^ x + y ] ]   [ Join of =x= and =y= ] ]
  [ [`bagintersect(S,x,y)  `] [ [^ x * y ] ]   [ Intersection of =x= and =y= ] ]
  [ [`bagdifference(S,x,y)  `] [ [^ x - y ] ]   [ Difference of =x= and =y= ] ]
  [ [`bag2set(S,x)`] [ [^ Bag2Set(x) ] ] [ Convert bag =x= to a set ]]
  [ [`set2bag(S,t)`] [ [^ Set2Bag(t) ] ] [ Convert set =t= to a bag ]]
  [ [`zero_function(S) `] [ [^ @zero_ ] ] [ The constant function returning =0= ] ]
  [ [`one_function(S) `] [ [^ @one_ ] ] [ The constant function returning =1= ] ]
  [ [`add_function(S,f,g) `] [ [^ @add_(f,g) ] ] [ The function returning =f(x) + g(x)= for all elements =x= in =S= ] ]
  [ [`min_function(S,f,g) `] [ [^ @min_(f,g) ] ] [ The function returning =min(f(x),g(x))= for all elements =x= in =S= ] ]
  [ [`monus_function(S,f,g) `] [ [^ @monus_(f,g) ] ] [ The function returning =monus(f(x),g(x))= for all elements =x= in =S= ] ]
  [ [`nat2bool_function(S,f) `] [ [^ @Nat2Bool_(f) ] ] [ The function returning false if =f(x)=0=, and true otherwise ] ]
  [ [`bool2nat_function(S,h) `] [ [^ @Bool2Nat_(h) ] ] [ The function returning =1= if =f(x)=, =0= otherwise ] ]
]

Note that, like for sets, the *_function operations are used as implementation
details for representing bags.

[endsect] [/ Bags]

[endsect] [/ Operations on data expressions]
