[library mCRL2.data
    [quickbook 1.4]
    [authors [Wesselink, Wieger]]
    [copyright 2005-2007 Technische Universiteit Eindhoven]
    [category string-text]
    [purpose
        A C++ layer for the Data Library.
    ]
    [license
        Distributed under the Boost Software License, Version 1.0.
    ]
]

[/  Links   ]
[def __boost__                 [@http://www.boost.org www.boost.org]]
[def __mcrllib__               [@http://www.cwi.nl/~mcrl mCRL]]
[def __mcrl2__                 [@http://mcrl2.org mCRL2]]
[def __mcrl__                  mCRL]
[def __atermlib__              [@http://www.cwi.nl/htbin/sen1/twiki/bin/view/Meta-Environment/ATerms ATerm Library]]
[def __mcrl2_primer__          [@http://www.mcrl2.org/wiki/index.php/MCRL2_Primer mCRL2 Primer]]
[def __lps_library__           [@http://www.mcrl2.org/devel/lps/ LPS library]]

[section: Data types]

[section: Introduction]
The mCRL2 library contains classes that represent data expressions, sorts etc. In
__mcrl2_primer__ these concepts are explained in more detail. This document describes
the corresponding classes.
[endsect]

[section: Sorts and data expressions]
The main class of the data library is `data_expression`. There are three
different kinds of data expressions: `data_variable`, `data_application`
and `data_operation`. They all derive from the class `data_expression`.

A data expression has a sort. A constant sort is represented by `sort_identifier`
and a non-constant sort by `sort_arrow`. Both derive from the class `sort_expression`.

[h6 Data specifications]
Data types are usually declared in a data specification. A data specification
contains lists of sorts, constructors, mappings and equations.
The class `data_specification` contains such a data specification. It is
merely a container of sorts, constructors, mappings and equations. There
is no support for manipulating a data specification. An example of a data
specification is

[pre
sort
  Bit   = struct b0 | b1;

map
  invert: Bit -> Bit;

cons
  K: Pos;

eqn
  invert(b1)= b0;
  invert(b0)= b1;
]

There are several predefined sorts and equations, like `Pos` for the
positive natural numbers. The attributes of a data specification must
conform to a number of type checking rules. TODO: these rules must be documented.

[section: Creating data expressions]
Data expressions and sort expressions can be created using a parser,
or directly using constructors.

[h6 Parsing data expressions]
There is a parser available for linear process specifications
(see the __lps_library__). A linear process specification
contains a data specification. To parse a data specification, it
has to be embedded in a linear process specification.

[h6 Constructing data expressions]
An example of constructing data expressions is given below.

    sort_identifier X("X");
    sort_identifier Y("Y");
    sort_identifier Z("Z");
    sort_expression XY   = sort_arrow(X, Y);
    sort_expression XYZ  = sort_arrow(XY, Z); 
    data_variable x("x", X);
    data_variable three("3", pos());
    data_variable zero("0", nat());
    data_expression e = x;
    data_expression F = false_();

The functions `int_` [footnote If a function name clashes with a `C++` keyword,
a trailing underscore is added.], `nat`, `pos` and `real` return predefined sorts
for types integer, natural number, positive natural number and real
respectively. The functions `true_` and `false_` return predefined
boolean data expressions representing true and false.

[endsect] [/ Creating data expressions]

[section: Operations on data expressions]
There are several operations on data expressions available:

[h6 Logical operators]
The logical operators `not_`, `and_` and `or_`. For convenience there
are also functions `multi_and` and `multi_or` that take more than two
arguments. All of these operators simplify the result if one of their
arguments is false or true.

[h6 Standard functions]
There are several standard functions defined with the same names as their
counterparts in the standard `C++` header `<functional>`. For example
`negate`, `plus`, `minus` etc.

[h6 Function application]
Data expressions are higher order expressions, meaning that they can
be applied as a function to an argument with the right sort. This is
not supported by the library, but a way to achieve it is as follows:

    data_expression x;
    data_expression y;
    data_application z(plus, atermpp::make_list(x, y));

Here `plus` is a predefined standard function, and `make_list` is a
function to make a list from its arguments..

[endsect] [/ Operations on data expressions]

[section: Rewriting data expressions]
A common operation on data expressions is to rewrite them into normal
form. There is a rewriter available that uses the equations of a data
specification as rewrite rules. An example is given below:

    data_specification data_spec;
    rewriter r(data_spec);
    data_expression x = plus(int_(1), int_(2));
    data_expression y = int_(3);
    assert(r(x) == r(y));

A common pattern is to rewrite terms after applying a sequence of
substitutions of the form ['data-variable := data-expression]. The
rewriter has a special interface for this that allows the user to
pass the substitutions as a parameter. This is more efficient, since
the substitutions are only translated once. An example of this is:

    data_specification data_spec;
    rewriter r(data_spec);
    std::vector<rewriter::substitution> substitutions;
    data_variable x("x", int_());
    data_variable y("y", int_());
    data_variable z("z", int_());
    substitutions.push_back(r.make_substitution(x, int_(1))); // x := 1
    substitutions.push_back(r.make_substitution(y, int_(2))); // y := 2
    data_expression z = r(plus(x, y), substitutions.begin(), substitutions.end());
    assert(z == r(int_(3)));

[endsect] [/ Rewriting data expressions]

[endsect]

[/section: Algorithms]
[/There are a few algorithms available in the file =mcrl2/data/utility.h=.]
[/The function `identifiers` returns all identifiers appearing in an arbitrary term.]
[/include ../example/utility.cpp]
[/data_utility_example]
[/endsect]

[endsect]
