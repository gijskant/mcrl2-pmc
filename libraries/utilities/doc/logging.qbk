[section: Logging Library]

[h1 Introduction]

Printing of logging and debug messages has been standardised throughout the mCRL2 toolset through this logging library. The facilities provided by this library should be used throughout the toolset. The library is inspired by the description in "Logging in C++" by P. Marginean (url: http://drdobbs.com/cpp/201804215).

[h1 Concepts]

The logging library incorporates the concepts introduced in this section.

[h2 Log level]

The type `mcrl2_log_level_t' describes the various log levels that we identify. The log level describes the severity of the message. For the sake of completeness we give the type here:

  enum mcrl2_log_level_t
  {
    log_quiet,
    log_error,
    log_warning,
    log_info,
    log_detailed_info,
    log_debug,
    log_debug1,
    log_debug2,
    log_debug3,
    log_debug4,
    log_debug5
  };

Note that no message should ever be printed to the `log_quiet' log level. This level is meant to disable all messages.

[h2 Hint]

Hints can be used to distinguish between separate components in the toolset. The logging library allows controlling logging statements with different hints separately. One can e.g. change the log level for a specific hint, or attach another output stream to a specific hint, allowing the library user to write specific messages to a file.

[h2 OutputPolicy]

The output policy controls the way messages are output. By default the file_output policy is used, which writes a message to the file related to the hint of the current message.

[h1 Library interface]
The main routine in the library is mCRL2log(level, hint), where level is a loglevel, and hint is a (optional) string hint. The routine returns an output stream to which a single log message may be printed. Printing defaults to `stderr'.

[h2 Maximal log level (compile time)]
The library includes a compile time variable `MCRL2_MAX_LOG_LEVEL', which, if not set, defaults to mcrl2_log_debug. All log messages with a log level higher than `MCRL2_MAX_LOG_LEVEL' will be disabled during compile-time, meaning they will not be in the generated executable.

[h2 Maximal log level (runtime)]
The maximal reporting level can be set using `mcrl2_logger::set_reporting_level(level)', by default `log_warning' is assumed.

[h2 Setting output stream]
The output stream of the logger can be set to be any file using `mcrl2_logger::output_policy_t::set_stream(file_pointer)'. Note that file_pointer in this case can also be `stderr' or `stdout'. The default output stream is `stderr'.

[h2 Incorporating hints]
For both the reporting level and the stream, the routines to change them have an optional hint argument that can be used to override the defaults for a specific hint. To set a reporting level for a specific hint "hint" one can use `mcrl2_logger::set_reporting_level(level, "hint")', likewise, for a stream one can use `mcrl2_logger::output_policy_t::set_stream(file_pointer, "hint")'. In order to remove specific treatment of a hint, the routines `mcrl2_logger::clear_reporting_level("hint")' and `mcrl2_logger::output_policy_t::clear_stream("hint")' can be used.

[h2 Formatting the output]
By default each line in the output is prefixed with a fixed string, including a timestamp, the log level and, if provided, a hint. Furthermore, the user of the library can control indentation (at a global level) using the routines `mcrl2_logger::indent()' and `mcrl2_logger::unindent()'.

[h1 Tutorial]
In this section we describe a typical use case of the logging library.

To enable logging, first include the header file.
  #include "mcrl2/utilities/logger.h"

If you want to control the log levels that are compiled into the code, you should set the following macro *before* the include.
  #define MCRL2_MAX_LOG_LEVEL log_debug
this only compiles logging statements up to and including log_debug (and is actually the default).

Now let's start out main routine as usual
  int main(int argc, char** argv)
  {

We only allow reporting of messages up to log_detailed_info, so we do not print messages of level log_debug or higher.
  
    mcrl2_logger::set_reporting_level(log_detailed_info);

We want this information to be printed to stderr, which is the default. Let's do some logging.

    mCRL2log(info) << "This shows the way info messages are printed, using the default messages" << std::endl;
    mCRL2log(debug) << "This line is not printed, and the function " << my_function() << " is not evaluated" << std::endl;

Now we call an algorithm my_algorithm. Which we will define later. My algorithm uses as hint "my_algorithm", and we want to write its output to a file. First we create a file to which we log, and assign it to the hint.

    FILE* plogfile;
    plogfile = fopen("logger_test_file.txt" , "w");
    if(plogfile == NULL)
    {
      throw mcrl2::runtime_error("Cannot open logfile for writing");
    }
    mcrl2_logger::output_policy_t::set_stream(plogfile, "my_algorithm");
    
    // Execute algorithm
    my_algorithm();

    // Do not forget to close the file.
    fclose(plogfile);
  }

Let's take a look at an implementation of my_algorithm().

  void my_algorithm()
  {
    mCRL2log(debug, "my_algorithm") << "Starting my_algorithm" << std::endl;
    int iterations = 3;
    mCRL2log(debug1, "my_algorithm") << "A loop with " << iterations << " iterations" << std::endl;
    mcrl2_logger::indent();
    for(int i = 0; i < iterations; ++i)
    {
      mCRL2log(debug2, "my_algorithm") << "Iteration " << i << std::endl;
      if(i >= 2)
      {
        mcrl2_logger::indent();
        mCRL2log(debug3, "my_algorithm") << "iteration number >= 2, treating specially" << std::endl;
        do_something_special();
        mcrl2_logger::unindent();
      }
    }
    mcrl2_logger::unindent();  
  }

Note that, with the settings so far, only the first debug statement in my_algorithm will be printed. To overcome this, the define before the include of `logger.h' must allow for more debug levels, e.g. by setting it as follows

  #define MCRL2_MAX_LOG_LEVEL log_debug2

Note that this does not yet suffice, as we set that we only allow logging of messages up to `log_detailed_info' level. Therefore we should add the following before the execution of the second debug print in my_algorithm

  mcrl2_logger::set_reporting_level(log_debug2, "my_algorithm");

The complete code now looks as follows:

  #define MCRL2_MAX_LOG_LEVEL log_debug2
  #include "mcrl2/utilities/logger.h"

  void my_algorithm()
  {
    mCRL2log(debug, "my_algorithm") << "Starting my_algorithm" << std::endl;
    int iterations = 3;
    mCRL2log(debug1, "my_algorithm") << "A loop with " << iterations << " iterations" << std::endl;
    mcrl2_logger::indent();
    for(int i = 0; i < iterations; ++i)
    {
      mCRL2log(debug2, "my_algorithm") << "Iteration " << i << std::endl;
      if(i >= 2)
      {
        mcrl2_logger::indent();
        mCRL2log(debug3, "my_algorithm") << "iteration number >= 2, treating specially" << std::endl;
        do_something_special();
        mcrl2_logger::unindent();
      }
    }
    mcrl2_logger::unindent();  
  }

  int main(int argc, char** argv)
  {
    mcrl2_logger::set_reporting_level(log_detailed_info);

    mCRL2log(info) << "This shows the way info messages are printed, using the default messages" << std::endl;
    mCRL2log(debug) << "This line is not printed, and the function " << my_function() << " is not evaluated" << std::endl;

    FILE* plogfile;
    plogfile = fopen("logger_test_file.txt" , "w");
    if(plogfile == NULL)
    {
      throw mcrl2::runtime_error("Cannot open logfile for writing");
    }
    mcrl2_logger::output_policy_t::set_stream(plogfile, "my_algorithm");
    
    // Execute algorithm
    my_algorithm();

    // Do not forget to close the file.
    fclose(plogfile);
  }

Note that in this code, the logging of my_algorithm is done to the file "logger_test_file.txt", whereas the other log messages are printed to stderr.

[endsect]
