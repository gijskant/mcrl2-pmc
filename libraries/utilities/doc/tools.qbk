[/  Images   ]
[def __note__              [$images/note.png]]
[def __alert__             [$images/caution.png]]
[def __detail__            [$images/note.png]]
[def __tip__               [$images/tip.png]]
[def __pbes__              [$images/pbes.gif]]
[def __pbes_expression__   [$images/pbes_expression.gif]]

[/  Links   ]
[def __mcrl2__                 [@http://mcrl2.org mCRL2]]
[def __cli_library__                   [@http://www.mcrl2.org/mcrl2/wiki/index.php/CLI_sublibrary Command Line Interface Library]]

[section: Tool classes]
To simplify the creation of a tool, a number of tool classes is available in the
Utilities Library. They all inherit from the class `tool`, and they can be found
in the namespace `utilities::tools`. The main purpose of the tool classes is to
standardize the behavior of tools. Tool classes use the __cli_library__ for
handling command line arguments. The table below gives an overview of the
available tool classes, and the command line options that they handle.
                           
[table Tool classes and their supported command line arguments
    [[tool class] [command line arguments]]
    [ [=class tool=][ handles =--quiet=, =--verbose=, =--debug=, =--help= and =--version=]]
    [ [=class input_tool=][ in addition handles a positional input file argument]]
    [ [=class input_output_tool=][ in addition handles a positional output file argument]]
    [ [=template <typename Tool> class rewriter_tool=] [extends a tool with a =--rewriter= option]]
    [ [=template <typename Tool> class pbes_rewriter_tool=] [extends a tool with =--rewriter= and =--pbes-rewriter= options]]
]
                                                                                 
The class =rewriter_tool= makes strategies of the data rewriter
available to the user. The class =pbes_rewriter_tool= makes pbes rewriters
available to the user.
                                                           
[h3 Example]
Below an example is given for the pbesparelm tool. Since this is a tool that
takes a file as input and also writes output to a file, it derives from the
class =input_output_tool=.

[import ../../../tools/pbesparelm/pbesparelm.cpp]
[pbes_parelm_tool]

using the =execute= member function, that accepts the command line
arguments specified by the user.

In the constructor a few settings are provided.
This is enough to create a tool with the follow help message:
[pre
Usage: pbesparelm [OPTION\]... [INFILE [OUTFILE\]\]
Reads a file containing a PBES, and applies parameter elimination to it. If 
OUTFILE is not present, standard output is used. If INFILE is not present,     
standard input is used.
]

[h3 Tool properties]
[table Tool properties
    [[property] [meaning]]
    [ [ synopsis ][ Summary of command-line syntax ]]
    [ [ what is  ][ don't know ]]
]

[h3 Creating a new tool]
To create a new tool, the following needs to be done:

[h5 1) Override the =run= member function]
The actual execution of the tool happens in the virtual member function =run=.
The developer has to override this function to add the behavior of the tool
The =run= function is called from the =execute= member function, after the
command line parameters have been parsed.

[h5 2) Set some parameters in the constructor]
In the constructor of a tool, one has to supply a name for the tool,
an author and a description:

  class my_tool: public input_tool
  {
    public:
      my_tool()
        : input_tool(
            "mytool",
            "John Doe",
            "Reads a file and processes it"
          )
      {}
  };

[h5 3) Optionally add additional command line arguments]
Additional command line arguments can be specified by overriding the virtual
methods =parse_options= and =add_options=:

  class pbes_constelm_tool: public filter_tool_with_pbes_rewriter
  {
    protected:
      bool m_compute_conditions;

      void parse_options(const command_line_parser& parser)
      {
        m_compute_conditions = parser.options.count("compute-conditions") > 0;
      }

      void add_options(interface_description& clinterface)
      {
        clinterface.add_option("compute-conditions", "compute propagation conditions", 'c');
      }
    ...
  };

One can change this selection
by overriding the method =available_rewriters=.


[h3 Creating a squadt user interface for a tool]
The preferred way to add a squadt user interface to a tool is to define a class
that derives from tool class adapted by the =squadt_tool= template class.  In
this class one has to override the four methods =set_capabilities=,
=user_interactive_configuration=, =check_configuration= and =perform_task=. All
squadt related code has to made conditional using the flag
=ENABLE_SQUADT_CONNECTIVITY=.  An example is given below:

  class pbes2bes_tool: public squadt_tool< rewriter_tool<input_output_tool> >
  {
    public:

      // Normal tool class implementation for rewriter_tool<input_output_tool>
      ....

  // squadt related functionality (see squadt::mcrl2_tool_interface)
  #ifdef ENABLE_SQUADT_CONNECTIVITY
      void set_capabilities(tipi::tool::capabilities&) const;

      void user_interactive_configuration(tipi::configuration& c)
      {
        // Let squadt_tool update configuration for rewriter and add output file configuration
        synchronise_with_configuration(c);

        // do some user interaction ...

        // update tool class specific part of the configuration
        update_configuration(c);
      }

      bool check_configuration(tipi::configuration const&) const {
        return true; // no tool class specific checking implemented
      }

      bool perform_task(tipi::configuration&);
  #endif
  };

  int main(int argc, char* argv[])
  {
    MCRL2_ATERMPP_INIT(argc, argv)
 
    return pbes2bes_tool().execute(argc, argv);
  }

Properties of the tool class that are provided as argument to the squadt_tool
template class are mimicked for the squadt context. For example
squadt_tool<input_tool> takes an input file named "main-input". Similarly
squadt_tool<rewriter_tool<input_output_tool>> adds input/output files named
"main-input" and "main-output" and a mandatory option "rewrite-strategy".

A =squadt_tool= template class instantiation has two methods that simplify
dealing with configuration objects. One is =synchronise_with_configuration=, this
synchronises the state of tool class variables with that of a configuration
object (the latter has precedence).  This method should only be used in the
user_interactive_configuration and perform_task methods. The other method is
=update_configuration=; which updates a configuration with values received from
the user. This one is typically used at the end of user interactive
configuration. Both of these methods should become obsolete in the near future
and will be removed in the future.

[endsect]
