[library Utilities Library
    [quickbook 1.4]
    [authors [Wesselink, Wieger]]
    [copyright 2008 Technische Universiteit Eindhoven]
    [category string-text]
    [purpose
        The mCRL2 library contains data structures and algorithms
        for the mCRL2 toolset.
    ]
]

[/  Images   ]
[def __note__              [$images/note.png]]
[def __alert__             [$images/caution.png]]
[def __detail__            [$images/note.png]]
[def __tip__               [$images/tip.png]]
[def __pbes__              [$images/pbes.gif]]
[def __pbes_expression__   [$images/pbes_expression.gif]]

[/  Links   ]
[def __mcrl2__                 [@http://mcrl2.org mCRL2]]

[section: Tool classes]
The tools of the mCRL2 toolset share a lot of functionality. To avoid
duplication of code, a number of tool classes exists. They handle
many details of the creation of such a tool for a developer. The table
below gives an overview of the available tool classes, and the command
line options that they handle.

[table Tool classes and their supported command line arguments
    [[tool class] [command line arguments]]
    [ [=command_line_tool=][ handles =--quiet=, =--verbose=, =--debug=, =--help= and =--version=]]
    [ [=input_tool=][ in addition handles a positional input file argument]]
    [ [=input_output_tool=][ in addition handles a positional output file argument]]
    [ [=rewriter_tool=] [in addition handles =--rewriter=]]
    [ [=pbes_rewriter_tool=] [in addition handles =--pbes-rewriter=]]
]

The class =rewriter_tool= makes all strategies of the data rewriter
available to the user. The class =pbes_rewriter_tool= makes a selection
of the pbes rewriters available to the user. One can change this selection
by overriding the method =available_rewriters=.

[note It is questionable whether an option =--pbes-rewriter= should
exist, but it reflects the current situation of the toolset]

The tool classes are part of the utilities library, and are located in the
namespace =mcrl2::utilities=.

[h3 Example]
Below a simple example for the lpsparelm tool is given. A class
=lps_parelm_tool= is defined that derives from the most suitable tool
class (=input_output_tool= in this case). The tool is executed
using the =execute= member function, that accepts the command line
arguments specified by the user.

  class lps_parelm_tool : public input_output_tool {};

  int main(int argc, char* argv[])
  {
    lps_parelm_tool tool;
    return tool.execute(argc, argv);
  }

[h3 Creating a new tool]
To create a new tool, the following needs to be done:

[h5 1) Override the =run= member function]
The actual execution of the tool happens in the virtual member function =run=.
The developer has to override this function to add the behavior of the tool
The =run= function is called from the =execute= member function, after the
command line parameters have been parsed.

[h5 2) Set some parameters in the constructor]
In the constructor of a tool, one has to supply a name for the tool,
an author and a description:

  class my_tool: public input_tool
  {
    public:
      my_tool()
        : input_tool(
            "mytool",
            "John Doe",
            "Reads a file and processes it"
          )
      {}
  };

[h5 3) Optionally add additional command line arguments]
Additional command line arguments can be specified by overriding the virtual
methods =parse_options= and =add_options=:

  class pbes_constelm_tool: public filter_tool_with_pbes_rewriter
  {
    protected:
      bool m_compute_conditions;

      void parse_options(const command_line_parser& parser)
      {
        m_compute_conditions = parser.options.count("compute-conditions") > 0;
      }

      void add_options(interface_description& clinterface)
      {
        clinterface.add_option("compute-conditions", "compute propagation conditions", 'c');
      }
    ...
  };

[h3 Creating a squadt user interface for a tool]
The preferred way to add a squadt user interface to a tool is to define a
class that derives from the tool class, and from the class =squadt::mcrl2_tool_interface=.
In this class one has to override the four methods =set_capabilities=,
=user_interactive_configuration=, =check_configuration= and =perform_task=. All squadt
related code has to made conditional using the flag =ENABLE_SQUADT_CONNECTIVITY=.
An example is given below:

  #ifdef ENABLE_SQUADT_CONNECTIVITY
  class squadt_pbes2bes_tool : public pbes2bes_tool, public squadt::mcrl2_tool_interface
  {
    public:
      void set_capabilities(tipi::tool::capabilities&) const;

      void user_interactive_configuration(tipi::configuration&);

      bool check_configuration(tipi::configuration const&) const;

      bool perform_task(tipi::configuration&);

      int execute(int argc, char** argv)
      {
        if (squadt::free_activation(*this, argc, argv)) {
          return EXIT_SUCCESS;
        }
        return pbes2bes_tool::execute(argc, argv);
      }
  };
  #endif

  int main(int argc, char* argv[])
  {
    MCRL2_ATERMPP_INIT(argc, argv)

    try {
  #ifdef ENABLE_SQUADT_CONNECTIVITY
      squadt_pbes2bes_tool tool;
  #else
      pbes2bes_tool tool;
  #endif
      return tool.execute(argc, argv);
    }
    catch (std::exception& e) {
      std::cerr << e.what() << std::endl;
    }

    return EXIT_FAILURE;
  }

[endsect]
