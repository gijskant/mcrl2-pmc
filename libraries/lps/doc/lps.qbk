[section: Linear processes]

[section: Definition]
A /linear process/ is defined as

__linear_process__

with

__summand__

where

* /d/ is a vector of data variables, called the /process parameters/. The corresponding vector of sorts /D/ models the states of the process.
* __si is a linear process term, called a /summand/
* __Ei is a sort, and the elements /e/ of __Ei are called /summation variables/. [footnote The tool set requires that there are only finitely many values /e/ for which __ci has the value true. ]
* __ci is a boolean term, called the /condition/
* __ai is a term called the /action/
* __ti is a real valued term, called the /time/
* __gi is an /assignment/ function to data variables, with the following interpretation. The expression __gi/(d,e)/ is a state that can be reached from state /d/ by performing the action __ai at time __ti.

A linear process usually has an accompanying initial value __d0:/D/. The summands of a linear process
can have /free variables/, i.e. variables that do not appear in either /d/ or the summation variables /e/:/__Ei/.

[endsect] [/ Definition]

[section: Overview of the classes]

This section describes the classes that correspond to a linear process.

[section: class =specification=]
The class [classref lps::specification] represents a linearized process specification.
It consists of

* a [classref lps::linear_process linear process]
* a [classref lps::data_specification data specification], i.e. a specification of the sorts, constructors, mappings and equations
* an [classref lps::action_label_list action specification], i.e. a sequence of actions that may occur during execution of the process
* an [classref lps::process_initializer initial state]

A typical mCRL2 specification is the following:

[pre
sort
  D     = struct d1 | d2;
  Error = struct e;

act
  r1,s4: D;
  s2,r2,c2: D # Bool;
  s3,r3,c3: D # Bool;
  s3,r3,c3: Error;
  s5,r5,c5: Bool;
  s6,r6,c6: Bool;
  s6,r6,c6: Error;
  i;

proc
  S(b:Bool)     = sum d:D. r1(d).T(d,b);
  T(d:D,b:Bool) = s2(d,b).(r6(b).S(!b)+(r6(!b)+r6(e)).T(d,b));

  R(b:Bool)     = sum d:D. r3(d,b).s4(d).s5(b).R(!b)+
                  (sum d:D.r3(d,!b)+r3(e)).s5(!b).R(b);

  K             = sum d:D,b:Bool. r2(d,b).(i.s3(d,b)+i.s3(e)).K;

  L             = sum b:Bool. r5(b).(i.s6(b)+i.s6(e)).L;

init
  allow({r1,s4,c2,c3,c5,c6,i},
    comm({r2|s2->c2, r3|s3->c3, r5|s5->c5, r6|s6->c6},
        S(true) || K || L || R(true)
    )
  );
]

There are no classes available that represent such a general specification
containing parallel and communication operators. The mCRL2 tool set contains a
tool (mcrl22lps) that converts an mCRL2 specification into a linearized process
specification.

A specification can be stored in binary or ascii format. The [memberref lps::specification::load]
and [memberref lps::specification::save] methods are available for this. An example of loading
a linearised specification is:

    specification spec;
    spec.load("abp.lps");
    if (!spec) // check if load succeeded
    {
      std::exit(EXIT_FAILURE);
    }

All sequences that occur in the classes of the LPS library have an iterator interface
as defined in the C++ standard. An example of printing the summands of a process of
a specification is given below.

    linear_process p = spec.process();
    for (summand_iterator i = p.summands().begin(); i != p.summands().end(); ++i)
    {
      std::cout << pp(*i) << std::endl; // pp is the pretty print function
    }

[endsect] [/ class =specification=]

[section: class =linear_process=]
A linear process is represented by the class [classref lps::linear_process]. It has member
functions for retrieving the summands and the process parameters. There are two
member functions for retrieving the free variables. The function
[memberref lps::linear_process::find_free_variables find_free_variables]
computes the exact set of free variables, while the function
[memberref lps::linear_process::free_variables free_variables] returns a superset
of the free variables. [footnote Perhaps these two functions can be replaced
by one that caches the free variables?]
[endsect] [/ class =linear_process=]

[section: class =summand=]

A summand is represented by the class [classref lps::summand].

[note There are a few restrictions on the usage of summands.
The condition of a summand may be nil, in which case it must be ignored.
The time of a summand is optional, so before using it one must check that it exists.
]

[endsect] [/ class =summand=]

[section: class =action=]

An action is represented by the class [classref lps::action]. An action has two
attributes. It has a name (__ai), which is a label that may be shared with other
actions. And it has a parameter, which is the vector of data expressions __fi(/d/,/e/).

[endsect] [/ class =action=]

[endsect] [/ Classes]

[endsect] [/ Linear processes]
