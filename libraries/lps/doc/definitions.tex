\section{definitions}

\subsection{action formulas}
Action formulas are defined by the following grammar:
\[\begin{tightarray}{lrl}
%\alpha & ::= & \mathsf{val}(c) \mid \strue \mid \neg \alpha
%               \mid \alpha \land \alpha
%               \mid \forall x{:}D.\alpha \mid a(d) \mid \alpha\at t.
\alpha & ::= & c \mid \neg \alpha
               \mid \alpha \land \alpha \mid \alpha \lor \alpha
               \mid \forall x{:}D.\alpha \mid \exists x{:}D.\alpha
               \mid a(d) \mid \alpha\at t.
\end{tightarray}\]

\subsection{parameterised boolean equations}
A Parameterised Boolean Expression (PBE) is a formula $\varphi$
defined by the following grammar:
%
\[\begin{tightarray}{lrl}
\varphi & ::= &  c ~
              \mid~ \varphi \land \varphi ~\mid~ \varphi \vee \varphi
              ~\mid~ \forall x{:}D .~\varphi ~|~ \exists{x{:}D}.~ \varphi
             ~|~ X(d)
\end{tightarray}\]

Here $c$ is a data term of sort $\sbool$, $X$ is a parameterised
propositional variable
from $\f{Props}$
$D$ is a sort, $x$ is a variable of sort $D$ and $d$ is a data term.

A Parameterised Boolean Equation System (PBES) $\mathcal{E}$ is a
finite sequence of fixpoint equations, defined by the following grammar:
\[\begin{tightarray}{lrl}
\mathcal{E} & ::= &  \epsilon \mid (\sigma X(x{:}D)=\varphi)\mathcal{E}
\end{tightarray}\]
where $\sigma \in \{ \nu, \mu \}$ and $\varphi$ is a PBE; $\epsilon$ stands for
the empty list.

\subsection{state formulas}
A state formula is a formula $\varphi$ defined by the following grammar:

\[
\begin{array}{lc}
\varphi ::= &
c
~|~ true
~|~ false
~|~ \neg \varphi
~|~ \varphi \wedge \varphi
~|~ \varphi \vee \varphi
~|~ \varphi \Rightarrow \varphi
~|~ \forall x{:}D .\varphi
~|~ \exists x{:}D .\varphi
~|~ \langle\alpha\rangle \varphi \\ &
~|~ [\alpha] \varphi
~|~ \Delta
~|~ \Delta(t)
~|~ \nabla
~|~ \nabla(t)
~|~ X(d)
~|~ \nu  X(x{:}D:=d).~\varphi
~|~ \mu  X(x{:}D:=d).~\varphi
\end{array}
\]

Here, $\alpha$ is an action formula, $X$ is a (parameterised) propositional variable, $D$ is a
sort, $x$ is a data variable of sort $D$, and $c$, $t$ and $d$ are data expressions of sort
$bool$, $real$ and $D$, respectively. The following table gives the correspondence between
state formulas and their internal ATerm format.

%--- state formula ---%
\[
\begin{array}{ll}
\mathtt{<DataExpr>                                        } & c                              \\
\mathtt{StateTrue                                         } & true                           \\
\mathtt{StateFalse                                        } & false                          \\
\mathtt{StateNot(<StateFrm>)                              } & \neg \varphi                   \\
\mathtt{StateAnd(<StateFrm>, <StateFrm>)                  } & \varphi \wedge \varphi         \\
\mathtt{StateOr(<StateFrm>, <StateFrm>)                   } & \varphi \vee \varphi           \\
\mathtt{StateImp(<StateFrm>, <StateFrm>)                  } & \varphi \Rightarrow \varphi    \\
\mathtt{StateForall(<DataVarId>+, <StateFrm>)             } & \forall x{:}D .\varphi         \\
\mathtt{StateExists(<DataVarId>+, <StateFrm>)             } & \exists x{:}D .\varphi         \\
\mathtt{StateMust(<RegFrm>, <StateFrm>)                   } & \langle\alpha\rangle \varphi   \\
\mathtt{StateMay(<RegFrm>, <StateFrm>)                    } & [\alpha] \varphi               \\
\mathtt{StateYaled                                        } & \nabla                         \\
\mathtt{StateYaledTimed(<DataExpr>)                       } & \nabla(t)                      \\
\mathtt{StateDelay                                        } & \Delta                         \\
\mathtt{StateDelayTimed(<DataExpr>)                       } & \Delta(t)                      \\
\mathtt{StateVar(<String>, <DataExpr>\ast)                } & X(d)                           \\
\mathtt{StateNu(<String>, <DataVarIdInit>\ast, <StateFrm>)} & \nu  X(x{:}D:=d).~\varphi      \\
\mathtt{StateMu(<String>, <DataVarIdInit>\ast, <StateFrm>)} & \mu  X(x{:}D:=d).~\varphi
\end{array}
\]

\subsection{Linear process definitions}
A linear process definition (LPD) is a pair $\tuple{D, d_0, P}$, where
\begin{itemize}
\item $D$ is a sort, which is referred to as the {\em parameter-space} of $P$,
\item $d_0$ is a data expression of sort $D$, initialising $P$,
\item $P$ is a parameterised equation of the form:
\[\begin{tightarray}{lrl}
\mathbf{proc}~ P(x{:}D) & = &
  \sum_{i \in I}\sum_{y_i:E_i} c_i(x,y_i) \rightarrow a_i(f_i(x,y_i))\at t_i(x,y_i) \cdot P(g_i(x,y_i))\\
 & + &\sum_{j \in J}\sum_{y_j:E_j} c_j(x,y_j) \rightarrow \delta \at t_j(x,y_j);
\end{tightarray}\]
%
where $D$ is a sort, $x$ is a variable, and $I$ and $J$ are disjoint finite sets of indices.
For each index $k \in I \cup J$, $E_k$ is a sort, $y_k$ is a variable, and
$c_k: D\times E_k \rightarrow \sbool$ and
$t_k: D\times E_k \rightarrow \snnreal$ are functions.
For each index $i\in I$, $a_i$ is an action name of sort $D_{a_i}$,
$f_i: D \times D_i \rightarrow D_{a_i}$ and $g_i: D \times D_i \rightarrow D$ are functions.\footnote{not operations, since...!}
\end{itemize}
