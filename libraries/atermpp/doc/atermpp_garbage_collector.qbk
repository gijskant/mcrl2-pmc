[section: The garbage collector]
The ATerm Library uses a very agressive garbage collection scheme.
When the garbage collector is triggered, only the following terms will be
retained:

* Terms that are located on the program stack
* Terms that have been explicitly protected against garbage collection

[warning All other terms will be destroyed during garbage collection!]

The garbage collector of the ATerm Library assumes that all aterms that are
not on the program stack can be safely destroyed
[footnote There is no standard way to determine if an object is located
on the stack, which makes the garbage collection potentially unreliable.].
The terms in the `atermpp`
library all have a `protect` member function that can be called to prevent
this behavior.

The following program illustrates this.

    #include <string>
    #include "atermpp/atermpp.h"
    #include "mcrl2/atermpp/aterm_init.h"
    using namespace atermpp;

    aterm a; // using global aterm variables is in general not a good idea
    aterm b;

    aterm f(const std::string& s)
    {
      aterm x = make_term("f(" + s + ")"); // no need to protect x, since it will be created on stack
      return x;
    }

    int main(int argc, char* argv[])
    {
      MCRL2_ATERMPP_INIT(argc, argv)

      a.protect();          // Unsafe! Protecting a term should be done after assignment.
      a = aterm_int(4);

      b = aterm_real(1.1);
      b.protect();          // OK, now it is safe to use b

      b = aterm_real(2.5);  // Oops, b has not been unprotected, so the term aterm_real(1.1)
                            // will never be freed.

      aterm_appl* c = new aterm_appl(make_term("f(x)"));
      c->protect();         // Term c is on the heap, so it must be protected.
      // use c
      c->unprotect();
      delete c;             // After calling unprotect the term can be safely deleted.
    }

[endsect]
