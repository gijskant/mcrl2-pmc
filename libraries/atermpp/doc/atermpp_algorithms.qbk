[section:algorithms ATerm algorithms]

For the `atermpp` library has a couple of algorithms are defined. Most
of these algorithms have template parameters for the terms that they
operate on. These algorithms work on every class for which an `aterm_traits`
specialization exists.

[heading Find algorithms]
There are two find algorithms, `find_if` for searching a subterm that matches a
given predicate, and `find_all_if` for finding all subterms that match a
predicate. The program fragment below illustrates this:

  #include "atermpp/algorithm.h"

  // function object to test if it is an aterm_appl with function symbol "f"
  struct is_f
  {
    bool operator()(aterm t) const
    {
      return (t.type() == AT_APPL) && aterm_appl(t).function().name() == "f";
    }
  };

  aterm_appl a = make_term("h(g(x),f(y),p(a(x,y),q(f(z))))");
  aterm t = find_if(a, is_f());
  assert(t == make_term("f(y)"));

  find_all_if(a, is_f(), std::back_inserter(v));
  assert(v.size() == 2);
  assert(v.front() == make_term("f(y)"));
  assert(v.back() == make_term("f(z)"));

The find algorithms also work on user defined types. So if `t` is of type `MyTerm`
and `aterm_traits<MyTerm>` is defined, then it is possible to call `find_if(t, is_f())`
as well.

[heading Replace algorithms]
There are several algorithms for replacing subterms. The `replace` algorithm replaces
a subterm with another term, `bottom_up_replace` does the same but with a different traversal
order. The algorithm `replace_if` makes replacements based on a predicate. There is also
`partial_replace`, that has the option to prevent further recursion based on a predicate.

  #include "atermpp/algorithm.h"

  // function object to test if it is an aterm_appl with function symbol "a" or "b"
  struct is_a_or_b
  {
    bool operator()(aterm t) const
    {
      return (t.type() == AT_APPL) &&
      (aterm_appl(t).function().name() == "a" || aterm_appl(t).function().name() == "b");
    }
  };

  aterm_appl a = make_term("f(f(x))");
  aterm_appl b = replace(a, make_term("f(x)"), make_term("x"));
  assert(b == make_term("f(x)"));
  aterm_appl c = replace(a, make_term("f(x)"), make_term("x"), true);
  assert(c == make_term("x"));

  aterm d = make_term("h(g(b),f(a),p(a(x,y),q(a(a))))");
  aterm_appl e = replace_if(d, is_a_or_b(), make_term("u"));
  assert(e == make_term("h(g(u),f(u),p(u,q(u)))"));

[heading Miscellaneous algorithms]
The algorithm `apply` is applies an operation to the elements
of a list, and returns the result. The `for_each` algorithm applies
an operation to each subterm of a term.

   #include "atermpp/algorithm.h"

   // Applies a function f to the given argument t.
   struct apply_f
   {
     aterm_appl operator()(aterm_appl t) const
     {
       return aterm_appl(function_symbol("f", 1), t);
     }
   };

   bool print(aterm_appl t) // The return value true indicates that for_each
                              // should recurse into the children of t.
   {
     std::cout << t.function().name() << " ";
     return true;
   }

   aterm_appl t = make_term("h(g(x),f(y))");
   atermpp::for_each(t, print);             // prints "h g x f y"

   aterm_list l = make_term("[0,1,2,3]");
   l = atermpp::apply(l, apply_f());        // results in [f(0),f(1),f(2),f(3)]

[endsect]
