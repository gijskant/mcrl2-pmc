[section: ATerms and the C++ Standard Library]

[heading Protected containers]
Most of the container classes of the C++ Standard Library put their data on the heap.
As a result, putting ATerms in a container without taking precautions is unsafe.
For example:

   #include <vector>

   std::vector<atermpp::aterm> v;             // This is unsafe!
   v.push_back(atermpp::make_term("f(x)");
   v.push_back(atermpp::make_term("g(y)");

Once the garbage collector is triggered, all terms inside `v` will be destroyed. For
this reason, protected variants of most common containers exist. By default, only
the predefined aterm types are protected inside such a container. For user defined
terms, extra precautions are needed.

   #include "atermpp/vector.h"

   atermpp::vector<atermpp::aterm> v;         // This is OK!
   v.push_back(atermpp::make_term("f(x)");
   v.push_back(atermpp::make_term("g(y)");

[heading Iterator interfaces]
The classes `term_list` and `term_appl` have C++ standard conforming iterator interfaces.
Thus they operate well with the C++ Standard Library, as illustrated by the following
example:

    #include <algorithm>
    #include <iostream>
    #include "atermpp/atermpp.h"

    using namespace std;
    using namespace atermpp;

    struct counter
    {
      int& m_sum;

      counter(int& sum)
        : m_sum(sum)
      {}

      void operator()(const aterm_int& t)
      {
        m_sum += t.value();
      }
    };

    int main(int argc, char* argv[])
    {
      MCRL2_ATERMPP_INIT()

      term_list<aterm_int> q = make_term("[1,2,3,4]");
      int sum = 0;
      for_each(q.begin(), q.end(), counter(sum));
      assert(sum == 10);

      for (term_list<aterm_int>::iterator i = q.begin(); i != q.end(); ++i)
      {
        cout << i->value() << " ";
      }
    }

[endsect]
