[library LTS Library
    [quickbook 1.4]
    [authors [Wesselink, Wieger]]
    [copyright 2005-2010 Technische Universiteit Eindhoven]
    [category string-text]
]

[/  Links   ]
[def __mcrl2__                 [@http://mcrl2.org mCRL2]]
[def __mcrl2_primer__          [@http://www.mcrl2.org/wiki/index.php/MCRL2_Primer mCRL2 Primer]]
[def __lts_library__           [@http://www.mcrl2.org/mcrl2/wiki/index.php/LTS_library LTS Library]]

[section: Introduction]
The __lts_library__ provides data structures and methods to handle /labelled
transition systems/ (LTS). Using the library, an LTS can be read from/written
to file (various file formats are supported), minimised using various
equivalences, determinised, and analysed.

This manual gives an overview of the library's structure and explains how to
program with the library. The relevant concepts are introduced and defined
[@ here].

Note that the current implementation of this library is mainly focussed on
creating LTSs. That is, it is easy to add states, transitions and labels, but
there is virtually no functionality to change or remove parts of an LTS. 
[endsect]

[section: Structure]
The LTS library resides in the namespace mcrl2::lts. The main class of this
library is the lts class. This class represents an LTS and contains almost all
available functionality to work with LTSs. States and labels are identified by
unsigned ints and transitions are triples (from, label, to) of unsigned ints,
where from and to are the source and target states, respectively, and label is
the label of the transition.

There is a possibility to assign ATerm values to states and labels. This has
to be specified when creating an lts object or when one resets such an object
(with the reset() method). In principle these values can be any ATerm, but not
all LTS formats support this. In practice the following structures typically
occur:
* No state information (all formats)
* μCRL states: ATermLists of μCRL data expressions (μCRL, FSM)
* mCRL2 states: ATermAppl of mCRL2 data expressions (mCRL2, FSM) 
* String labels: ATermAppl without arguments; the function symbol name is the
  label (all formats except mCRL2)
* mCRL2 multiaction labels: ATermAppl; mCRL2 multiaction in internal format (mCRL2) 

Besides the main lts class, there are several auxiliary classes. Three of them
(state_iterator, transition_iterator and label_iterator) are iterators to
iterate over states, transitions and labels. The lts class has methods to
obtain such iterators (e.g. lts::get_transitions()). Their use is illustrated
in the tutorial below.

The other classes, lts_dot_options, lts_eq_options and lts_extra, are used to
store options for certain operations. 
[endsect]

[section: Starting up]
First of all we must include the appropriate header to use the LTS library.

  #include <mcrl2/lts/liblts.h>

Most of the time it is also useful to specify that we are using the namespace
of the LTS library.

  using namespace mcrl2::lts;

In the rest of the tutorial we assume that this is specified. If one does not
wish to use this, one will have to prepend mcrl2::lts:: to all references to
entities in the LTS library.

[endsect]

[section: Creating an LTS]

Now let us make a function make_blue_lts() that constructs the blue LTS as
shown above and saves it to a file. We start with some declarations.

  void make_blue_lts()
  {
    unsigned int s[5];
    unsigned int lab_open,lab_car,lab_flowers;
 
    lts l(false,true);

All states and labels are identified by unsigned integers. We therefore have an
array s of five unsigned integers to store the identifiers of the (five) states
as well as an unsigned integer variable for each label. The LTS is created with
two arguments: the first argument indicates that we do not store state
information and the second argument indicates that we will use label information
in this example.

Before we can add any transitions to the LTS, we must first add the states and
labels. This is done as follows.

    for (unsigned int i=0; i<5; ++i)
    {
      s[i] = l.add_state();
    }
 
    lab_open = l.add_label((ATerm) ATmakeAppl0(ATmakeAFun("open_door",ATfalse,0)));
    lab_car = l.add_label((ATerm) ATmakeAppl0(ATmakeAFun("win_car",ATfalse,0)));
    lab_flowers = l.add_label((ATerm) ATmakeAppl0(ATmakeAFun("win_flowers",ATfalse,0)));

Note that these functions return the identifier of the state or label. With this
information we can construct the LTS. We specify the initial state:

  l.set_initial_state(s[0]);

And add the transitions:

  l.add_transition(s[0],lab_open,s[1]);
  l.add_transition(s[0],lab_open,s[2]);
  l.add_transition(s[1],lab_car,s[3]);
  l.add_transition(s[2],lab_flowers,s[4]);

The LTS is now complete. To save it, we call the write_to() method with a
filename and the type of the output (lts_aut in this case).

  l.write_to("blue.aut",lts_aut);
}
[endsect]

[section: Read and print]

Now we have created an LTS file, we describe how to read it in again, apply
some reduction and print its contents. There are two ways to read an LTS from a
file. The most straightforward method is to use the appropriate constructor:

  lts l("blue.aut");

Note, however, that this method only works when the supplied file contains a
valid LTS (according to the LTS library). If this is not the case, there is no
way to detect failure. It is therefore advisable to use the following method.

  lts l;
  if ( l.read_from("blue.aut") )
  {
    // reading went ok
  } else {
    // reading failed
  }

Now that the LTS has been read from file, our goal is to print the transitions
of the minimal deterministic trace-equivalent LTS to the screen.

For the reduction we simply call the reduce() method with the option
lts_eq_trace.

  l.reduce(lts_eq_trace);

The LTS l has now been reduced, so we can print the result. We iterate over all\
transitions in a loop as follows.

  for (transition_iterator i = l.get_transitions(); i.more(); ++i)
  {

We show the states by printing their identifiers (i.e. the unsigned integers),
but for the labels we wish to use the actual value as a string, which we can
obtain as follows.

    string label = l.label_value_str(i.label());

To print each transition we do the following.

    cout << i.from() << "  -- " << label << " -->  " i.to() << endl;
  }

The output is as follows:

1  -- open_door -->  0
0  -- win_flowers -->  2
0  -- win_car -->  2

Note that the initial state is 1. To verify this one could also print
l.initial_state(). 
[endsect]

[section: Reducing and comparing labelled transition systems]

It is possible to reduce an lts modulo different equivalencies. 
The transition system will be replaced by another transition system
that is generally smaller in such a way that the initial state is
still equivalent to the old initial state. The equivalencies that
have been implemented are:

    lts_eq_none:             No reduction
    lts_eq_bisim:            Strong bisimulation equivalence 
    lts_eq_branching_bisim:  Branching bisimulation equivalence
    lts_eq_divergence_preserving_branching_bisim:
                             Divergence preserving branching bisimulation equivalence 
    lts_eq_sim:              Strong simulation equivalence 
    lts_eq_trace:            Strong trace equivalence
    lts_eq_weak_trace:       Weak trace equivalence
    lts_eq_isomorph:         Isomorphism.

Application of the reduction of an lts is pretty simple. Note that the
lts is replaced by the reduced lts. The original lts will be destroyed.

    lts l("an_lts.aut");
    if (l.reduce(lts_eq_branching_bisim))
    { cout << "Transition system is succesfully reduced modulo branching bisimulation";
    }
    else 
    { cout << "Reduction failed";
    }

It is also possible to compare an lts to another lts. This can be done
using the equivalence options mentioned above. But it is also possible to
use the following preorders. 

    lts_pre_none:             No preorder 
    lts_pre_sim:              Strong simulation preorder 
    lts_pre_trace:            Strong trace preorder 
    lts_pre_weak_trace:       Weak trace preorder 

Comparing labelled transition systems is done using the reduction algorithms.
This means that the transition systems are destroyed when the comparison is
calculated. To avoid destruction a copy is made of the transition system. But as
transition systems can be extremely large, this is not always desired. Therefore,
we provide a compare function that makes copies of the transition system to 
avoid that they get damaged and a destructive_compare which may change both
transition systems. 

    lts l1("lts1.aut");
    lts l2("lts2.aut");

    if (l1.compare(l2,lts_eq_bisim))    // Non destructive compare.
    { cout << "Transition systems are bisimilar\n";
    }
    else
    { cout << "Transitions systems are not bisimilar";
    }
    
    if (l1.destructive_compare(l2,lts_pre_sim))  // Destructive compare.
    { cout << "Transitions system l1 is strongly simulated by l2";
    }
    else
    { cout << "Lts l1 is not strongly simulated by l2";
    }

[endsect]
[section: Some utility functions]
Explain:
   
   determinise(l);
   reachability_check(l,remove_unreachable);
   is_deterministic(l);
   scc_reduce(l, preserve_divergence_loops);
[section: References]
# [@http://www.mcrl2.org/libref/lts/ LTS reference manual]

[endsect]
