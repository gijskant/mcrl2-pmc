// Date: 01-12-2004
// This document describes the output format of the GenSpect parser. Here:
// - <NumberString> represents a string of the format '"0"|("-"?[1-9][0-9]*)'
// - <String> represents an arbitrary string
// - the other alphabetical strings within angular brackets are non-terminals
//   that represent all possible branches of their productions
// - for non-terminal N, N*/N+ represents an ATermList with zero/one or more N's
// - each c(a_0, ..., a_n), where c is an alphabetical string, represents an
//   ATermAppl with c as its unquoted head and a_0, ..., a_n as its arguments

//General
//-------

//sort identifier
<SortId>     ::= SortId(<String>) 

//data identifier
<DataId>     ::= DataId(<String>, <SortExpr>) 

//action identifier
<ActId>      ::= ActId(<String>, <SortExpr>*) 

//process identifier
<ProcessId>  ::= ProcessId(<String>) 

//data variable
<DataVar>    ::= DataVar(<String>, <SortExpr>) 

//data id or nil
<DataIdOrNil>::= <DataId> | Nil() 

//action id or nil
<ActIdOrNil> ::= <ActId> | Nil() 

//number
<Number>     ::= Number(<NumberString>) 

//Specification
//-------------

//specification
<Spec>       ::= Spec(SortSpec(<SortDecl>*), ConsSpec(<DataDecl>*),
                   MapSpec(<DataDecl>*), EqnSpec(<EqnSect>*),
                   ActSpec(<ActDecl>*), ProcSpec(<ProcDecl>*), Init(<ProcExpr>)
                  )

//sort declaration
<SortDecl>   ::= SortDeclStandard(<SortId>) 
               | SortDeclRef(<SortId>, <SortExpr>) 

//data declaration
<DataDecl>   ::= DataDecl(<DataId>)

//equation section
<EqnSect>    ::= EqnSect(<DataVarDecl>*, <EqnDecl>+) 

//data variable declaration
<DataVarDecl>::= DataVarDecl(<DataVar>)

//equation declaration
<EqnDecl>    ::= EqnDecl(<DataExpr>, <DataExpr>) 

//action declaration
<ActDecl>    ::= ActDecl(<ActId>) 

//process declaration
<ProcDecl>   ::= ProcDecl(<ProcId>, <DataVarDecl>*, <ProcExpr>) 

//Expressions
//-----------

//sort expression
<SortExpr>   ::= <SortId>
               | SortBool() 
               | SortPos() 
               | SortNat() 
               | SortInt() 
               | SortList(<SortExpr>) 
               | SortSet(<SortExpr>) 
               | SortBag(<SortExpr>) 
               | SortArrow(<SortExpr>+, <SortExpr>) 
               | SortStruct(<StructCons>+) 
               | SortUnknown()
               | SortAny()

//constructor declaration of a structured sort
<StructCons> ::= StructCons(<DataId>, <StructProj>*, <DataIdOrNil>) 

//projection declaration of a structured sort
<StructProj> ::= StructProj(<DataIdOrNil>, <SortExpr>+) 

//data expression
<DataExpr>   ::= <DataId>
               | <Number>
               | True() 
               | False() 
               | EmptyList() 
               | EmptySetBag() 
               | ListEnum(<DataExpr>+) 
               | SetEnum(<DataExpr>+) 
               | BagEnum(<BagEnumElt>+) 
               | SetBagComp(<DataVarDecl>, <DataExpr>) 
               | DataAppl(<DataExpr>, <DataExpr>+) 
               | NotOrCompl(<DataExpr>) 
               | Neg(<DataExpr>) 
               | Size(<DataExpr>) 
               | Forall(<DataVarDecl>+, <DataExpr>) 
               | Exists(<DataVarDecl>+, <DataExpr>) 
               | ListAt(<DataExpr>, <DataExpr>) 
               | MultOrIntersect(<DataExpr>, <DataExpr>) 
               | Div(<DataExpr>, <DataExpr>) 
               | Mod(<DataExpr>, <DataExpr>) 
               | AddOrUnion(<DataExpr>, <DataExpr>) 
               | SubtOrDiff(<DataExpr>, <DataExpr>) 
               | LTOrPropSubset(<DataExpr>, <DataExpr>) 
               | GT(<DataExpr>, <DataExpr>) 
               | LTEOrSubset(<DataExpr>, <DataExpr>) 
               | GTE(<DataExpr>, <DataExpr>) 
               | In(<DataExpr>, <DataExpr>) 
               | Cons(<DataExpr>, <DataExpr>) 
               | Snoc(<DataExpr>, <DataExpr>) 
               | Concat(<DataExpr>, <DataExpr>) 
               | Eq(<DataExpr>, <DataExpr>) 
               | Neq(<DataExpr>, <DataExpr>) 
               | And(<DataExpr>, <DataExpr>) 
               | Or(<DataExpr>, <DataExpr>) 
               | Imp(<DataExpr>, <DataExpr>) 
               | Lambda(<DataVarDecl>+, <DataExpr>) 
               | Whr(<DataExpr>, <WhrDecl>+) 

//bag enumeration element
<BagEnumElt> ::= BagEnumElt(<DataExpr>, <DataExpr>) 

//where clause declaration
<WhrDecl>    ::= WhrDecl(<DataVarDecl>, <DataExpr>) 

//process expression
<ProcExpr>   ::= ActProcRef(<String>, <DataExpr>*) 
               | Delta() 
               | Tau() 
               | Sum(<DataVarDecl>+, <ProcExpr>) 
               | Restrict(<MultActId>*, <ProcExpr>) 
               | Allow(<MultActId>*, <ProcExpr>) 
               | Hide(<MultActId>*, <ProcExpr>) 
               | Ren(<RenExpr>*, <ProcExpr>) 
               | Comm(<CommExpr>*, <ProcExpr>) 
               | Sync(<ProcExpr>, <ProcExpr>) 
               | AtTime(<ProcExpr>, <DataExpr>) 
               | Seq(<ProcExpr>, <ProcExpr>) 
               | Cond(<DataExpr>, <ProcExpr>, <ProcExpr>) 
               | BInit(<ProcExpr>, <ProcExpr>) 
               | Merge(<ProcExpr>, <ProcExpr>) 
               | LMerge(<ProcExpr>, <ProcExpr>) 
               | Choice(<ProcExpr>, <ProcExpr>) 

//multiaction identifier
<MultActId>  ::= MultActId(<ActId>+) 

//renaming expression
<RenExpr>    ::= RenExpr(<ActId>, <ActId>) 

//communication expression
<CommExpr>   ::= CommExpr(<MultActId>, <ActIdOrNil>) 
