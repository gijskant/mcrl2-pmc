// Date: 06-12-2004
// This document describes the output format of the GenSpect parser. Here:
// - <NumberString> represents a string of the format '"0"|("-"?[1-9][0-9]*)'
// - <String> represents an arbitrary string
// - the other alphabetical strings within angular brackets are non-terminals
//   that represent all possible branches of their productions
// - for non-terminal N, N*/N+ represents an ATermList with zero/one or more N's
// - each c(a_0, ..., a_n), where c is an alphabetical string, represents an
//   ATermAppl with c as its unquoted head and a_0, ..., a_n as its arguments

//Specification
//-------------

//specification
<Spec>        ::= SpecV1(SortSpec(<SortDecl>*), ConsSpec(<OpDecl>*),
                    MapSpec(<OpDecl>*), EqnSpec(<EqnSect>*),
                    ActSpec(<ActDecl>*), ProcSpec(<ProcDecl>*), Init(<ProcExpr>)
                  )

//sort declaration
<SortDecl>    ::= SortDeclStandard(<String>)
                | SortDeclRef(<String>, <SortExpr>)                       (- ??)

//operation declaration
<OpDecl>      ::= OpDecl(<String>, <SortExpr>)

//equation section
<EqnSect>     ::= EqnSect(<DataVarDecl>*, <EqnDecl>+) 

//data variable declaration
<DataVarDecl> ::= DataVarDecl(<String>, <SortExpr>)

//equation declaration
<EqnDecl>     ::= EqnDecl(<DataExpr>, <DataExpr>) 

//action declaration
<ActDecl>     ::= ActDecl(<String>, <SortExpr>*)

//process declaration
<ProcDecl>    ::= ProcDecl(<String>, <DataVarDecl>*, <ProcExpr>)

//Expressions
//-----------

//sort expression
<SortExpr>    ::= SortId(<String>)
                | SortBool
                | SortPos
                | SortNat
                | SortInt
                | SortList(<SortExpr>)
                | SortSet(<SortExpr>)
                | SortBag(<SortExpr>)
                | SortArrow(<SortExpr>+, <SortExpr>)
                | SortStruct(<StructCons>+)                               (- ??)

//constructor declaration of a structured sort
<StructCons>  ::= StructCons(<String>, <StructProj>*, <StringOrNil>)      (- ??)

//projection declaration of a structured sort
<StructProj>  ::= StructProj(<StringOrNil>, <SortExpr>+)                  (- ??)

//string or nil
<StringOrNil> ::= <String>
                | Nil

//data expression
<DataExpr>    ::= DataVarOpId(<String>)                                   (- tc)
                | DataVar(<String>, <SortExprOrUnknown>)                  (+ tc)
                | OpId(<String>, <SortExprOrUnknown>)                     (+ tc)
                | DataAppl(<DataExpr>, <DataExpr>+) 
                | Number(<NumberString>, <SortExprOrUnknown>)             (- dr)
                | EmptyList(<SortExprOrUnknown>)                          (- dr)
                | EmptySetBag(<SortExprOrUnknown>)                        (- dr)
                | ListEnum(<DataExpr>+, <SortExprOrUnknown>)              (- dr)
                | SetEnum(<DataExpr>+, <SortExprOrUnknown>)               (- dr)
                | BagEnum(<BagEnumElt>+, <SortExprOrUnknown>)             (- dr)
                | SetBagComp(<DataVarDecl>, <DataExpr>)                   (- dr)
                | Forall(<DataVarDecl>+, <DataExpr>)                      (- dr)
                | Exists(<DataVarDecl>+, <DataExpr>)                      (- dr)
                | Lambda(<DataVarDecl>+, <DataExpr>)                      (- dr)
                | Whr(<DataExpr>, <WhrDecl>+)                             (- ??)

//sort expression or unknown
<SortExprOrUnknown>
              ::= <SortExpr> 
                | Unknown                                                 (- tc)

//bag enumeration element
<BagEnumElt>  ::= BagEnumElt(<DataExpr>, <DataExpr>) 

//where clause declaration
<WhrDecl>     ::= WhrDecl(<String>, <DataExpr>)

//process expression
<ProcExpr>    ::= ActProcRef(<String>, <DataExpr>*)                       (- tc)
                | Act(ActId(<String>, <SortExprOrUnknown>*, <DataExpr>*)  (+ tc)
                | ProcRef(ProcId(<String>), <DataExpr>*)                  (+ tc)
                | Delta
                | Tau 
                | Sum(<DataVarDecl>+, <ProcExpr>) 
                | Restrict(<MultActName>*, <ProcExpr>)
                | Allow(<MultActName>*, <ProcExpr>)
                | Hide(<MultActName>*, <ProcExpr>)
                | Ren(<RenExpr>*, <ProcExpr>)
                | Comm(<CommExpr>*, <ProcExpr>)
                | Sync(<ProcExpr>, <ProcExpr>)
                | AtTime(<ProcExpr>, <DataExpr>)
                | Seq(<ProcExpr>, <ProcExpr>)
                | Cond(<DataExpr>, <ProcExpr>, <ProcExpr>) 
                | BInit(<ProcExpr>, <ProcExpr>)
                | Merge(<ProcExpr>, <ProcExpr>)
                | LMerge(<ProcExpr>, <ProcExpr>)
                | Choice(<ProcExpr>, <ProcExpr>)

//multiaction identifier
<MultActName> ::= MultActName(<String>+) 

//renaming expression
<RenExpr>     ::= RenExpr(<String>, <String>) 

//communication expression
<CommExpr>    ::= CommExpr(<MultActName>, <StringOrNil>) 
