// Date: 12-11-2004
// This document describes the output format of the GenSpect parser. Here:
// - <IdString> represents a string of the format '[a-zA-Z_][a-zA-Z0-9_]*'
// - <NumberString> represents a string of the format '"0"|("-"?[1-9][0-9]*)'
// - the other alphabetical strings within angular brackets are non-terminals
//   that represent all possible branches of their productions
// - for non-terminal N, N*/N+ represents an ATermList with zero/one or more N's
// - each c(a_0, ..., a_n), where c is an alphabetical string, represents an
//   ATermAppl with c as its unquoted head and a_0, ..., a_n as its arguments

//General
//-------

//identifier
<Id>         ::= Id(<IdString>) 

//number
<Number>     ::= Number(<NumberString>) 

//identifier declaration
<IdDecl>     ::= IdDecl(<Id>, <SortExpr>) 

//declaration of one or more identifiers of the same sort
<IdsDecl>    ::= IdsDecl(<Id>+, <SortExpr>) 

//id or nil
<IdOrNil>    ::= <Id> | Nil() 

//Specification
//-------------

//specification
<Spec>       ::= Spec(SortSpec(<SortDecl>*), ConsSpec(<IdsDecl>*),
                   MapSpec(<IdsDecl>*), EqnSpec(<EqnSect>*),
                   ActSpec(<ActDecl>*), ProcSpec(<ProcDecl>*), Init(<ProcExpr>)
		 )

//sort declaration
<SortDecl>   ::= SortDeclStandard(<Id>+) 
               | SortDeclRef(<Id>, <SortExpr>) 

//equation section
<EqnSect>    ::= EqnSect(<IdsDecl>*, <EqnDecl>+) 

//equation declaration
<EqnDecl>    ::= EqnDecl(<DataExpr>, <DataExpr>) 

//action declaration
<ActDecl>    ::= ActDecl(<Id>+, <SortExpr>*) 

//process declaration
<ProcDecl>   ::= ProcDecl(<Id>, <IdsDecl>*, <ProcExpr>) 

//Expressions
//-----------

//sort expression
<SortExpr>   ::= <Id>
               | SortBool() 
               | SortPos() 
               | SortNat() 
               | SortInt() 
               | SortList(<SortExpr>) 
               | SortSet(<SortExpr>) 
               | SortBag(<SortExpr>) 
               | SortArrow(<SortExpr>+, <SortExpr>) 
               | SortStruct(<StructCons>+) 

//constructor declaration of a structured sort
<StructCons> ::= StructCons(<Id>, <StructProj>*, <IdOrNil>) 

//projection declaration of a structured sort
<StructProj> ::= StructProj(<IdOrNil>, <SortExpr>+) 

//data expression
<DataExpr>   ::= <Id>
               | <Number>
               | True() 
               | False() 
               | EmptyList() 
               | EmptySetBag() 
               | ListEnum(<DataExpr>+) 
               | SetEnum(<DataExpr>+) 
               | BagEnum(BagEnumElt+) 
               | SetBagComp(<IdDecl>, <DataExpr>) 
               | FuncApp(<DataExpr>, <DataExpr>*) 
               | NotOrCompl(<DataExpr>) 
               | Neg(<DataExpr>) 
               | Size(<DataExpr>) 
               | Forall(<IdsDecl>+, <DataExpr>) 
               | Exists(<IdsDecl>+, <DataExpr>) 
               | ListAt(<DataExpr>, <DataExpr>) 
               | MultOrIntersect(<DataExpr>, <DataExpr>) 
               | Div(<DataExpr>, <DataExpr>) 
               | Mod(<DataExpr>, <DataExpr>) 
               | AddOrUnion(<DataExpr>, <DataExpr>) 
               | SubtOrDiff(<DataExpr>, <DataExpr>) 
               | LTOrPropSubset(<DataExpr>, <DataExpr>) 
               | GT(<DataExpr>, <DataExpr>) 
               | LTEOrSubset(<DataExpr>, <DataExpr>) 
               | GTE(<DataExpr>, <DataExpr>) 
               | In(<DataExpr>, <DataExpr>) 
               | Cons(<DataExpr>, <DataExpr>) 
               | Snoc(<DataExpr>, <DataExpr>) 
               | Concat(<DataExpr>, <DataExpr>) 
               | Eq(<DataExpr>, <DataExpr>) 
               | Neq(<DataExpr>, <DataExpr>) 
               | And(<DataExpr>, <DataExpr>) 
               | Or(<DataExpr>, <DataExpr>) 
               | Imp(<DataExpr>, <DataExpr>) 
               | Lambda(<IdsDecl>+, <DataExpr>) 
               | Whr(<DataExpr>, <WhrDecl>+) 

//bag enumeration element
<BagEnumElt> ::= BagEnumElt(<DataExpr>, <DataExpr>) 

//where clause declaration
<WhrDecl>    ::= WhrDecl(<Id>, <DataExpr>) 

//process expression
<ProcExpr>   ::= ActProcRef(<Id>, <DataExpr>*) 
               | Delta() 
               | Tau() 
               | Sum(<IdsDecl>+, <ProcExpr>) 
               | Restrict(<MAId>*, <ProcExpr>) 
               | Allow(<MAId>*, <ProcExpr>) 
               | Hide(<MAId>*, <ProcExpr>) 
               | Ren(<RenExpr>*, <ProcExpr>) 
               | Comm(<CommExpr>*, <ProcExpr>) 
               | Sync(<ProcExpr>, <ProcExpr>) 
               | AtTime(<ProcExpr>, <DataExpr>) 
               | Seq(<ProcExpr>, <ProcExpr>) 
               | Cond(<DataExpr>, <ProcExpr>, <ProcExpr>) 
               | BInit(<ProcExpr>, <ProcExpr>) 
               | Merge(<ProcExpr>, <ProcExpr>) 
               | LMerge(<ProcExpr>, <ProcExpr>) 
               | Choice(<ProcExpr>, <ProcExpr>) 

//multiaction identifier
<MAId>       ::= MAId(<Id>+) 

//renaming expression
<RenExpr>    ::= RenExpr(<Id>, <Id>) 

//communication expression
<CommExpr>   ::= CommExpr(<MAId>, <IdOrNil>) 
