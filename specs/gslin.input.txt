// Date: 30-11-2004
// This document describes the input format of the GenSpect lineariser. Here:
// - <IdString> represents the name of an identifier by means of a string of
//   the format '[a-zA-Z_][a-zA-Z0-9_]*', where keywords are excluded
// - the other alphabetical strings within angular brackets are non-terminals
//   that represent all possible branches of their productions
// - for non-terminal N, N*/N+ represents an ATermList with zero/one or more N's
// - for non-terminal N, N? represents an zero or one occurrences of N
// - each c(a_0, ..., a_n), where c is an alphabetical string, represents an
//   ATermAppl with c as its unquoted head and a_0, ..., a_n as its arguments
//
// This description uses the theory of higher-order abstract data types, i.e.
// we have a higher-order signature Sigma = (B, O), where B is set of basic
// sorts and O is a set of operations. From the set B, we can generate the set
// of higher-order sorts as follows:
// - the set of basic sorts B is in B->;
// - for all s_0, ..., s_n, s in B->, (s_0 # ... # s_n -> s) is in B->.
// The set O is a B->-sorted set of operations, where each O_s contains
// constants of sort s, for all s in B->.
// The higher-order signature Sigma determines a first-order signature
// Sigma-> = (B->, O extended with Appl), where Appl is the set of operation
// applications.  This set contains the operation apply: (w -> s) # w -> s for
// every w,s in B-> where w = s_0, ..., s_n.
// Because we modelled the set Appl by the data expression DataAppl, the
// description of the data types below is essentially first-order. Also, we
// only use finite subsets of the infinite set of sorts B-> and the infinite set
// of operations O.

//General
//-------

//sort identifier
<SortId>      ::= SortId(<IdString>, <Status>)

//data identifier
<DataId>      ::= DataId(<IdString>, <SortExpr>, <DataStatus>)

//data variable
<DataVar>     ::= DataVar(<IdString>, <SortExpr>, <DataStatus>)

//action identifier
<ActId>       ::= ActId(<IdString>, <Domain>, <Status>)

//domain consisting of zero or more sort expressions
<Domain>      ::= Domain(<SortExpr>, ..., <SortExpr>)

//process identifier
<ProcId>      ::= ProcId(<IdString>, <Status>)

//identifier status
<Status>      ::= StatUser()
                | StatSystem()

//data identifier status
<DataStatus>  ::= <Status>
                | StatLambda()

//Specification
//-------------

//specification
<Spec>        ::= Spec(SortSpec(<SortExpr>*), ConsSpec(<OpDecl>*),
                    MapSpec(<OpDecl>*), EqnSpec(<EqnSect>*),
                    ActSpec(<ActDecl>*), ProcSpec(<ProcDecl>*), Init(<ProcExpr>)
                  )

//operation declaration
<OpDecl>      ::= OpDecl(<DataId>) 

//equation section
<EqnSect>     ::= EqnSect(<DataVarDecl>*, <EqnDecl>+) 

//data variable declaration
<DataVarDecl> ::= DataVarDecl(<DataVar>)

//equation declaration
<EqnDecl>     ::= EqnDecl(<DataExpr>, <DataExpr>, <Status>) 

//action declaration
<ActDecl>     ::= ActDecl(<ActId>)

//process declaration
<ProcDecl>    ::= ProcDecl(<ProcId>, <DataVarDecl>*, <ProcExpr>)

//Expressions
//-----------

//sort expression
<SortExpr>   ::= <SortId>
               | SortBool()
               | SortPos()
               | SortNat()
               | SortInt()
               | SortList(<SortExpr>)
               | SortSet(<SortExpr>)
               | SortBag(<SortExpr>)
               | SortArrow(<SortExpr>+, <SortExpr>)
               | SortStruct(<Id>)
               | SortUnknown()
               | SortAny()

//data expression
<DataExpr>   ::= <DataId>
               | <DataVar>
               | DataAppl(<DataExpr>, <DataArgs>) 
               | Whr(<DataExpr>, <WhrDecl>+) 

//arguments consisting of one or more data expressions
<DataArgs>   ::= <DataExpr>
               | <DataArgs>, <DataExpr>

//where clause declaration
<WhrDecl>    ::= WhrDecl(<DataId>, <DataExpr>) 

//process expression
<ProcExpr>   ::= Action(<ActId>, <Arguments>?)
               | ProcRef(<ProcId>, <Arguments>?) 
               | Delta() 
               | Tau() 
               | Sum(<VarDecl>+, <ProcExpr>) 
               | Restrict(<MAId>*, <ProcExpr>) 
               | Allow(<MAId>*, <ProcExpr>) 
               | Hide(<MAId>*, <ProcExpr>) 
               | Ren(<RenExpr>*, <ProcExpr>) 
               | Comm(<CommExpr>*, <ProcExpr>) 
               | Sync(<ProcExpr>, <ProcExpr>) 
               | AtTime(<ProcExpr>, <DataExpr>) 
               | Seq(<ProcExpr>, <ProcExpr>) 
               | Cond(<DataExpr>, <ProcExpr>, <ProcExpr>) 
               | BInit(<ProcExpr>, <ProcExpr>) 
               | Merge(<ProcExpr>, <ProcExpr>) 
               | LMerge(<ProcExpr>, <ProcExpr>) 
               | Choice(<ProcExpr>, <ProcExpr>) 

//multiaction identifier
<MAId>       ::= MAId(<ActId>+) 

//renaming expression
<RenExpr>    ::= RenExpr(<ActId>, <ActId>) 

//communication expression
<CommExpr>   ::= CommExpr(<MAId>, <ActIdOrNil>) 

//action identifier or nil
<ActIdOrNil>    ::= <ActId> | Nil() 
