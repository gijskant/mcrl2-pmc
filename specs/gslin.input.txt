// Date: 18-11-2004
// This document describes the input format of the GenSpect lineariser. Here:
// - <UIdString> represents a user identifier by means of a string of the
//   format '[a-zA-Z_][a-zA-Z0-9_]*', where keywords are excluded
// - <SIdString> represents a system identifier by means of a string; possible
//   values are described in the articles/sids.tex
// - the other alphabetical strings within angular brackets are non-terminals
//   that represent all possible branches of their productions
// - for non-terminal N, N*/N+ represents an ATermList with zero/one or more N's
// - for non-terminal N, N? represents an zero or one occurrences of N
// - each c(a_0, ..., a_n), where c is an alphabetical string, represents an
//   ATermAppl with c as its unquoted head and a_0, ..., a_n as its arguments
//
// This description uses the theory of higher-order abstract data types, i.e.
// we have a higher-order signature Sigma = (B, O), where B is set of basic
// sorts and O is a set of operations. From the set B, we can generate the set
// of higher-order sorts as follows:
// - the set of basic sorts B is in B->;
// - for all s_0, ..., s_n, s in B->, (s_0 # ... # s_n -> s) is in B->.
// The set O is a B->-sorted set of operations, where each O_s contains
// constants of sort s, for all s in B->.
// The higher-order signature Sigma determines a first-order signature
// Sigma-> = (B->, O extended with Appl), where Appl is the set operation
// applications.  This set contains the operation apply: (w -> s) # w -> s for
// every w,s in B-> where w = s_0, ..., s_n.
// Because we modelled the set Appl operations by the data expression DataAppl,
// the description of the data types below is essentially first-order. Also,
// we only use a finite subsets of the infinite set of sorts B-> and set of
// operations O.

//General
//-------

//user identifier
<UId>        ::= UId(<UIdString>) 

//system identifier
<SId>        ::= SId(<SIdString>) 

//identifier
<Id>         ::= <UId> | <SId>

//user variable occurrence
<UVar>        ::= UVar(<UIdString>)

//system variable occurrence
<SVar>        ::= SVar(<SIdString>)

//variable occurrence
<Var>         ::= <UVar> | <SVar>

//Specification
//-------------

//specification
<Spec>       ::= Spec(SortSpec(<SortExpr>*), ConsSpec(<OpDecl>*),
                   MapSpec(<OpDecl>*), EqnSpec(<EqnSect>*),
                   ActSpec(<ActDecl>*), ProcSpec(<ProcDecl>*), Init(<ProcExpr>)
                 )

//operation declaration
<OpDecl>     ::= OpDecl(<Id>, <SortExpr>) 

//equation section
<EqnSect>    ::= EqnSect(<VarDecl>*, <EqnDecl>+) 

//variable declaration
<VarDecl>    ::= VarDecl(<Id>, <SortExpr>)

//equation declaration
<EqnDecl>    ::= EqnDecl(<DataExpr>, <DataExpr>) 

//action declaration
<ActDecl>    ::= ActDecl(<Id>, <Domain>?)

//domain consisting of one or more sort expressions
<Domain>     ::= <SortExpr>
               | <Domain>, <SortExpr>

//process declaration
<ProcDecl>   ::= ProcDecl(<Id>, <VarDecl>*, <ProcExpr>) 

//Expressions
//-----------

//sort expression
<SortExpr>   ::= <Id>
               | SortApp(<SortExpr>, <SortArgs>)

//arguments consisting of one or more sort expressions
<SortArgs>   ::= <SortExpr>
               | <SortArgs>, <SortExpr>

//data expression
<DataExpr>   ::= <Id>
               | <Var>
               | DataApp(<DataExpr>, <DataArgs>) 
               | Whr(<DataExpr>, <WhrDecl>+) 

//arguments consisting of one or more data expressions
<DataArgs>   ::= <DataExpr>
               | <DataArgs>, <DataExpr>

//where clause declaration
<WhrDecl>    ::= WhrDecl(<Id>, <DataExpr>) 

//process expression
<ProcExpr>   ::= Action(<Id>, <Arguments>?)
               | ProcRef(<Id>, <Arguments>?) 
               | Delta() 
               | Tau() 
               | Sum(<VarDecl>+, <ProcExpr>) 
               | Restrict(<MAId>*, <ProcExpr>) 
               | Allow(<MAId>*, <ProcExpr>) 
               | Hide(<MAId>*, <ProcExpr>) 
               | Ren(<RenExpr>*, <ProcExpr>) 
               | Comm(<CommExpr>*, <ProcExpr>) 
               | Sync(<ProcExpr>, <ProcExpr>) 
               | AtTime(<ProcExpr>, <DataExpr>) 
               | Seq(<ProcExpr>, <ProcExpr>) 
               | Cond(<DataExpr>, <ProcExpr>, <ProcExpr>) 
               | BInit(<ProcExpr>, <ProcExpr>) 
               | Merge(<ProcExpr>, <ProcExpr>) 
               | LMerge(<ProcExpr>, <ProcExpr>) 
               | Choice(<ProcExpr>, <ProcExpr>) 

//multiaction identifier
<MAId>       ::= MAId(<Id>+) 

//renaming expression
<RenExpr>    ::= RenExpr(<Id>, <Id>) 

//communication expression
<CommExpr>   ::= CommExpr(<MAId>, <IdOrNil>) 

//id or nil
<IdOrNil>    ::= <Id> | Nil() 
