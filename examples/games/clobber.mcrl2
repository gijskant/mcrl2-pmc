% This specification describes the game `Clobber', which is a two
% player board game. There is a board of 8 by 8 (although below
% we describe a board of 4 by 4, as otherwise the state space is
% prohibitively big). One player has white pieces  (0) and the other has
% black pieces (X). Initially, the board is set up as:
% 
%      0 X 0 X 0 X 0 X
%      X 0 X 0 X 0 X 0
%      0 X 0 X 0 X 0 X
%      X 0 X 0 X 0 X 0
%      0 X 0 X 0 X 0 X
%      X 0 X 0 X 0 X 0
%      0 X 0 X 0 X 0 X
%      X 0 X 0 X 0 X 0
% 
% Black makes the first move and players alternatingly make a move. A 
% player makes a turn by moving a piece
% of its own color horizontally or vertically to a position with a piece
% of the opposite color and it removes that piece. This is the only move
% that is allowed. The first player that cannot do a move looses the game.
%
% Thanks go to Mark Winands for explaining the game.
%
% Reijkjavik, May 9, 2006, Jan Friso Groote

sort Position = struct Black | White | Empty;
     Direction = struct Up | Right | Down | Left;

map N:Pos;
eqn N=4;

sort Row=List(Position);
     Board=List(Row);
map  At:Board#Pos#Pos->Position;
     At:Board#Pos#Pos#Direction->Position;
     At:Row#Pos->Position;
     Put:Position#Board#Pos#Pos->Board;
     Put:Position#Board#Pos#Pos#Direction->Board;
     Put:Position#Row#Pos->Row;

var b:Board;
    r:Row;
    p,p':Position;
    x,y:Pos;
eqn At(b,x,y,Up)=At(b,x,y+1);
    At(b,x,y,Right)=At(b,x+1,y);
    y>1 -> At(b,x,y,Down)=At(b,x,Int2Pos(y-1));
           At(b,x,1,Down)=Empty;
    x>1 -> At(b,x,y,Left)=At(b,Int2Pos(x-1),y);
           At(b,1,y,Left)=Empty;
    At([],x,y)=Empty;
    At(r|>b,1,y)=At(r,y);
    x>1 -> At(r|>b,x,y)=At(b,Int2Pos(x-1),y);
    At([],y)=Empty;
    At(p|>r,1)=p;
    y>1 -> At(p|>r,y)=At(r,Int2Pos(y-1));
    Put(p,b,x,y,Up)=Put(p,b,x,y+1);
    Put(p,b,x,y,Right)=Put(p,b,x+1,y);
    y>1 -> Put(p,b,x,y,Down)=Put(p,b,x,Int2Pos(y-1));
    x>1 -> Put(p,b,x,y,Left)=Put(p,b,Int2Pos(x-1),y);
    Put(p,r|>b,1,y)=Put(p,r,y)|>b;
    x>1 -> Put(p,r|>b,x,y)=r|>Put(p,b,Int2Pos(x-1),y);
    Put(p,p'|>r,1)=p|>r;
    y>1 -> Put(p,p'|>r,y)=p'|>Put(p,r,Int2Pos(y-1));

act WhiteMove,BlackMove:Pos#Pos#Direction;

proc Clobber(b:Board,WhiteMoves:Bool)=
       sum x,y:Pos, dir:Direction.
                    (WhiteMoves && 
                     x<=N && y<=N &&
                     At(b,x,y)==White && 
                     At(b,x,y,dir)==Black)->
           WhiteMove(x,y,dir).Clobber(Put(White,Put(Empty,b,x,y),x,y,dir),false)+
       sum x,y:Pos, dir:Direction.
                    (!WhiteMoves && 
                     x<=N && y<= N &&
                     At(b,x,y)==Black && 
                     At(b,x,y,dir)==White)->
           BlackMove(x,y,dir).Clobber(Put(Black,Put(Empty,b,x,y),x,y,dir),true);

init Clobber([[Black,White,Black,White],
              [White,Black,White,Black],
              [Black,White,Black,White],
              [White,Black,White,Black]],false);
