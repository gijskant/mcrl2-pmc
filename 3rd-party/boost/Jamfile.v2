import modules ;
import stage ;
import set ;
import package ;
import common ;

constant BOOST_VERSION : 1.33.1 ;

project boost
       : build-dir $(TOP)/bin 
       : requirements
          <include>.
          <include>$(BOOST_ROOT)
          <define>BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS=1
          <define>BOOST_ALL_NO_LIB=1
          <tag>@$(__name__).tag
       : usage-requirements
          <include>$(BOOST_ROOT)
          <define>BOOST_MPL_CFG_NO_PREPROCESSED_HEADERS=1
          <define>BOOST_ALL_NO_LIB=1
       ;

# This rule is called by Boost.Build to determine the name of  
# target. We use it to encode build variant, compiler name and 
# boost version in the target name  
rule tag ( name : type ? : property-set ) {
  if $(type) in STATIC_LIB SHARED_LIB IMPORT_LIB {
    if $(layout) = versioned {
      local result = [ common.format-name
          <base> <toolset> <threading> <runtime> -$(BOOST_VERSION_TAG)
          : $(name) : $(type) : $(property-set) ] ;
      
      # Optionally add version suffix.
      # On NT, library with version suffix won't be recognized
      # by linkers. On CYGWIN, we get strage duplicate symbol
      # errors when library is generated with version suffix.
      # On OSX, version suffix is not needed -- the linker expets
      # libFoo.1.2.3.dylib format.
      # AIX linkers don't accept version suffixes either.
      if $(type) = SHARED_LIB &&
        ! ( [ $(property-set).get <target-os> ] in windows cygwin darwin aix ) {
        result = $(result).$(BOOST_VERSION)  ;
      }
      
      return $(result) ;
    }
    else {
      return [ common.format-name
        <base> <threading> <runtime>
        : $(name) : $(type) : $(property-set) ] ;
    }
  }
}

libraries = [ MATCH .*libs/(.*)/build/.* : [ glob libs/*/build/Jamfile.v2 ] ] ;

# Make project ids of all libraries known.
for local l in $(libraries) {
  use-project /boost/$(l) : libs/$(l)/build ;

  alias $(l) : libs/$(l)/build//boost_$(l) : : : ;
}

alias headers : : : : ;
