\documentclass[a4paper,10pt]{article}
\usepackage{textcomp,amsmath,amssymb,amsthm,stmaryrd}
\usepackage{geometry}
\usepackage{mymath,mythm}
\usepackage{algorithm,algorithmic}

\theoremstyle{plain}
\newtheorem{thmfs}{Theorem}[section]
\theoremstyle{definition}
\newtheorem{tcase}[thmfs]{Test case}

\newcommand{\mcrl}{mCRL2}
\newcommand{\lpe}{linear process equation}
\newcommand{\tool}{\textit{lpeparelm}}
\newcommand{\ti}{\textit}
\newcommand{\tb}{\textbf}

\newcommand{\ovr}{\overrightarrow}

\newcommand{\pp}{process parameter}
\newcommand{\pps}{process parameters}
\newcommand{\framework}{\textit{LPE framework} \cite{LPEframework}}

\newcommand{\bisim}{\frac{\leftrightarrow}{}}

\newcommand{\tab}{\hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm}  \= \hspace*{5.mm}  \= \hspace*{5.mm}  \= \hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm}  \= \hspace*{5.mm}  \= \hspace*{5.mm}\kill}

\newcommand{\tabw}{\hspace*{15.mm} \= \hspace*{20.mm} \= \hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm}  \= \hspace*{5.mm}  \= \hspace*{5.mm}  \= \hspace*{5.mm} \= \hspace*{5.mm} \= \hspace*{5.mm}  \= \hspace*{5.mm}  \= \hspace*{5.mm}\kill}

\font \aap cmmi10        
\newcommand{\at}[1]{\mbox{\aap ,} #1}

%opening
\title{lpeparelm\\DRAFT}
\author{F.P.M.Stappers}

\begin{document}

\maketitle

\begin{abstract}
This documentation describes the usage and implementation of the tool \tool\ within the \mcrl\ toolset.
Basically, \tool\ is a tool which removes unused \pp\ and unused sum variables, from a \lpe\ (LPE).
\end{abstract}

\tableofcontents

\section{Introduction}
This \tool\ tool is a tool for the \mcrl\ studio. The tool is a
filter which reads from a \ti{input.lpe}. The file \ti{input.lpe} is
a file in \ti{.lpe} format \cite{LPEformat}. We use the
\framework\ to read the \ti{input.lpe}. The filter removes \pps\ and sum variables, which are not used, from the
\lpe . After the algorithm (Section \ref{sec:alg}) terminates, \tool\
will write the output to an output file \ti{output.lpe} in the \ti{.lpe} format \cite{LPEformat}.

\section{Definitions} \label{sec:def}

The equation below is a \lpe\ in \mcrl : 
\begin{defn}\lpe\ (LPE) \newline
%\at werkt niet
\begin{tabbing}
\tab
$X (\ovr{d: D}) = $ \> \> \> $ \sum_{i \in I} \sum_{\ovr{e_i: E_i}} \ovr{c_i} ( \ovr{d, e_i }) \rightarrow 
(a_i^1 (\ovr{f_{i,1}}(\ovr{d,e_i})) \vert \ldots \vert a_i^{n(i)}(\ovr{f_{i,n(i)}}(\ovr{d,e_i}))) \at \text{ } t_i(\ovr{d,e_i})  \cdot X(\ovr{g_i}(\ovr{d,e_i})) +$ \\ \\
\> \> \> $ \sum_{j \in j} \sum_{\ovr{e_j: E_j}} \ovr{c_j} ( \ovr{d, e_j} ) \rightarrow 
(a_j^1 (\ovr{f_{j,1}}(\ovr{d,e_j})) \vert \ldots \vert a_j^{n(j)}(\ovr{f_{j,n(j)}}(\ovr{d,e_j}))) \at \text{ } t_j(\ovr{d,e_j}) + $ \\ \\
\> \> \> $\sum_{\ovr{e_\delta}:\ovr{E_\delta}} \ovr{c_\delta} ( \ovr{d, e_\delta}) \rightarrow 
\delta \at \text{ } t_\delta(\ovr{d,e_\delta})$ 
\end{tabbing}

Where $I$ and $J$ are disjoint.\\
\end{defn}

If we speak about an LPE in this article we refer to Definition \ref{def}.  The different states 
%are $\ovr{d}$ 
of the process are represented by the data vector parameter $\ovr{d}:\ovr{D}$. $\ovr{D}$ may be a Cartesian product of $n$ data types, meaning that $\ovr{d}$ consist of a tuple $(d_1, \ldots, d_n)$. The LPE expresses that in state $\ovr{d}$ it performs (multi)actions $\lbrace a_i^1, \ldots , a_i^{n(i)} \rbrace$, carrying data parameters $\ovr{f_{i,1}}(\ovr{d,e_i}), \ldots , \ovr{f_{i,n(i)}}(\ovr{d, e_i})$ and 
it can reach the new state $\ovr{g_i}(\ovr{d ,e_i})$ under the condition that $c_i(\ovr{d , e_i})$ is \ti{true}. So for each summand $i$ from $I$ we have a function $\ovr{g_i}: \ovr{D} \times \ovr{E_i} \rightarrow \ovr{D}$ and a function $c_i: \ovr{D} \times \ovr{E_i} \rightarrow \mathbb{B}$.
Data parameters $\ovr{e_i : E_i}$ are sum variables. These variables are used to action range over a data domain. 

For an more detailed explanation of \lpe s  we refer to \cite{LPE_info}.
%\end{defn}

\section{Definition}
A parameter of an LPE has which has no influence on condition, action and time arguments is removed from the LPE in the \tool filter. Elimination of parameters can lead to a reduction when generating a state space of an LPE. If a \pp\ ranges over an infinite domain, the number of generated states can even be reduced to a finite domain, using this operation. %This typically happens after hiding parts of a specification.

%Let $1 \leq m \leq n$;
%We define the original vector as $\ovr{p}$:\\
%$\ovr{p} = \langle p_1, \ldots, p_n \rangle$\\
%We define the derived vector from $\ovr{p}$ as $\ovr{p'}$: \\
%$\ovr{p'} = \langle p_1', \ldots, p_m' \rangle$\\
%For which holds:\\
%$\forall_{i: 1 \leq i \leq m}\exists_{j: \leq j \leq n}(p_i'= p_j) $\\

%\begin{defn} Let $S$ be the set of indices of a vector.\\ 
%We define $\ovr{v'}_S$:\\
%$$\ovr{v'}_S = \ovr{v} \setminus S$$
%Explanation: If an index $j$ occurs in $S$ the new constructed $\ovr{v'}_S$ does not contains $v_j$.
%\end{defn}

\begin{defn}
Let $\ovr{x}$ be a vector and  $n$ be $\vert \ovr{x} \vert$. If we want to adress the $j^{th}$ element ($ 1 \leq j \leq \vert x \vert $) of vector $\ovr{x}$, the do so by:
$\ovr{x}._j$
\end{defn}

\begin{defn}
We define $\ovr{vect^i}$;\\
$\ovr{vect^i} = 
( \ovr{d}._1:\ovr{D}._1 , \ldots , \ovr{d}._k: \ovr{D}._k , \ovr{e}._{i_{(k+1)}}:\ovr{E}._{i_{(k+1)}} , \ldots , e_{i_{(k+z)}}:E_{i_{(k+z)}} ) $\\
where $k = \vert \ovr{d} \vert$ and $z = \vert \ovr{e_i} \vert$. The length of $ \vert \ovr{vect^i} \vert = n$, which is equal to $k + z$.
\end{defn}

\begin{defn} Let $S$ be the set of inert \pps\ indices, let $I \cap J = \emptyset $:
\begin{tabbing}
\tab
$S = \lbrace s \in \lbrace 1, \ldots n \rbrace \vert$ 
$\forall_{\ovr{vert^i}._s}($  \\
\> \>$\sum_{i \in I} \sum_{\ovr{e_i:E_i}} c_i ( \ovr{vect^i} ) \rightarrow $
$ a_i^1 (\ovr{f_{i,1}}(\ovr{vect^i})) \vert \ldots \vert a_i^{n(i)}(\ovr{f_{i,n(i)}}(\ovr{vect^i})) \at \text{ } t_i(\ovr{vect^i})  \cdot X(\ovr{g_i}(\ovr{vect^i}))
$ \\
\> \> $+ \sum_{j \in J} \sum_{\ovr{e_j:E_j}} c_j ( \ovr{vect^j} ) \rightarrow $
$ a_j^1 (\ovr{f_{j,1}}(\ovr{vect^j})) \vert \ldots \vert a_j^{n(j)}(\ovr{f_{j,n(j)}}(\ovr{vect^j})) \at \text{ } t_j(\ovr{vect^j})
$ \\
\> \> $ + \sum_{\ovr{e_\delta:E_\delta}} c_\delta ( \ovr{d, e_\delta}) \rightarrow 
\delta \at \text{ } t_\delta(\ovr{vect^{\delta}})$ \\

\> $\bisim$ \\

\> \>$\sum_{i \in I} \sum_{\ovr{e_i:E_i}} c_i ( \ovr{vect^i}._s ) \rightarrow $
$ a_i^1 (\ovr{f_{i,1}}(\ovr{vect^i}._s)) \vert \ldots \vert a_i^{n(i)}(\ovr{f_{i,n(i)}}(\ovr{vect^i}._s)) \at \text{ } t_i(\ovr{vect^i._s})  \cdot X(\ovr{g_i}(\ovr{vect^i}._s))
$ \\
\> \> $+ \sum_{j \in J} \sum_{\ovr{e_j:E_j}} c_j ( \ovr{vect^j}._s ) \rightarrow $
$ a_j^1 (\ovr{f_{j,1}}(\ovr{vect^j}._s)) \vert \ldots \vert a_j^{n(j)}(\ovr{f_{j,n(j)}}(\ovr{vect^j}._s)) \at \text{ } t_j(\ovr{vect^j}._s)
$ \\
\> \> $ + \sum_{\ovr{e_\delta:E_\delta}} c_\delta ( \ovr{d, e_\delta}) \rightarrow 
\delta \at \text{ } t_\delta(\ovr{vect^{\delta}}._s)$\\
$)$ \\
\end{tabbing}
\end{defn}

\section{Proof}


\section{Description}
In this section we describe the algorithm informally. Throughout the run of the algorithm \pps\ get marked if they are used in an action, time or condition. Process parameters which are dependant of other marked \pps\ also get marked. If a \pp\ gets marked it should not be removed. Initally, all parameters in the LPE are unmarked. After the algorithm terminates all unmarked \pps\ are removed. A \pp\ gets marked if it occurs in one of the following places:

\begin{itemize}
\item In a condition: $c_i(\ovr{vect^i})$ for some $i \in I$
\item In an action argument: $a_i^j(\ovr{f_{i,j}}(\ovr{vect^i})$ for some $i \in I$ and $j \in \lbrace 1, \ldots , n \rbrace$
\item In a time argument: $t_i(\ovr{vect^i})$ for some $i \in I$
\item In an argument: $\ovr{g_i}(\ovr{vect^i})_j$ for some $i \in I$ and $j \in \lbrace 1, \ldots , n \rbrace $ where the $j$-th \pp\ is marked.
\end{itemize}

\newpage
\section{Algorithm} \label{sec:alg}
\begin{algorithm}[h]
\caption{lpeparelm}
\begin{algorithmic}[1]
\STATE $S := \lbrace 1 \ldots n \rbrace;$
\STATE $UsedPP := \emptyset $
  \FORALL{$i \in I$}
    \STATE $UsedPP = UsedPP \cup FindUsedPP(\ovr{c_i}(\ovr{vect^i}));$
    \FOR{$j := 1$ to $n(i) $}
      \STATE $UsedPP = UsedPP \cup FindUsedPP(a_i^{j}(\ovr{f_{i,j}}(\ovr{vect^i}));$
    \ENDFOR
    \STATE $UsedPP = UsedPP \cup FindUsedPP(\ovr{t_i}(\ovr{vect^i}));$
  \ENDFOR
\STATE $Change = true;$
\WHILE{$Change$}
\STATE $Change = false;$
  \FORALL{$ i \in I$}
    \FORALL{$j := 1$ to $ n $}
      \IF{$(\ovr{g_i}(\ovr{vert^i})._j ) \in UsedPP$}
        \IF{$ FindUsedPP(\ovr{g_i}(\ovr{vert^i})._j ) > 0 $}
          \STATE $UsedPP = UsedPP \cup FindUsedPP(\ovr{g_i}(\ovr{vert^i})._j) ;$
          \STATE $Change = true;$
        \ENDIF
      \ENDIF
    \ENDFOR
  \ENDFOR
\ENDWHILE
\STATE $S := S \setminus UsedPP;$
\end{algorithmic}
\line(1,0){120}
\begin{tabbing}
\tab
$UsedPP$ \> \> \> \> : \> The set of indices of used \pps .\\
$FindUsedPP$ \> \> \> \> : \> A routine which returns a set of indices of used\\
\> \> \> \> \> \pps\ which occure in a given argument.
\end{tabbing}
\end{algorithm}

\newpage
\section{Test Cases}
All specifications are given in \mcrl\ specification.
Transformation from a \mcrl\ specification to an LPE file is done with the tool:
$mcrl22lpe$. Each transformation is executed with the \verb"-no-cluster" option, unless
mentioned otherwise.

\subsection*{Case 1}
inputfile: \verb"$DIR$/tests/lpeparelm/case1.mcrl2"
\begin{tabbing}
\tabw
\ti{info} \> This case test will show if if the \tool\ works without condition, action and time arguments.\\
\line(1,0){120}\\
\tb{act} \> a; \\
\tb{proc} \> X(i:Nat) = \> a.X(i)\\
\tb{init} \> X(2); \\  
\line(1,0){120}\\
\ti{Result} \> Process parameter $i$ should be removed.\\ 
\end{tabbing}

\subsection*{Case 2}
inputfile: \verb"$DIR$/tests/lpeparelm/case2.mcrl2"
\begin{tabbing}
\tabw
\ti{info} \> This case test will show if if the \tool\ works with an action argument.\\
\line(1,0){120}\\
\tb{act} \> a: Nat; \\
\tb{proc} \> X(i,j:Nat) = \> a(i). X(i,j)\\
\tb{init} \> X(0,1); \\  
\line(1,0){120}\\
\ti{Result} \> Process parameter $j$ should be removed.\\ 
\end{tabbing}

\subsection*{Case 3}
inputfile: \verb"$DIR$/tests/lpeparelm/case3.mcrl2"
\begin{tabbing}
\tabw
\ti{info} \> This case test will show if if the \tool\ works with a condition argument.\\
\line(1,0){120}\\
\tb{act} \> a; \\
\tb{proc} \> X(i,j:Nat) = \> (i == 5 ) $\rightarrow$ a. X(i,j)\\
\tb{init} \> X(0,1); \\  
\line(1,0){120}\\
\ti{Result} \> Process parameter $j$ should be removed.\\ 
\end{tabbing}

\subsection*{Case 4}
inputfile: \verb"$DIR$/tests/lpeparelm/case4.mcrl2"
\begin{tabbing}
\tabw
\ti{info} \> This case test will show if if the \tool\ works with a time argument.\\
\line(1,0){120}\\
\tb{act} \> a; \\
\tb{proc} \> X(i,j:Nat) = \> a$@$i. X(i,j)\\
\tb{init} \> X(0,4); \\  
\line(1,0){120}\\
\ti{Result} \> Process parameter $j$ should be removed.\\ 
\end{tabbing}

\subsection*{Case 5}
inputfile: \verb"$DIR$/tests/lpeparelm/case5.mcrl2"
\begin{tabbing}
\tabw
\ti{info} \> This case test will show if if the \tool\ works to check if inert \pps\ are dependant of other \pps .\\
\line(1,0){120}\\
\tb{act} \> a: Nat ; \\
\tb{act} \> b; \\
\tb{proc} \> X(i,j:Nat) = \> a(i).X(k,j,k) + \\
          \> \>              b.X(j,j,k);\\
\tb{init} \> X(1,2,3); \\  
\line(1,0){120}\\
\ti{Result} \> Process parameter $j$ should be removed.\\ 
\end{tabbing}

\subsection*{Case 6}
inputfile: \verb"$DIR$/tests/lpeparelm/case6.mcrl2"
\begin{tabbing}
\tabw
\ti{info} \> This case test will show how the tool reacts on free variables and multiple summands.\\
\line(1,0){120}\\
\tb{act} \> act1, act2, act3: Nat; \\
\tb{proc} \> X(i: Nat) \>  = \> (i \verb"<" 5) $\rightarrow$ act1(i).X(i+1) + \\
\> \> \>     (i == 5) $\rightarrow$ act3(i).Y(i, i); \\
\>     Y(i,j: Nat) \> = \> act2(j).Y(i,j+1); \\
\tb{init} X(0); \\
\line(1,0){120}\\
\ti{Result} \> No \pp\ should be removed.\\ 
\line(1,0){120}\\
\ti{Genarated LPE} \\
\>  \verb"var  freevar0: Nat;"\\
\>  \verb"proc P(s3: Pos, i,j: Nat)"\\
\>  \verb" (s3 == 1 && i < 5) ->"\\
\>  \verb"   act1(i) ."\\
\>  \verb"   P(s3 := 1, i := i + 1, j := freevar0)"\\
\>  \verb"+ (s3 == 1 && i == 5) ->"\\
\>  \verb"   act3(i) ."\\
\>  \verb"   P(s3 := 2, j := i)"\\
\>  \verb"+ (s3 == 2) ->"\\
\>  \verb"   act2(j) ."\\
\>  \verb"   P(s3 := 2, j := j + 1);"\\
\\
\>  \verb"var  freevar: Nat;"\\
\>  \verb"init P(s3 := 1, i := 0, j := freevar);"\\
\end{tabbing}

\subsection*{Case 7}
inputfile: \verb"$DIR$/tests/lpeparelm/case7.mcrl2"
\begin{tabbing}
\tabw
\ti{info} \> This case test will show how the tool reacts on time, actions, conditions, multiple \\
	\> summands and depandant \pps of an inert.\\
\line(1,0){120}\\
\tb{act}  \> act1, act2, act3: Nat;\\
\tb{proc} \> X(i,z,j: Nat) \>    = \>  (i \verb"<"  5) $\rightarrow$ act1(i)$@$z.X(i+1,z, j) +\\
          \>               \>  \> (i == 5) $\rightarrow$ act3(i).X(i, j, 4); \\
\tb{init} X(0,5, 1);\\
\line(1,0){120}\\
\ti{Result} \> No \pp\ should be removed.\\ 
\line(1,0){120}\\
\ti{Genarated LPE} \\
\>  \verb" proc P(i,z,j: Nat) ="\\
\>  \verb"       (i == 5) ->"\\
\>  \verb"         act3(i) ."\\
\>  \verb"         P(z := j,j := 4)"\\
\>  \verb"     + (i < 5) ->"\\
\>  \verb"         act1(i) @ Nat2Real(z) ."\\
\>  \verb"         P(i := i + 1);"\\
\\
\>  \verb" init P(i := 0, z := Pos2Nat(5), j := Pos2Nat(1));"\\
\end{tabbing}

\subsection*{Case 8}
inputfile: \verb"$DIR$/tests/lpeparelm/case7.mcrl2"
\begin{tabbing}
\tabw
\ti{info} \> This case test will show how the tool reacts on time, actions, conditions, multiple \\
	\> summands and depandant \pps of an inert.\\
\line(1,0){120}\\
\tb{act}  \> act1, act2, act3: Nat;\\
\tb{proc} \> X(i,z,j: Nat) \>    = \>  (i \verb"<"  5) $\rightarrow$ act1(i)$@$z.X(i+1,z, j) +\\
          \>               \>  \> (i == 5) $\rightarrow$ act3(i).X(i, j, 4); \\
\tb{init} X(0,5, 1);\\
\line(1,0){120}\\
\ti{Result} \> No \pp\ should be removed.\\ 
\line(1,0){120}\\
\ti{Genarated LPE} \\
\>  \verb" var  freevar0: Nat;     "               \\                %%
\>  \verb" proc P(s3: Pos, i,j: Nat) ="              \\              %%
\>  \verb"         (s3 == 2) ->        "               \\             %%
\>  \verb"           action(j) .        "                \\           %%
\>  \verb"          P(s3 := 2, j := j + 1)"                \\        %%
\>  \verb"       + (s3 == 1 && i < 5) ->   "                 \\       %%
\>  \verb"           action(i) .            "                  \\     %%
\>  \verb"            P(s3 := 1, i := i + 1, j := freevar0)"     \\   %%
\>  \verb"      + (s3 == 1 && i == 5) -> "                         \\%%
\>  \verb"           action(i) . "                 \\                 %%
\>  \verb"           P(s3 := 2, j := i);"            \\               %%
\>  \verb"       "                                     \\             %%
\>  \verb"  var  freevar: Nat;"                          \\           %%
\>  \verb"  init P(s3 := 1, i := 0, j := freevar);"        \\         %%
\end{tabbing}

\begin{thebibliography}{99}  \bibitem{LPE_info} auteur\\
   \textit{article},
   Extra info.
  \bibitem{LPEframework} J.W. Wesselink,
   \textit{http://www.win.tue.nl/~wieger/mcrl2/html/index.html}\\
   A C++ wrapper for the ATerm library.
\bibitem{LPEformat} Aad Mathijssen\\
   \textit{https://svn.win.tue.nl/viewcvs-checkout/MCRL2/trunk/specs/mcrl2.internal.txt},
   A description of the internal format of the mCRL2 language.
  \bibitem{LPEfreevar} auteur,
   \textit{article}
   Extra info.
  \bibitem{lin} J.F. Groote,
   \textit{linear}
   Extra info.

\end{thebibliography}

\end{document}
