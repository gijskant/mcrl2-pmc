\documentclass[a4paper,10pt]{article}
\usepackage{textcomp,amsmath,amssymb,amsthm}%,stmaryrd}
%\usepackage{geometry}
%\usepackage[ps2pdf]{hyperref} % remove for printing
%\usepackage[active]{srcltx}
\usepackage{mymath,mythm}

\newcommand{\lpe}{linear process equation}
\newcommand{\tool}{\textit{lpeconstelm}}
\newcommand{\ovr}{\overrightarrow}
\newcommand{\mcrl}{$\mu$CRL2}
\newcommand{\framework}{\textit{LPE framework} \cite{LPEframework}}
\newcommand{\pp}{process parameter}
\newcommand{\pps}{process parameters}
\newcommand{\ti}{\textit}
\newcommand{\tb}{\textbf}
\newcommand{\sv}{\textit{state vector}}
\newcommand{\fv}{\textit{flag vector}}
\newcommand{\svs}{\textit{new state vector set}}
\newcommand{\fvs}{\textit{new flag vector set}}
\newcommand{\la}{$\leftarrow$}
\newcommand{\ra}{$\rightarrow$}
\newcommand{\sq}{$\square$}

\newcommand{\csvs}{new\_state\_vector\_set}
\newcommand{\cfvs}{new\_flag\_vector\_set}


%opening
\title{lpeconstelm \\ DRAFT \\ work in progress}
\author{F.P.M. Stappers}

\begin{document}

\maketitle

\begin{abstract}
This documentation describes the usage and implementation of the tool \tool\ within the \mcrl\ toolset.
Basically, \tool\ is a tool which eliminates constant parameters in a \lpe\ (LPE).
\end{abstract}

\tableofcontents

\section{Intoduction}
This \tool\ tool is a tool for the \mcrl\ studio. The tool is a
filter which reads form a \ti{input.lpe}. The file \ti{input.lpe} is
a file in \ti{.lpe} format \cite{LPEformat}. We make use of the
\framework\ to read the \ti{input.lpe}. The filter substitutes for
each constant \pp\ its constant value and removes the \pp\ from the
\lpe . After the algorithm (section \ref{sec:alg}) ends, the \tool\
will write the output to an output file \ti{output.lpe}. This file is
a file in the \ti{.lpe} format \cite{LPEformat}.

\section{definitions} \label{sec:def}

The equation below is a representation of a \lpe\ in \mcrl\ . This definition simplified to describe the \tool\ tool.
\begin{defn}[\lpe]\label{def:LPE}
\begin{displaymath}
X (\ovr{d}:\ovr{D}) = \sum_{i \in I} \sum_{e_i:E_i} c_i ( \ovr{d}, \ovr{e_i} ) \rightarrow a(\ovr{f_i}(\ovr{d},e_i)) \cdot X(\ovr{g_i}(\ovr{d},\ovr{e_i})) $$
$$ X(\ovr{init})
\end{displaymath}

A \lpe\ is written as in Definition \ref{def:LPE}, the different states of the process are represented by the data vector parameter $\ovr{d:D}$. $D$ may be a Cartesian product of $n$ data types, meaning that $d$ may consist of a tuple $(d_1, \ldots, d_n)$. The \lpe expresses that in state $\ovr{d}$ it preforms action $a$, carrying data parameter $f_i(\ovr{d},e)$ and it can reach the new state $g_i(\ovr{d,e})$ under the conditions that $c_i(\ovr{d,e})$ is true. So for each summand $i:I$ we have a function $g_i: D \times E \rightarrow D$ and a function $c_i: D \times E $, which reduces to a normal form \ti{true}, \ti{false} or something else. 

The data type $E$ helps to give the \lpe s a more general form. Not only the data parameter $\ovr{d:D}$, but also the data parameters $\ovr{e_i: E_i}$ can influence the condition $c_i$ and the and the resulting state $g_i$. Such a $e$ is often used in a \lpe to do a read or send action range over a domain. 

For an more detailed explanation of \lpe s  we refer to \cite{LPE_info}.
\end{defn}

\subsection{lpeconstelm definition}\label{subsec:lpedef}

A parameter of a \lpe\ can be replaced by its intial value if it can be determined that this parameter remains constant throughout any run of the process. Thi elimination of constant parameters does not reduce the resulting state space, however it may shorten the time needed tot generate a state space from a \lpe. \\
If we live in an ideal world and have all the time of the world we can inspected each state space and check if a \pp\ changes throughout the the run of the process. We can determine the reachability $R_{\psi}$ for each state given a certain input value ($\ovr{v_0}$). 

We proceed to give a definition based upon a minimal fixed point $v_0$ with induction. 
\begin{defn}\label{def:lpe}
$R_\psi$ is the smallest set which complies to:
\begin{itemize}
\item $\ovr{v_0} \in R_\psi(\ovr{v_0})$
\item For all $i \in I$ and $w_i \in E_i$ if $v \in R_\psi(\ovr{v_0})$ and $c_i(v, w_i$ holds, \\ then $g_i(v, w_i) \in R_\psi(\ovr{v_0})$ \\

$S_\psi(\ovr{v_0}) = \lbrace j \in  \lbrace 1, \ldots, n \rbrace \vert \exists_u : D_j . \forall \ovr{v} \in R_\psi(\ovr{v_0}) . v_j = u \rbrace $
\end{itemize}

$S_\psi(\ovr{v_0})$ will give the set of indeces in for which the \pp\ is constant.
\end{defn}

Note that definition \ref{def:lpe} has to generate the entire statespace. Generating an entire statespace can take a lot of time. In some cases generating the entire statespace and checking for constants can take forever. This is why we have to come up with a "faster" solution. However to create such a solution we have to make descisions which will influence the outcome of the filter. The outcome can contain a smaller set of constant \pps; will not detect all constant \pps .

\subsection{Suggestions 1}
We don't want to inspect all state spaces as mentioned in section \ref{subsec:lpedef}. This is why we have to aproximate the solution to definiton \ref{def:lpe}. Our first approximation we suggest will be:
\begin{defn} \label{def:sug1}
\label{defn:const}$S=$
\begin{displaymath}
\lbrace   
j \in \lbrace 1, \ldots , n \rbrace \vert \forall_{i\in I}, \ovr{d}: \ovr{D} , e_i: E_i, ((c_i(\ovr{d},e_i) = true)  \rightarrow d_j = g_i^j(\ovr{d},e_i)))\rbrace
\end{displaymath}
This approximation is very basic and does not cover all possiple solutions. Let us take a look at example \ref{example:sug1}:
\begin{example} \label{example:sug1}
proc P($x$: Nat) = P($2 \times x$);
init P(0);
\end{example}
By filling in example \ref{example:sug1} into definition \ref{def:sug1} this will result into $S = \oslash$. For all $x / 0 $ the outcome of the \pp\ is not constant. However for $x=0$ the \pp\ is constant in this \lpe . We have create an other sollution which is not as relax as definition \ref{def:sug1}.
% { j | forall d : d=2*d }

\end{defn}

\subsection{Algorithm definitions}
To calculate the set of constant \pps\ we use the algorithm
\ref{sss:alg} Before we describe the algorithm we need to introduce
some definitions. 
%These definitions are defined in \ref{sss:algdef}.
%A more general explanation is given in \ref{sss:algdesc}

\begin{itemize}
\item \begin{defn} \textbf{- state vector}\\
This vector represents the \pps\ of the input of a \lpe . The vector is 
$\langle d_0, \ldots, d_(n-1) \rangle$, where $n$ is the is the number
of \pps . The state vector is denoted with: 

\begin{displaymath}
(\ovr{d})
\end{displaymath}
\end{defn}

\item \begin{defn} \textbf{- flag vector}\\
This vector is a vector of boolean values which represents if \pps\
are constant or variable. If an element of this vector is \ti{true}
this implies that the corresponding \pp\ is possible constant. If an element
of this vector is \ti{false} this implies that the corresponding
\pp\ is variable.
\begin{displaymath}
%\langle \cup_{d \in d_0 \ldots d_n} :: \langle \forall_{i \in I} :: Constant(d, e_i) \rangle \rangle
(\ovr{\Bbb{B}})
\end{displaymath}
\end{defn}

\item \begin{defn} \textbf{- new state set}\\
 This vector represents the outcome of the
\pps\ for which the normal form of the condition is not \ti{false}. So
the set is defined by:

\begin{displaymath}\langle \cup_{i \in I}: c_i(\ovr{d},
e_i) :\ovr{g_i}(\ovr{d},e_i) \rangle
\end{displaymath}
\end{defn}

\item \begin{defn}
\textbf{- new flag set} \\
This set represents the boolean values indicating if the
corresponding \pps\ in the \svs\ are \ti{constant} or \ti{variable}. Only the summands for
which the normal form of condition is not \ti{false} are in this set. The set is
defined by:
\begin{displaymath}
\langle \cup_{i \in I}: c_i(\ovr{d, e_i}) : (\ovr{\Bbb{B}}) ) \rangle
\end{displaymath}
\end{defn}
\end{itemize}

\subsubsection{Description}\label{sss:desc}
In this subsection the idea behind the algorithm is explained. First we take the \sv . The \sv\ is constructed from the \verb"init" of the \lpe (see \cite{LPE_info}). Next the \fv\ is constructed. The number of vector elements in this vector is equal to the number of \pps . Each \pp\ corresponds with an element in the \fv .  All elements in this vector are set \ti{true}.

 We start the iteration. In this step we evaluate for each summand its condition. We evaluate the condition by substituting the values of the \pp\ from the \sv\ in the condition. Only those \pp\ from the \sv\ are substituted for which the corresponding \pp\ in the \fv\ are true. 

After substitution the condition is rewritten. If the rewritten condition is in a normal form other then \ti{false} the condition implies that it might be \ti{true}, so the summand will evaluated. 

In this step the \svs\ is constructed. This set of new state vectors contains the set of next state vectors which can be reached from the current \sv\ and for which the condition might be \ti{true}. 

After the \svs\ is constructed, we construct the \fvs . Initally we set the the size of the set to the number of non false conditions. Each element within  these vectors is set true. Each vector of the \fvs\ corresponds with a vector of \svs . Each element of a vector in the \fvs\ is a comparison between the \sv and the element of the corrresponding vector in the \svs . If a element from the vector in the \svs\ is not equal to an element out of the \sv\ , the corresponding \fvs\ element is set to false. 

Next we construct a \ti{new} \fv . For each element in this vector we take the conjunction of all the values of the same element in the vectors of the \fvs . Each element of a vector from the \svs\ is checked if they differ from other elements  in vectors of the \svs . The boolean outcome of both results is the \ti{new} \fv . The reason for this second check is needed on the \svs , because free variables might occur. %to be implemented CHECK LPECONSTELM
 
If the \ti{new} \fv\ differs from the \fv , a \ti{new} \sv\ has to be created as well. The construction of the \ti{new} \sv\ contains all elements from the \sv\ with substition with the elements which differ from the \svs . 
%These can be found in the \svs . 
A next iteration is started in which the old \sv\ is substituted by the \ti{new} \sv\ and the old \fv\ is substituted by the \ti{new} \fv .
  
If the \ti{new} \fv\ does not differ from the \fv\ the algorithm ends and all \pps\ which have a corresponding value true in the \fv\ are substituted by their constant values. Then these \pps list and all occurrences of \pp\ 

\subsubsection{Free variables}
In \mcrl\ it is possible to use free variables. Free variables are values which have no particular value and can therefore be threaded as don't care values. If a \pp\ is substituted by a free variable and the \pp\ has already got a value, the value remains the same. If a \pp\ , which is a free variable, is substituted by a variable with a specific value, the value is changed to that specific value. If a \pp , which is a free variable, is substituted by another free variable, the \pp\ remains a free variable. 

If we compare a free variable with another value, either a free variable or a specific value, the comparison always yields \ti{true}. Adding a check on the \svs\ solves the problem of the possibility of fake constants. At first this might seems strange, but is contributes to the validity of the algorithm. Let us concider example \ref{exmpl:freevar}:
\begin{example}\label{exmpl:freevar} The LPE: 
\begin{tabbing}
$P(y = \_,x = 0) =$ \= $(c_1 = true) \rightarrow  P(y := x+1, x := x) + $ \\
	    \> $(c_2 = true)
 \rightarrow P(y := x+2, x := x)$
\end{tabbing}

A free variable is denoted with $\_$. If we take a look at the LPE and build the \fvs\ we get:
\begin{center}
\begin{tabular}{cc} 
 $\lbrace \langle True, $ & $ True \rangle$\\
 $\langle True, $ & $ True \rangle \rbrace$\\
\end{tabular} 
\end{center}

However the when we build the \svs , we get:
\begin{center}
\begin{tabular}{cc} 
 $\lbrace \langle$ 1, & 0 $\rangle$\\
 $\langle$ 2, & 0 $\rangle \rbrace$\\
\end{tabular}  
\end{center}

If we take the conjunction of the elements of each vector within the \fvs\ the \ti{new} \fv\ will be:
\begin{center}
\begin{tabular}{cc} 
 $\langle True, $ & $ True \rangle$\\
\end{tabular}
\end{center}

However by examining the \svs\ this should be: 
\begin{center}
\begin{tabular}{cc} 
 $\langle False, $ & $ True \rangle$\\
\end{tabular}
\end{center}

This why have an additional check on the \svs\ to overcome this problem.
\end{example}

For further reading about \lpe\ and free variables please refer to \cite{LPEfreevar} 

\section{Algorithm} \label{sec:alg}
\begin{tabbing} 
statevector \la create\_statevector(\verb"P(init)"); \\
flagvector \la create\_flagvector(statevector.size()); \\
iteration \la \ti{true}; \\
\tb{while} \= iteration \tb{do} \ra \\
  \> \csvs .empty(); \\
  \> \cfvs .empty(); \\
  \> \tb{forall} \= i \la summands \tb{do} \ra \\
  \>  \>   \tb{if} \= \\
  \>  \>   \sq \> (true $=$ evaluate\_condition(i)) \ra \\
  \>  \>       \> \csvs .add(compute\_next\_state\_vector(i)); \\
  \>  \>       \> \cfvs .add(compute\_next\_state\_flag\_vector(i)); \\
  \>  \>  \sq \>  (false $=$ evaluate\_condition(i)) \ra \\
  \>  \>  \> \tb{skip};\\
  \>  \tb{od llarof} \\
  \>  newflagvector \la \csvs .flatten() $\wedge$  \\
  \>  \> \cfvs .nextstate\_different\_check;\\
  \>  \tb{if}  \\
  \>  \sq  \> (flagvector $\neq$ newflagvector) \ra \\ 
  \>       \>	statevector \la \cfvs .flatten(); \\
  \>       \>     flagvector \la newflagvector; \\
        %iteration \la true
  \>  \sq \>  (flagvector $=$ newflagvector) \ra  \\
  \>      \> iteration \la false;\\
  \>  \tb{fi} \\
  \tb{od elihw}\\
  LPE.substitute\_values(flagvector, \verb"P(init)");
\end{tabbing}

\section{Examples}
This section covers a few simple examples to illustrate the behavior of the algorithm. 
\subsection{Example 1}
\begin{verbatim}
proc P(i,j: Nat) =
	true -> P(i:= i + 1, j:=j);

init P(i := 0, j := 0)
\end{verbatim} \footnote{\mcrl specifaction language}

Construct state vector and flag vector: 
\begin{center}\begin{minipage}{250pt}
\sv \la  $\langle 0 , 0 \rangle$\\
\fv \la  $\langle True , True \rangle$\\
\end{minipage}\end{center}

Evaluate all the conditions of all summands.
The condition of the first summand is \ti{true}.\\

We constructed the \svs and the \fvs :
\begin{center}\begin{minipage}{250pt}
\svs \la  $\lbrace \langle 1 , 0 \rangle \rbrace $\\
\fvs \la  $\lbrace \langle False , True \rangle \rbrace $\\
\end{minipage}\end{center}

We flatten \fvs to \ti{new} \fv : 
\begin{center}\begin{minipage}{250pt}
\ti{new} \fv \la $\langle False , True \rangle $
\end{minipage}\end{center}

We compare \ti{new} \fv\ with \fv\ and see they are not equal so we continue:
\begin{center}\begin{minipage}{250pt}
\sv \la $\langle 1 , 0 \rangle $\\
\fv \la $\langle False , True \rangle $\\
\end{minipage}\end{center}

In the second iteration the condition of the first summand is \ti{true}.\\
So we construct again the \svs, the \fvs\ and flatten the \fvs\ to \ti{new} \fv: 
\begin{center}\begin{minipage}{250pt}
\svs \la  $\lbrace \langle 2 , 0 \rangle \rbrace $\\
\fvs \la  $\lbrace \langle False , True \rangle \rbrace $\\
\ti{new} \fv \la  $\langle False , True \rangle $ \\
\end{minipage}\end{center}

If we compare the \fv\ with \ti{new} \fv\ we see they are equal and the iteration ends.
In this example the second \pp\ (\verb"j") is substituted by \verb"0" and \verb"j" is removed from the \lpe.
After applying the filter we get:
\begin{verbatim}
proc P(i) 
	true -> P(i := i + 1);

Init P(0);
\end{verbatim}

\subsection{Example 2}
This example shows the why iteration is needed.
\begin{verbatim}
proc P(i,j) = P(i := i + 1, j := i);
init P(i := 0, j := 0); 
\end{verbatim}
 
Construct state vector and flag vector: 
\begin{center}\begin{minipage}{250pt}
\sv \la  $\langle 0 , 0 \rangle$\\
\fv \la  $\langle True , True \rangle$\\
\end{minipage}\end{center}

Evaluate all the conditions of all summands.
The condition of the first summand is \ti{true}.\\

We constructed the \svs and the \fvs :
\begin{center}\begin{minipage}{250pt}
\svs \la  $\lbrace \langle 1 , 0 \rangle \rbrace $\\
\fvs \la  $\lbrace \langle False , True \rangle \rbrace $\\
\end{minipage}\end{center}

We flatten \fvs\ to \ti{new} \fv: 
\begin{center}\begin{minipage}{250pt}
\ti{new} \fv \la $\langle False , True \rangle $
\end{minipage}\end{center}

We compare \ti{new} \fv\ with \fv\ and see they are not equal so we continue:
\begin{center}\begin{minipage}{250pt}
\sv \la $\langle 1 , 0 \rangle $\\
\fv \la $\langle False , True \rangle $\\
\end{minipage}\end{center}

In the second iteration the condition of the first summand is \ti{true}.\\
So we construct again the \svs, the \fvs\ and flatten the \fvs to \ti{new} \fv: 
\begin{center}\begin{minipage}{250pt}
\svs \la  $\lbrace \langle 2 , 1 \rangle \rbrace $\\
\fvs \la  $\lbrace \langle False , False \rangle \rbrace $\\
\ti{new} \fv \la  $\langle False , False \rangle $ \\
\end{minipage}\end{center}

We compare \ti{new} \fv\ with \fv\ and see they are not equal so we continue:
\begin{center}\begin{minipage}{250pt}
\sv \la $\langle 2 , 1 \rangle $\\
\fv \la $\langle False , False \rangle $\\
\end{minipage}\end{center}

In the third iteration the condition of the first summand is \ti{true}.\\
So we construct again the \svs, the \fvs\ and flatten the \fvs\ to \ti{new} \fv: 
\begin{center}\begin{minipage}{250pt}
\svs \la  $\lbrace \langle 3 , 2 \rangle \rbrace $\\
\fvs \la  $\lbrace \langle False , False \rangle \rbrace $\\
\ti{new} \fv \la  $\langle False , False \rangle $ \\
\end{minipage}\end{center}

If we compare the \fv\ with \ti{new} \fv\ we see they are equal and the iteration ends.
Non of the elements in the \fv\ are \ti{true}, so there are no constants. The \lpe\ remains unchanged.


\newpage
\begin{thebibliography}{99}  \bibitem{LPE_info} auteur\\
   \textit{article},
   Extra info.
  \bibitem{LPEframework} J.W. Wesselink,
   \textit{http://www.win.tue.nl/~wieger/mcrl2/html/index.html}\\
   A C++ wrapper for the ATerm library.
  \bibitem{LPEformat} auteur,
   \textit{article}
   Extra info.
  \bibitem{LPEfreevar} auteur,
   \textit{article}
   Extra info.

\end{thebibliography}

\newpage



\end{document}
