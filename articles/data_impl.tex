\documentclass[a4paper,fleqn]{article}

% title and author
\title{The Data Implementation Phase of the mCRL2 Parser}
\author{Aad Mathijssen} 

% packages
\usepackage[english]{babel}
\usepackage[final]{graphics}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{array}
\usepackage{calc}
\usepackage{xspace}

% General layout
% --------------

%add headings
\pagestyle{headings}

% increase pagewidth
\addtolength{\textwidth}{20mm}
\addtolength{\oddsidemargin}{-10mm}
\addtolength{\evensidemargin}{10mm}

% set the indentation of the math environment to 10mm
\setlength{\mathindent}{10mm}

% equations are unique up to their section
\renewcommand{\theequation}{\arabic{equation}}

% do not put subsubsections in the table of contents
\addtocounter{tocdepth}{-1}

% column types that change column types l,c,r from math mode to LR
% and the other way round
\newcolumntype{L}{>{$}l<{$}}%stopzone%stopzone%stopzone
\newcolumntype{C}{>{$}c<{$}}%stopzone%stopzone%stopzone
\newcolumntype{R}{>{$}r<{$}}%stopzone%stopzone%stopzone

% Environments
% ------------

% equations: eqnarray environment with no outer column spacing and tighter
% intercolumn spacing
\newenvironment{equations}
  {\setlength{\arraycolsep}{2pt}%
   \begin{array}{@{}lll@{}}%
  }
  {\end{array}%
  }

% tightarray: array with no outcolumn spacing and tighter intercolumn spacing
\newenvironment{tightarray}[1]
  {\setlength{\arraycolsep}{2pt}%
   \begin{array}{@{}#1@{}}%
  }
  {\end{array}%
  }

% definitions: list of definitions where:
% - the optional argument denotes the space between successive items
%   (default 0.15em)
% - items are horizontally aligned at the math indent
\newenvironment{definitions}[1][0.15em]
  {\begin{list}%
    {}%
    {\setlength{\parsep}{0pt}%
     \setlength{\itemsep}{#1}%
     \setlength{\leftmargin}{\mathindent}%
     \setlength{\labelwidth}{\mathindent - \labelsep}%
    }
  }
  {\end{list}}

% tdefinitions: list of tagged definitions where:
% - the optional argument denotes the space between successive items
%   (default 0.15em)
% - items are horizontally aligned at the math indent
% - each item is tagged with the mandatory argument
\newenvironment{tdefinitions}[2][0.15em]
  {\begin{list}%
    {#2}%
    {\setlength{\parsep}{0pt}%
     \setlength{\itemsep}{#1}%
     \setlength{\leftmargin}{\mathindent}%
     \setlength{\labelwidth}{\mathindent - \labelsep}%
    }
  }
  {\end{list}}

% edefinitions: list of enumerated definitions where:
% - the optional argument denotes the space between successive items
%   (default 0.15em);
% - items are horizontally aligned at the math indent;
% - each item is numbered with a parenthesized roman numeral.
\newcounter{edefinitioncount}
\newenvironment{edefinitions}[1][0.15em]
  {\begin{list}%
    {(\roman{edefinitioncount})}%
    {\renewcommand{\theenumi}{\roman{enumi}}%
     \renewcommand{\labelenumi}{(\theenumi)}%
     \usecounter{edefinitioncount}%
     \setlength{\parsep}{0pt}%
     \setlength{\itemsep}{#1}%
     \setlength{\leftmargin}{\mathindent}%
     \setlength{\labelwidth}{\mathindent - \labelsep}%
    }
  }
  {\end{list}}
  
% entry: list of entries where:
% - the optional argument denotes the space between successive items
%   (default 0.15em);
% - items are horizontally aligned at the math indent;
% - each item is labelled.
\newenvironment{entry}[2][0.15em]%
  {\begin{list}{}%
    {\renewcommand{\makelabel}[1]{\textsf{##1:}\hfil}%
     \settowidth{\labelwidth}{\textsf{#2:}}%
     \setlength{\leftmargin}{\labelwidth+\labelsep}%     
     \setlength{\parsep}{0pt}%
     \setlength{\itemsep}{#1}%
    }%
  }%
  {\end{list}}

% derivation: calculational derivation where expressions (\expr) are related by
% means of transformations (\tran). A transformation is denoted by a symbol and
% a hint. Expressions and transformations can be broken into several lines
% using \breakexpr and \breaktran.
\newenvironment{derivation}
{\par\addtolength{\baselineskip}{1mm}\begin{tabbing}\hspace{5mm}\=\hspace{5mm}\=\hspace{5mm}\=\kill}
{\end{tabbing}\par}
\newcommand{\expr}[1]{\>\>$#1$}
\newcommand{\tran}[2]{\\*\>$#1$\>\>\{ #2 \}\\}
\newcommand{\breakexpr}{$\\*\>\>$}
\newcommand{\breaktran}{\\*\>\>\>\hspace{8pt}}

% Theorem-like environments that are numbered as s.n, where:
% - s is the section number
% - n is the number of occurrences of all theorem-like environments in s
% We have the following environments:
% - definition
% - theorem
% - lemma
% - corollary
% - property
% - example
% - remark
% - convention
% - specification
% - declaration

\newtheorem{thdefinition}{Definition}[section]
\newenvironment{definition}
  {\begin{thdefinition}\em}
  {\end{thdefinition}}

\newtheorem{ththeorem}[thdefinition]{Theorem}
\newenvironment{theorem}
  {\begin{ththeorem}\em}
  {\end{ththeorem}}

\newtheorem{thcorollary}[thdefinition]{Corollary}
\newenvironment{corollary}
  {\begin{thcorollary}\em}
  {\end{thcorollary}}

\newtheorem{thlemma}[thdefinition]{Lemma}
\newenvironment{lemma}
  {\begin{thlemma}\em}
  {\end{thlemma}}

\newtheorem{thproperty}[thdefinition]{Property}
\newenvironment{property}
  {\begin{thproperty}\em}
  {\end{thproperty}}

\newtheorem{thexample}[thdefinition]{Example}
\newenvironment{example}
  {\begin{thexample}\em}
  {\end{thexample}}

\newtheorem{thremark}[thdefinition]{Remark}
\newenvironment{remark}
  {\begin{thremark}\em}
  {\end{thremark}}

\newtheorem{thconvention}[thdefinition]{Convention}
\newenvironment{convention}
  {\begin{thconvention}\em}
  {\end{thconvention}}

\newtheorem{thspecification}[thdefinition]{Specification}
\newenvironment{specification}
  {\begin{thspecification}\em}
  {\end{thspecification}}

\newtheorem{thdeclaration}[thdefinition]{Declaration}
\newenvironment{declaration}
  {\begin{thdeclaration}\em}
  {\end{thdeclaration}}

% proof: proof of a theorem
\newenvironment{proof}
  {\textbf{Proof}}
  {\frm{\Box}
   \vspace{1ex}%
  }


% Commands
% --------
% --------


% math mode
% ---------

% improvement to $ ... $ such that mathematical formulas cannot be cramped
\newcommand{\frm}[1]{\mbox{\ensuremath{#1}}}

% frm with extra spacing
\newcommand{\for}[1]{\frm{\,#1\,}}


% functions and constants
% -----------------------

% constant
\newcommand{\f}[1]{\ensuremath{\mathit{#1}}}

% function application with 1 argument: f(arg0)
\newcommand{\fa}[2]{\ensuremath{\f{#1}(#2)}}

% function application with 2 arguments: f(arg0, arg1)
\newcommand{\faa}[3]{\ensuremath{\f{#1}(#2, #3)}}

% function application with 3 arguments: f(arg0, arg1, arg2)
\newcommand{\faaa}[4]{\ensuremath{\f{#1}(#2, #3, #4)}}

% function application with 4 arguments: f(arg0, arg1, arg2, arg3)
\newcommand{\faaaa}[5]{\ensuremath{\f{#1}(#2, #3, #4, #5)}}


% functions and types
% -------------------

% function application symbol: .
\newcommand{\fap}{\ensuremath{\!\cdot\!}}

% composition: 0
\newcommand{\comp}{\ensuremath{\circ}}

% function composition: o
\newcommand{\fcomp}{\ensuremath{%
  \hspace{0.08em}\mbox{\small\ensuremath{\circ}}\hspace{0.08em}}}
  
% function mapping
\newcommand{\fmap}{
  \hspace{0.08em}\raisebox{0.2ex}{%
  \tiny\ensuremath{\bullet}}\hspace{0.08em}}


% lambda calculus
% ---------------

% abstraction in the typed lambda calculus
\newcommand{\labst}[3]{\ensuremath{\lambda #1\!:\!#2.#3}}

% application in the typed lambda calculus
\newcommand{\lappl}[2]{\ensuremath{#1\ #2}}

% abstraction in the pure (untyped) lambda calculus
\newcommand{\pabst}[2]{\ensuremath{\lambda #1.#2}}

% application in the pure (untyped) lambda calculus
\newcommand{\pappl}[2]{\ensuremath{#1\ #2}}

% sets
% ----

% set of elements: {e}
\newcommand{\set}[1]{\ensuremath{\{\,#1\,\}}}

% bag of elements: {e}
\newcommand{\bag}[1]{\ensuremath{\set{#1}}}

% set difference: s \ t
\newcommand{\sdiff}[2]{\ensuremath{#1\ \backslash\ #2}}

% set comprehension: { e | c }, where e is an expression or a binding and c is
% a condition
\newcommand{\scompr}[2]{\ensuremath{\set{#1\ |\ #2}}}

% powerset: P(s)
\newcommand{\pow}[1]{\ensuremath{\fa{\mathcal{P}}{#1}}}


% tuples
% ------

% tuple of elements: <e>
\newcommand{\tpl}[1]{\ensuremath{\langle\,#1\,\rangle}}

% pair of elements: <e0,e1>
\newcommand{\pair}[2]{\ensuremath{\tpl{#1\hspace{0.08em},#2}}}


% lists
% -----

% list of a certain type: L(t)
\newcommand{\List}[1]{\ensuremath{\mathcal{L}{\I{#1}}}}

% list of elements: [e]
\newcommand{\lst}[1]{\ensuremath{[\,#1\,]}}

% empty list
\newcommand{\el}{\ensuremath{[\,]}}

% cons: |>
\newcommand{\cons}{\ensuremath{\hspace{0.12em}\triangleright\hspace{0.08em}}}
  
% snoc: <|
\newcommand{\snoc}{\ensuremath{\hspace{0.08em}\triangleleft\hspace{0.12em}}}

% concatenation: ++
\newcommand{\concat}{\frm{+\!+}}

% take
\newcommand{\take}{\ensuremath{\lceil}}

% drop
\newcommand{\drop}{\ensuremath{\lfloor}}


% logic
% -----

% boolean type: B
\newcommand{\bool}{\ensuremath{\mathbb{B}}}

% true
\newcommand{\true}{\ensuremath{\f{true}}}

% false
\newcommand{\false}{\ensuremath{\f{false}}}

% implies: =>
\newcommand{\limp}{\ensuremath{\Rightarrow}}

% follows: =>
\newcommand{\lfol}{\ensuremath{\Leftarrow}}

% bi-implies: <=>
\newcommand{\lbimp}{\ensuremath{\Leftrightarrow}}

% not with extra spacing
\newcommand{\Lnot}{\ensuremath{\ \lnot\ }}

% and with extra spacing
\newcommand{\Land}{\ensuremath{\ \land\ }}

% or with extra spacing
\newcommand{\Lor}{\ensuremath{\ \lor\ }}

% implies with extra spacing
\newcommand{\Limp}{\ensuremath{\ \limp\ }}

% bi-implies with extra spacing
\newcommand{\Lbimp}{\ensuremath{\ \lbimp\ }}

% quantification in Dijkstra notation: <Q x : y : z>
\newcommand{\quantD}[4]{\ensuremath{\langle\,{#1} {#2} : #3 : {#4}\,\rangle}}

% universal quantification in Dijkstra notation: <forall x : y : z>
\newcommand{\forallD}[3]{\ensuremath{\quantD{\forall}{#1}{#2}{#3}}}

% existential quantification in Dijkstra notation: <exists x : y : z>
\newcommand{\existsD}[3]{\ensuremath{\quantD{\exists}{#1}{#2}{#3}}}

% derivable in #1: |-_#1
\newcommand{\derivable}[1]{\ensuremath{\vdash_{_{#1}}}}

% valid in #1: |=_#1
\newcommand{\valid}[1]{\ensuremath{\models_{_{#1}}}}

%inference rule with 0 premises and 1 conclusion
\newcommand{\infC}[1]{\ensuremath{
  \begin{array}{c} 
    \\\hline 
    #1 
  \end{array}
}}

%inference rule with 1 premise and 1 conclusion
\newcommand{\infPC}[2]{\ensuremath{
  \begin{array}{c} 
    #1 \\\hline 
    #2 
  \end{array}
}}

% inference rule with 2 premises and 1 conclusion
\newcommand{\infPPC}[3]{\ensuremath{
  \begin{array}{c@{\hspace{2em}}c}
    #1 & #2 \\\hline
    \multicolumn{2}{c}{#3}
  \end{array}
}}

%inference rule with 3 premises and 1 conclusion
\newcommand{\infPPPC}[4]{\ensuremath{
  \begin{array}{c@{\hspace{2em}}c@{\hspace{2em}}c}
    #1 & #2 & #3\\\hline
    \multicolumn{3}{c}{#4}
  \end{array}
}}

% arithmetic
% ----------

% natural type: N
\newcommand{\nat}{\ensuremath{\mathbb{N}}}

% positive type: N+
\newcommand{\pos}{\ensuremath{\mathbb{N}^{+}}}

% integral type: Z
\newcommand{\tint}{\ensuremath{\mathbb{Z}}}

% integer division: "div"
\renewcommand{\div}{\ensuremath{\ \mathbf{div}\ }}

% integer remainder: "mod"
\renewcommand{\mod}{\ensuremath{\ \mathbf{mod}\ }}


% miscellaneous
% -------------

% language of a signature Sigma: L(Sigma)
\newcommand{\lang}[1]{\ensuremath{\fa{\mathcal{L}}{\f{#1}}}}

% meaning of a syntactic element
\newcommand{\mean}[1]{%
  [\hspace{-.15em}[\hspace{.15em}#1\hspace{.15em}]\hspace{-.15em}]%
}

% alternative choice
\newcommand{\alt}{\ensuremath{[\hspace{-0.04em}]}}

% bullet
\newcommand{\bul}{\mbox{\small\ensuremath{\bullet}}}

% complexity according to expression: O(e)
\newcommand{\bigo}[1]{\ensuremath{\mathcal{O}(#1)}}

% print #2 inside #3, where #2 is raised by #1
\newlength{\insidewd}%                        Define length command
\newcommand{\inside}[3][0pt]{%		      Definition of inside:
   \settowidth{\insidewd}{#3}%                - Save width of #3
   \raisebox{#1}[0pt]{%                       - Raise #2 by #1
     \makebox[0pt]{\hspace{\insidewd}#2}}%    - Print #2 centered
   #3}%				              - Print #3

% stack #2 on #3, where #2 is raised by #1
\newlength{\stackht}%                         Define length commands
\newcommand{\stack}[3][0pt]{%		      Definition of stack:
   \settoheight{\stackht}{#3}%                - Save height of #3
   \addtolength{\stackht}{#1}%                - Add to #1 to heigth
   \inside[\stackht]{#2}{#3}}%                - Print #2 in #3 at height #3 + #1

% abbreviations
% -------------

% mCRL
\newcommand{\mCRL}{\frm{\mu}CRL\xspace}

% Miscellaneous local definitions
% -------------------------------

% temporary lengths
\newlength{\tlength}

% mCRL2 keywords
\newcommand{\kwsort}{{\bf sort}}
\newcommand{\kwcons}{{\bf cons}}
\newcommand{\kwmap}{{\bf map}}
\newcommand{\kwvar}{{\bf var}}
\newcommand{\kweqn}{{\bf eqn}}
\newcommand{\kwact}{{\bf act}}
\newcommand{\kwstruct}{{\bf struct}}
\newcommand{\kwwhr}{{\bf whr}}
\newcommand{\kwend}{{\bf end}}


% mCRL Sorts
\newcommand{\srtbool}{\f{Bool}}
\newcommand{\srtpos}{\f{Pos}}
\newcommand{\srtnat}{\f{Nat}}
\newcommand{\srtint}{\f{Int}}

% mCRL Operations
\newcommand{\opzeronat}{{0n}}
\newcommand{\oponenat}{{1}}
\newcommand{\optwonat}{{2}}
\newcommand{\opzeroint}{{0i}}
\newcommand{\opposint}{\ensuremath{\f{pos}}}
\newcommand{\opnegint}{\ensuremath{\f{neg}}}
\newcommand{\opnot}{\ensuremath{\f{not}}}
\newcommand{\opand}{\ensuremath{\f{and}}}
\newcommand{\opor}{\ensuremath{\f{or}}}
\newcommand{\opforall}{\ensuremath{\f{forall}}}
\newcommand{\opexists}{\ensuremath{\f{exists}}}
\newcommand{\opsucc}{\ensuremath{\f{succ}}}
\newcommand{\oppred}{\ensuremath{\f{pred}}}
\newcommand{\opadd}{\ensuremath{\f{add}}}
\newcommand{\opminus}{\ensuremath{\f{minus}}}
\newcommand{\opmonus}{\ensuremath{\f{monus}}}
\newcommand{\optimes}{\ensuremath{\f{times}}}
\newcommand{\opdiv}{\ensuremath{\f{div}}}
\newcommand{\opmod}{\ensuremath{\f{mod}}}
\newcommand{\oppower}{\ensuremath{\f{power}}}
\newcommand{\opdouble}{\ensuremath{\f{double}}}
\newcommand{\opif}{\ensuremath{\f{if}}}
\newcommand{\opeq}{\ensuremath{\f{eq}}}
\newcommand{\opneq}{\ensuremath{\f{neq}}}
\newcommand{\opgrt}{\ensuremath{\f{grt}}}
\newcommand{\opsmt}{\ensuremath{\f{smt}}}
\newcommand{\opgreq}{\ensuremath{\f{greq}}}
\newcommand{\opsmeq}{\ensuremath{\f{smeq}}}
\newcommand{\opint}{\ensuremath{\f{int}}}
\newcommand{\opnat}{\ensuremath{\f{nat}}}
\newcommand{\oplambda}[1]{\ensuremath{\f{lambda\_#1}}}
\newcommand{\opappl}[1]{\ensuremath{\f{appl\_#1}}}
\newcommand{\opsubst}[2]{\ensuremath{\f{subst\_#1\_#2}}}
\newcommand{\opindex}[1]{\ensuremath{\f{index\_#1}}}
\newcommand{\opproj}[2]{\ensuremath{\f{proj_{#1}^{#2}}}}
\newcommand{\opheadsymbol}{\ensuremath{\f{opheadsymbol}}}

\newcommand{\Time}{{\bf Time}}
\newcommand{\Bool}{{\bf Bool}}
\newcommand{\sft}{{\sf t}}
\newcommand{\sff}{{\sf f}}
\newcommand{\nul}{{\bf 0}}
\font \aap cmmi10        
\newcommand{\at}[1]{\mbox{\aap ,} #1}
\newcommand{\before}{\mbox{\footnotesize{\frm{\ll}}}}
\newcommand{\ap}{{:}}
\newcommand{\qed}{\hfill\ensuremath{\quad\Box}}
\newcommand{\leftmerge}{\underline {\parallel}}

\newenvironment{mCRL2}%
{\par\bigskip\noindent%
 \begin{tabular}{@{}>{\bf}p{2.3em}L@{\ }L@{\ }L@{\ }L@{\ }L@{\ }L@{\ }L@{\ }L}%
}%
{\end{tabular}\bigskip\par%
}

\begin{document}

\maketitle

\section{Data removal}

The data implementation phase comes after the parsing and type checking phases.
In this phase, all sort and data expressions are implemented in a core set
of higher-order algebra. For sorts, this core set contains sort
identifiers and arrow sorts only. For data expressions, it
contains data variables, operation identifiers and data
applications only. In this document we show how this is done. To
increase readability, we only show expressions in the external
format instead of the internal format.

\subsection{Structured sorts}

A structured sorts is of the form
\begin{mCRL2}
& \kwstruct
    &c_{1}(\f{pr}_{1,1}: A_{1,1}, & \ldots & , \f{pr}_{1,k_{1}}: A_{1,k_{1}})
      ?\f{is\_c_{1}}\\
&\hfill |
    &c_{2}(\f{pr}_{2,1}: A_{2,1}, & \ldots & , \f{pr}_{2,k_{2}}: A_{2,k_{2}})
      ?\f{is\_c_{2}}\\
&                                 & \multicolumn{1}{c}{\vdots}\\
&\hfill |
    &c_{n}(\f{pr}_{n,1}: A_{n,1}, & \ldots & , \f{pr}_{n,k_{n}}: A_{n,k_{n}})
      ?\f{is\_c_{n}},
\end{mCRL2}
\noindent
where \frm{n \in \pos} and \frm{k_{i} \in \nat} with \frm{1 \leq i \leq n}.
All projections \frm{\f{pr}_{i,j}} and recognisers \frm{\f{is\_c_{i}}} are
optional.

For each constructor \frm{c_{i}} the following constructor operation is
declared, where
\frm{S} is the sort of the structured sort:
\[c_{i}: A_{i,1} \times A_{i,k_{i}} \to S\]
For each defined projection \frm{p_{i,j}} the following operation is declared:
\[p_{i,j}: S \to A_{i,j}\]
For each defined recogniser \frm{\f{is\_c}_{i}} the following operation is
generated:
\[\f{is\_c}_{i}: S \to \srtbool\]

\subsection{Numerical constants}

For the sorts \frm{\srtpos}, \frm{\srtnat} and \frm{\srtint}, the following
constructors are provided:

\begin{mCRL2}
&c1:   & \srtpos              & \text{one}\\
&cDub: & \srtbool \to \srtpos & \text{double a positive number and add a bit}\\
\\
&c0 :  & \srtnat              & \text{zero}\\
&cNat: & \srtpos \to \srtnat  & \text{positive number}\\
\\
&cNeg: & \srtpos \to \srtint  & \text{negation of a positive number}\\
&cInt: & \srtnat \to \srtint  & \text{natural number}\\
\end{mCRL2}

\noindent
Each numerical constant \frm{p} of sort $\srtpos$ is implemented as a term $\f{impl_{pc}(p)}$, where $\f{impl_{pc}}$ is inductively defined as follows:
\[\begin{tightarray}{lll@{\quad}L}
\f{impl_{pc}}(1) & = & c1\\
\f{impl_{pc}}(p) & = & \f{cDub}(p \mod 2)(\f{impl_{pc}}(p \div 2), & if $p \neq 1$
\end{tightarray}\]

\noindent
Each constant \frm{n} of sort \frm{\srtnat} is implemented as $\f{impl_{nc}}(n)$, where $\f{impl_{nc}}$ is defined as follows:
\[\begin{tightarray}{lll@{\quad}L}
\f{impl_{nc}}(0) & = & c0\\
\f{impl_{nc}}(n) & = & \f{cNat}(\f{impl_{pc}}(n)), & if $n \neq 0$
\end{tightarray}\]

\noindent
Each constant \frm{x} of sort \frm{\srtint} is implemented as $\f{impl_{ic}}(x)$, where $\f{impl_{ic}}$ is defined as follows:
\[\begin{tightarray}{lll@{\quad}L}
\f{impl_{ic}}(x) & = & \f{cInt}(\f{impl_{nc}}(x)), & if $x \geq 0$\\
\f{impl_{ic}}(x) & = & \f{cNeg}(\f{impl_{pc}}(-x)),& if $x < 0$
\end{tightarray}\]

\subsection{List enumerations}

A list enumeration is of the form
\[[e_{0}, \dots, e_{n}]\]
where \frm{n \in \nat} and all \frm{e_{i}} are of the same sort, say \frm{S}.
This enumeration is translated to the implementation of the following
expression:
\[e_{0} \cons \cdots \cons e_{n} \cons \el\]
Here, \frm{\el} is of sort \frm{S}.

\subsection{Set enumerations}

A set enumeration is of the form
\[\set{e_{0}, \dots, e_{n}}\]
where \frm{n \in \nat} and all \frm{e_{i}}, \frm{0 \leq i \leq n} are of the
same sort, say \frm{S}.  This is translated to the implementation of the
following expression:
\[\fa{@set}{\lambda x{:}S.\ (x == e_{0})\ \lor\ \cdots\ \lor\ (x == e_{n})}\]
Here, \frm{\f{@set}} is an operation system identifier of sort \frm{S \to
\srtbool \to \fa{Set}{S}}, and \frm{x} is a variable that does not occur free
in \frm{e_{i}}, \frm{0 \leq i \leq n}.

\subsection{Bag enumerations}

A bag enumeration is of the form
\[\set{e_{0}: c_{0}, \dots, e_{n}: c_{n}}\]
where \frm{n \in \nat}, all \frm{e_{i}}, \frm{0 \leq i \leq n} are of the same
sort, say \frm{S}, and all \frm{c_{i}} are of sort \frm{\srtnat}.  This is
translated to the implementation of the following expression:
\[\fa{@bag}{\lambda x{:}S.\ (\faaa{if}{x == e_{0}}{c_{0}}{\faaa{if}{x ==
e_{1}}{c_{1}}{\ldots \faaa{if}{x == e_{n}}{c_{n}}{0}}})}\]
Here, \frm{\f{@bag}} is an operation system identifier of sort \frm{(S \to
\srtnat) \to \fa{Bag}{S}}, and \frm{x} is a variable that does not occur free
in \frm{e_{i}} or \frm{c_{i}}, \frm{0 \leq i \leq n}.

\subsection{Set and bag comprehensions}

A set comprehension is of the form
\[\scompr{x{:}S}{\fa{f}{x}},\]
where \frm{\fa{f}{x}} is an expression of sort \frm{\srtbool} in which \frm{x}
may occur. This is translated to the implementation of the following
expression:
\[\fa{@set}{\lambda x{:}S.\ \fa{f}{x}}\]
Here, \frm{\f{@set}} is an operation system identifier of sort \frm{(S \to
\srtbool) \to \fa{Set}{S}}.

Bags are implemented in the same way with the exception that all occurrences of
sort \frm{\srtbool} in the above are replaced by sort \frm{\srtnat}.

\subsection{Quantifications}

A universal quantification is of the form
\[\forall x_{0}{:}S_{0}, \ldots, x_{n}{:}S_{n}. p,\]
where \frm{p} is an expression of sort \frm{\srtbool}.

This expression is translated to the implementation of the following
expression:
\[\fa{forall}{\lambda x_{0}{:}S_{0}, \ldots, x_{n}{:}S_{n}. p}\]
Here, \frm{\f{forall}} is an operation system identifier of sort 
\frm{(S_{0} \to \cdots \to S_{n} \to \srtbool) \to \srtbool}. The
implementation of the lambda abstraction is shown in
subsection~\ref{subsec:lambda}.

The implementation of existential quantifications is completely analogous to
the above implementation.

\subsection{Lambda expressions}
\label{subsec:lambda}

A lambda abstraction is of the form
\[\lambda x_{0}{:}S_{0}, \ldots, x_{n}{:}S_{n}. e,\]
where the body \frm{e} may contain occurrences of the declared variables from
this abstraction and from the context. We denote the context variables that
occur in \frm{e} by \frm{x_{-m}, \ldots, x_{-1}} of sort \frm{S_{-m}, \ldots,
S_{-1}}, respectively, where \frm{m \in \nat}.

This expression is translated to the implementation of the following
expression:
\[\fa{lambda@k}{x_{-m}, \ldots, x_{-1}},\]
Here, \frm{\f{lambda@k}} is an operation system identifier of where \frm{k} is
a unique natural number. It has sort \frm{S_{-m} \to \cdots \to S_{-1}
\to S_{0} \to \cdots \to S_{n} \to T}, where \frm{T} is the sort of expression
\frm{e}. For \emph{lambda@k} we have the following property:
\[\mathit{lambda@k}(x_{-m})\cdots(x_{-1})(x_{0})\cdots(x_{n}) = e\]

\subsection{Where clauses}

A where clause is of the form
\[e\ \kwwhr\ x_{0} = e_{0}, \ldots, x_{n} = e_{n}\ \kwend\]
This expression is translated to the implementation of a the following
expression, where \frm{S_{i}} represents the sort of \frm{e_{i}}, \frm{0 \leq i
\leq n}:
\[(\lambda x_{0}{:}S_{0}, \ldots, x_{n}{:}S_{n}. e)(e_{0})\cdots(e_{n})\]

[To do: explain functions defined on structured, numbers, lists,
sets and bags. For now, see the op_ids.tex document]

\end{document}
