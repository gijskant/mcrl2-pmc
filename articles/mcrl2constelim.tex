\documentclass[a4paper,9pt]{article}
\usepackage{vmargin}

\setmarginsrb{2cm}{2cm}{2cm}{2cm}{0cm}{0cm}{0cm}{1cm}

%opening
\title{mCRL2-constelim \\ DRAFT}
\author{Frank Stappers}

\begin{document}

\maketitle

\begin{abstract}
This documentation describes the usage and implementation of  the tool \verb"constelim" within the mCRL2 toolset. 
Basically, \verb"constelim" is a tool which eliminates constant parameters in a linear process equation (LPE).
\end{abstract}

\section{Description} \label{sec:dec}

\subsection{Algorithm}
Before the algorithm is given we declare some of the used keywords.
\begin{itemize}
\item \textit{init vector} \\ A vector which is constructed to detect changes for each iteration. 
 The elements in this vector represent the values of the process parameter.
\item \textit{flag vector} \\ This vector is a representation for indicating which elements of the \textit{init vector} 
are constant and variable. 
\item \textit{state vector} \\ This vector is calculated out of the \textit{init vector}. 
Each summand of the LPE has is own state vector.
\item \textit{change vector} \\ This vector is constructed out of the \textit{init vector}, \textit{flag vector} 
and the \textit{state vector}. This vector is a representation for indicating which elements of the \textit{state vector}
are constant and variable. 
\end{itemize}

\textbf{The Algorithm}
\begin{enumerate}
\item[\textbf{1}] Construct the \textit{init vector} out of the \verb"init" process.
All variables which are not included in the \textit{init vector} are free variables and marked as \textit{don't care}.
\item[\textbf{2}] Mark the process parameters from the \textit{init vector} \textit{constant} and 
store the result in \textit{flag vector}.
\item[\textbf{3}] Rewrite all data arguments of \textit{constant} marked process parameters.
\item[\textbf{4}] Calculate for each summand for which the guard evalutes too true, its \textit{state vector} and 
for each \textit{state vector} its \textit{change vector}.
\item[\textbf{5}] Construct out of all calculted \textit{state vectors} the new \textit{init vector}.
Construct out of all the corresponding \textit{change vectors} the new \textit{flag vector}. 
If the new constructed \textit{flag vector} 
differs from the old \textit{flag vector} substitute the old \textit{flag vector} with new \textit{flag vector} and
 substitute the old \textit{init vector} with the new  \textit{init vector}. 
 If the old the \textit{flag vector} differs from the new \textit{flag vector} continu with steps 3, 4 and 5.
 If the old \textit{flag vector} does not differs from the new \textit{flag vector} continue with the next step.
\item[\textbf{6}] Substitute all parameters which are marked \textit{constant} with the given constant value and remove
the parameters from the LPE.
\end{enumerate}

\subsection{Decisions}

If a process parameter becomes flagged \textit{variable} the value of this parameter is set to an arbitray value.
To indicate for process $x$ a arbitrary value can be chosen, we introduce the notation $x_{nc}$.
When the algorithm detects a changed in  $x$, it indicates the variable with the special 
value $x_{nc}$. Basicly $x_{nc}$ acts like a sort of flag. Note that $x_{nc}$ differs from a \textit{don't care} value. 
%of the variable $x$ to $x_{nc}$. This means an value is already assigned and cannot act as a don't care value.
% If a $x_{nc}$ is substituted this will always change that process parameter flag to \textit{variable}. 
%If a \_ is substituted the process parameter flag stays unchanged. \\ 
If a process parameter is flagged \textit{constant} and there are multiple assignments (e.g. i:=j $\wedge$ i:=\_), 
the assignment with the most specific value will be assigned. \\
Let $v_{1}$ be a value of the process parameter of a \textit{init vector} and let $v_{2}$ be a value of a 
\textit{state vector} of a summand. 
Shorthand we denote \textit{constant} as $C$ and \textit{variable} as $V$.
The rules for constructing the \textit{change vector} upon the values of $v_{1}$ and $v_{2}$ are:


\begin{enumerate}
\item $ v_{1} = v_{2} \rightarrow C $
\item $ v_{1} \neq v_{2} \rightarrow V $
\item $ v_{1} = v_{2_{nc}} \vee v_{2} == v_{2_{nc}} \rightarrow V$
\item $ v_{1} = \_  \vee v_{2} = \_ \rightarrow C $
\end{enumerate}
Note: The rule with the lowerst number has the highest priority.

\subsubsection*{Flag Rules} 
Initially all process parameters are flagged \textit{constant}.
If the value of process parameter is equal to a \textit{don't care} the corresponding flag stays unchanged.
If process parameter $x$ has a value equal to $x_{nc}$ the corresponding flag is set \textit{variable}.
If a process parameter is not equal to its initial value after rewriting, the corresponding flag is set to \textit{variable}.
In case the value of the process parameter is not changed during rewriting, the corresponding flag stays unchanged.
When comparing flags we use these rules: 
\begin{tabbing}
\verb"    " \= C $\wedge$ C $\rightarrow$ C \\
\> C $\wedge$ V $\rightarrow$ V \\
\> V $\wedge$ C $\rightarrow$ V \\
\> V $\wedge$ V $\rightarrow$ V \\
\end{tabbing}


\section{Examples}
\subsection{Example 1}
To illustrate how constelim behaves we look at the example below:
\begin{verbatim}
act  action: Nat;

proc P(i,j: Nat) =
       true -> action(i) . P(i := i + Pos2Nat(1));

init P(i := 0, j := 0);
\end{verbatim}

First we construct the \textit{init vector} form \verb"init": $\langle 0 ,0 rangle$. 
Next we mark all  process parameters to be \textit{constant}. This gives us the following \textit{flag vector}: $\langle$C,C$\rangle$.
We now process all data arguments of marked process parameters. 
Next we construct \textit{state vectors} for each summand for which the guards yield too $true$. In this example we have only one summand which always yield too $true$, so we get the following \textit{state vector}: $\langle 1, 0 \rangle$. Next we compute the \textit{state vector}. The result of the state will be: $\langle V, C \rangle$
If the conjunction over all \textit{change vectors} differs from the \textit{flag vector}, we compute the new \textit{init} and \textit{flag vector} and continue with steps 3, 4, and 5 in the algorithm. We repeat in taking these steps until the new and old \textit{flag vector} are equal to each other. Then the iteration terminates. When the iteration terminates in this example, we then have to substitute \verb"j" by \verb"0" and remove \verb"j".\\

The tabular below will show the taken computable steps: \\
\begin{tabular}{|l|l|l|l|l|l|}
\hline
step 	&  init vector 			& flag vector			& state vector 			& change vector 		& variables \\
\hline	
\hline
1 	&  $\langle 0,0 \rangle$ 	& \_				& \_				& \_				& $i=0, j=0 $ \\
\hline
2	&  $\langle 0,0 \rangle$ 	&  $\langle C,C \rangle$ 	& \_				& \_				& $i=0, j=0 $\\
\hline
3	&  $\langle 0,0 \rangle$ 	&  $\langle C,C \rangle$ 	&  $\langle i+1,j \rangle$ 	& \_				& $i=0, j=0 $\\
\hline
4	&  $\langle 0,0 \rangle$ 	&  $\langle C,C \rangle$ 	&  $\langle 1,0 \rangle$ 	&  $\langle V,C \rangle$ 	& $i=1, j=0 $\\
\hline
5	&  $\langle i_{nc},0 \rangle$ 	&  $\langle V,C \rangle$ 	&  \_				& \_ 				&  $i= i_{nc} , j=0$\\
\hline
3	&  $\langle   i_{nc} ,0 \rangle$ 	&  $\langle V,C \rangle$ 	&  $\langle   i_{nc}+1 ,0 \rangle$  			&  \_			 	& $i= i_{nc} , j=0$ \\
\hline
4	&  $\langle   i_{nc} ,0 \rangle$ 	&  $\langle V,C \rangle$ 	&  $\langle   i_{nc} ,0 \rangle$	&  $\langle V,C \rangle$  		& $i= i_{nc} , j=0 $\\
\hline
5	&  $\langle   i_{nc} ,0 \rangle$ 	&  $\langle V,C \rangle$ 	&  \_ 					& \_  					& $i= i_{nc} , j=0 $\\
\hline
6	& 					&				&					&					& \verb"j" is substituted by \verb"0" and remove all \verb"j"\\	
\hline
\end{tabular}\\

We get the following LPE:
\begin{verbatim}
    Init P(i:=0, 0);
    P(i,0) = action(i).P(i := i+1, 0); 
\end{verbatim}

\subsection{Example 2}
This example show why we need have to iteration over steps 3, 4 and 5 in the algorithm. We take the following linear process equation:
\begin{verbatim}
    Init P(i:=0, j:=0);
    P(i,j) = action(i).P(i := i+1, j := i); 
\end{verbatim} % \footnote{Generated from: \verb"Init: P(0,0)" and \verb"P(i,i:Nat) = P(i+1,i)"}
This will lead to the following sequence of steps:\\
\begin{tabular}{|l|l|l|l|l|l|}
\hline
step 	&  init vector & flag vector& state vector & change vector & variables \\
\hline
\hline
1	&  $\langle 0,0 \rangle$  		& -				& \_					& \_				& $i=0, j=0 $ \\
\hline
2	&  $\langle 0,0 \rangle$  		&  $\langle C,C \rangle$  	& \_					& \_				& $i=0, j=0 $\\
\hline
3	&  $\langle 0,0 \rangle$  		&  $\langle C,C \rangle$  	&  $\langle i+1,i \rangle$ 		& \_				& $i=0, j=0 $\\
\hline
4	&  $\langle 0,0 \rangle$ 		&  $\langle C,C \rangle$ 	&  $\langle 1,0 \rangle$  		&  $\langle V,C \rangle$ 	& $i=1, j=0 $\\
\hline
5	&  $\langle i_{nc},0 \rangle$ 		&  $\langle V,C \rangle$ 	&  \_			  		&  \_			 	& $i= i_{nc} , j=0$ \\
\hline
3	&  $\langle   i_{nc} ,0 \rangle$  		&  $\langle V,C \rangle$ 	&  $\langle   i_{nc}+1 , i_{nc}$		&  \_			  	& $i= i_{nc} , j=0$ \\
\hline
4	&  $\langle   i_{nc} ,0 \rangle$  		&  $\langle V,C \rangle$  	&  $\langle   i_{nc} , i_{nc}   \rangle$  	&  $\langle V,V \rangle$  	& $i= i_{nc} , j= i_{nc}  $\\
\hline
5	&  $\langle   i_{nc} ,j_{nc} \rangle$  		&  $\langle V,V \rangle$  	&  \_  						&  \_  				& $i= i_{nc} , j= j_{nc}  $\\
\hline
3 	&  $\langle   i_{nc} , j_{nc}   \rangle$  	&  $\langle V,V \rangle$ 	&  $\langle   i_{nc}+1 , j_{nc}   \rangle$  	&  \_			  	& $i= i_{nc} , j= j_{nc}  $\\
\hline
4	&  $\langle   i_{nc} , j_{nc}   \rangle$  	&  $\langle V,V \rangle$  	&  $\langle   i_{nc} , j_{nc}   \rangle$  	&  $\langle V,V \rangle$  	& $i= i_{nc} , j= j_{nc} $ \\
\hline
5	&  $\langle   i_{nc} , j_{nc}   \rangle$  	&  $\langle V,V \rangle$  	&  \_					  	&  \_			 	& $i= i_{nc} , j= j_{nc} $ \\
\hline
6 	& 			 			& 				& 						&				& No substitution\\
\hline
\end{tabular} \\

Now we can see why the iteration of steps 3, 4 and 5 of the algorithm are needed. The linear process equation cannot be improved by \verb"constelim".

\subsection{Example 3} 
Next we will study a case with free variables. We take the following linear process equation:
\begin{verbatim}
    act  action: Nat;

    var  k,l,m: Nat;
    proc P(state: Pos, j,i: Nat) =
           state == 1           -> action(j) . P(state := 1, j := j, i := k)
         + state == 2 && i <  5 -> action(i) . P(state := 2, j := l, i := i + Pos2Nat(1))
         + state == 2 && i == 5 -> action(i) . P(state := 1, j := i, i := m);

    var  n: Nat;
    init P(state := 2, j := n, i := 0);
\end{verbatim}
If we take a close look to this example we can see we see that \verb"n" is not initialized. No particular value is assigned, so we deal with a free variable. \newline
This will lead to the following sequence of steps:\\
\begin{tabular}{|l|l|l|l|l|l|}
\hline
step & init vector & flag vector & state vectors & change vector & variables \\
\hline
\hline
1	& $\langle 2,\_,0\rangle$ 		& \_				& \_ 										& \_				& $state=2, i=0, j=\_, k=\_, l=\_, m=\_, n=\_$ \\
\hline
2	& $\langle 2,\_,0\rangle$ 		& $\langle C,C,C\rangle$	& \_ 										& \_ 				& $state=2, i=0, j=\_, k=\_, l=\_, m=\_, n=\_$ \\
\hline
3	& $\langle 2,\_,0\rangle$ 		& $\langle C,C,C\rangle$	& $\{state=1\}\rightarrow \langle 1, j, k \rangle$				& \_				& $state=2, i=0, j=\_, k=\_, l=\_, m=\_, n=\_$ \\
	&					&				& $\{state=2 \wedge i < 5 \} \rightarrow \langle 2, l , i+1 \rangle$		& 				& \\
	&					&				& $\{state=2 \wedge i =5 \} \rightarrow \langle 1, i, m \rangle$		& 				& \\
\hline
4	& $\langle 2,\_,0\rangle$ 		& $\langle C,C,C\rangle$	& $false \rightarrow \delta$							& \_				& \_ \\
	&					&				& $\langle 2,\_,1\rangle$							& $\langle C,C,V\rangle$	& $ \bullet state=2, i=1, j=\_, k=\_, l=\_, m=\_, n=\_$ \\
	&					&				& $false \rightarrow \delta$							& \_				& \_ \\
\hline
5	&$\langle 2,\_,i=i_{nc}\rangle$		& $\langle C,C,V\rangle$	& \_										& \_				& $ state =2, i=i_{nc}, j=5, k=\_, l=\_, m=\_, n=\_$ \\
\hline
3	&$\langle 2,\_,i=i_{nc}\rangle$		& $\langle C,C,V\rangle$	& $\{state=1\}\rightarrow \langle 1, j, k \rangle$				& \_				& $ state =2, i=i_{nc}, j=5, k=\_, l=\_, m=\_, n=\_$ \\
	&					&				& $\{state=2 \wedge i < 5 \} \rightarrow \langle 2, l , i+1 \rangle$		& 				& \\
	&					&				& $\{state=2 \wedge i =5 \} \rightarrow \langle 1, i, m \rangle$		& 				& \\
\hline
4	& $\langle 2,\_,i=_{nc}\rangle$ 	& $\langle C,C,V\rangle$	& $false \rightarrow \delta$							& \_				& \_ \\
	&					&				& $\langle 2,\_,i_{nc}\rangle$							& $\langle C,C,V\rangle$	& $ \bullet state=2, i=i_{nc}, j=\_, k=\_, l=\_, m=\_, n=\_$ \\
	&					&				& $\langle 1,5,\_ \rangle$							& $\langle V,C,C\rangle$	& $ \bullet state=1, i=i_{nc}, j=5, k=\_, l=\_, m=\_, n=\_$ \\
\hline
5	&$\langle state_{nc},5,i=i_{nc}\rangle$	& $\langle V,C,V\rangle$	& \_										& \_				& $ state = state_{nc}, i=i_{nc}, j=5, k=\_, l=\_, m=\_, n=\_$ \\
\hline
3	&$\langle state_{nc},5,i=i_{nc}\rangle$	& $\langle V,C,V\rangle$	& $\{state=1\}\rightarrow \langle 1, j, k \rangle$				& \_				& $ state = state_{nc}, i=i_{nc}, j=5, k=\_, l=\_, m=\_, n=\_$ \\
	&					&				& $\{state=2 \wedge i < 5 \} \rightarrow \langle 2, l , i+1 \rangle$		& 				& \\
	&					&				& $\{state=2 \wedge i =5 \} \rightarrow \langle 1, i, m \rangle$		& 				& \\
\hline
4	&$\langle state_{nc},5,i=i_{nc}\rangle$	& $\langle V,C,V\rangle$	& $\langle 1,\_,\_ \rangle $							& $\langle V,C,V\rangle$	& $ \bullet state=state_{nc}, i=i_{nc}, j=\_, k=\_, l=\_, m=\_, n=\_$ \\ 
	&					&				& $\langle 2,\_,i_{nc}\rangle$							& $\langle C,C,V\rangle$	& $ \bullet state=state_{nc}, i=i_{nc}, j=\_, k=\_, l=\_, m=\_, n=\_$ \\
	&					&				& $\langle 1,5,\_\rangle$							& $\langle V,C,C\rangle$	& $ \bullet state=state_{nc}, i=i_{nc}, j=5, k=\_, l=\_, m=\_, n=\_$ \\
\hline
5	&$\langle state_{nc},5,i=i_{nc}\rangle$	& $\langle V,C,V\rangle$	& \_										& \_				& $ state = state_{n}, i=i_{nc}, j=5, k=\_, l=\_, m=\_, n=\_$ \\
\hline
6	&					&				&										&				&  subtitute \verb"j:=5" and remove \verb"j" \\
\hline	
\end{tabular}
The resulting algorithm:
\begin{verbatim}
    act  action: Nat;

    var  k,l,m: Nat;
    proc P(state: Pos, i: Nat) =
           state == 1           -> action(5) . P(state := 1, i := k)
         + state == 2 && i <  5 -> action(i) . P(state := 2, i := i + Pos2Nat(1))
         + state == 2 && i == 5 -> action(i) . P(state := 1, i := m);

    var  n: Nat;
    init P(state := 2, i := 0);
\end{verbatim}

\end{document}
