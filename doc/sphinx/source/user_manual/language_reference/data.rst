Data specifications
===================

.. highlight:: mcrl2 

This page describes all built-in data types with their associated functions and 
operators, and describes how custom data types can be defined.

A data specification consists of a number of *sorts*, a number of *constructors*
for each sort, a number of *mappings*, and a set of *equations*. A data 
specification is an equational specification, in which sorts denote data types. 
The semantics of a sort is a non-empty set. The elements of the semantics of a 
sort are described by its constructors, whereas the mappings are functions 
defined on the semantics of sorts. The equations (axioms) describe equational 
properties of functions and elements of the semantics.

Note that every element of the semantics of a sort can be constructed from its
constructors (this is a property also known as "no junk"). It may however be the
case that an element can be described by several constructors (in which case it
violates a property commonly known as "no confusion"). The only exception to
this are the booleans; ``true`` and ``false`` are distinct elements.


.. _sortspec:

Specifying sorts
----------------

In an mCRL2 specification, sorts may be declared in a sort specification. In the
grammar below, a sort specification is generated by the non-terminal 
:token:`SortSpec` in the grammar below.

.. dparser:: SortDecl SortSpec IdsDecl ConsSpec

Sort specifications are best understood by looking at an example. We will define
a sort ``Natural``, representing the natural numbers. We will do so by defining 
a constructor ``zero`` for it, and a successor relation ``succ``::

  sort Natural;
  cons zero: Natural;
       succ: Natural -> Natural;

Note that if we leave out the ``cons`` statement, we have still defined the sort
``Natural``. In that case, however, mCRL2 will not know anything about this sort
except that it represents a non-empty set. There are cases in which such 
underspecification can be used, for instance to model user data that passes 
through a system, but that does not influence the behaviour of a system.

The syntax of constructor specifications is given by the :token:`ConsSpec` 
non-terminal above. Every constructor for a sort *S* must be specified in a 
``cons`` block, and is specified by a name and a sort that is a mapping to *S*.
Note that *S* can be seen as a nullary mapping to *S*. 


A sort can either be one one of the 
predefined sorts, or a sort that you specified yourself (or will specify later
in the specification, as the order of the statements in an mCRL2 specification
does not change the meaning of the specification).

Let's have a look at a slightly more complicated encoding of numbers, in this
case the positive numbers. We will use the predefined sort ``Bool``, which 
consists of the (distinct) elements ``true`` and ``false``::

  sort Positive;
  cons one: Positive;
       cdub: Bool # Positive -> Positive;

If we now interpret the term :samp:`cdub(true, {num})` (where *num* is a term
of sort ``Positive``) as "twice the number that *num* represents", and interpret
:samp:`cdub(false, {num})` as "twice the number that *num* represents, plus 
one", then we have created a binary encoding of the positive numbers. For 
instance, ``cdub(false, one)`` represents the number 2, and 
``cdub(false, cdub(true, cdub(false, one)))`` represents the number 10.

.. note::

   In mCRL2, the encoding of numbers (integers, positive numbers and natural 
   numbers) is binary, much like the example above. 

.. hint::

   If you need a more complex sort than described above, you will usually be 
   able to make a :ref:`constructed sort <constructedsorts>` that suits your 
   needs.

Data expressions
----------------

.. dparser:: DataExpr DataExprList BagEnumElt BagEnumEltList IdList VarDecl 
   VarsDecl VarsDeclList Assignment AssignmentList

Specifying mappings
-------------------

Mappings, like constructors, are functions that take zero or more arguments. The
difference lies in the fact that mappings say nothing about the sort that is 
their image (where constructors show you how to construct elements of that 
sort). 

To be more precise, mappings are aliases for an element of a specific sort, and
can be specified by the following grammar:

.. dparser:: IdsDecl MapSpec

Equational specifications give further information about how the elements that
these aliases represent behave. Equational specifications are given by the 
grammar below:

.. dparser:: VarsDecl VarsDeclList VarSpec EqnDecl EqnSpec

These specifications define a conditional rewrite system. Every rewrite rule is
of the form ``c -> d = e``, where ``c`` is a condition, and ``d`` and ``e`` are
data expressions. The meaning of such a rule is that if you encounter a data
expression ``d``, and the condition ``c`` is true, then you may substitute ``e``
for ``d`` to obtain an equivalent expression.

Given sorts ``A`` and ``B``, a unary mapping ``f`` and a binary mapping ``g``
can be specified as follows::

  map f: A -> B;
      g: A # A -> B;

This statement only says that ``f`` and ``g`` are mappings, but it does not yet
say how they behave. In order to describe the behaviour of mappings, we need to
give mCRL2 an equational specification of the mapping we wish to define. As an
example, we will specify the exclusive or operation on booleans::

  map xor: Bool # Bool -> Bool;
  eqn xor(false, false) = false;
      xor(false, true) = true;
      xor(true, false) = true;
      xor(true, true) = false;

This is rather verbose if we know that we already have a definition of
inequality of booleans. We could therefore also specify it as follows::

  map xor: Bool # Bool -> Bool;
  var a, b: Bool;
  eqn xor(a, b) = a != b;



.. _predefinedsorts:

Predefined sorts
----------------

To make modelling more convenient, mCRL2 provides a number of predefined sorts.
These sorts are listed in the table below. :ref:`Standard operations 
<predefinedmappings>` are defined on all predefined sorts; these operations are
discussed in more detail elsewhere in this document.

.. table:: Basic sorts in mCRL2

   =========== =======================
   ``Bool``    Booleans
   ----------- -----------------------
   ``Pos``     Positive numbers
   ----------- -----------------------
   ``Nat``     Natural numbers
   ----------- -----------------------
   ``Int``     Integers
   ----------- -----------------------
   ``Real``    Rationals
   =========== =======================

The constants ``true`` and ``false`` are defined as the only constructors for
the sort ``Bool``.

Any :token:`Number` that occurs in mCRL2 input is interpreted as a constant of
one of the integral sorts. All datatypes, including the standard data types, are
internally represented using abstract data types. This has the advantage that
numbers do not have a limited range. In particular, there is no largest number
in any of these domains, and there are no smallest integers and reals.

.. admonition:: Example

   If the mCRL2 toolset encounters the string ``1024`` in a context where a 
   ``Pos``, ``Nat``, ``Int`` or ``Real`` was expected, then it will be 
   interpreted as the decimal number ``1024`` of sort ``Pos``, as this is the
   most specific type that matches.

.. admonition:: Example

   To specify the decimal fractional value ``3.141592``, you will need to 
   specify it as a fraction, *i.e.*, ``3141592/1000000``.

.. note::
   :class: collapse 

   Blabla

.. _constructedsorts:

Constructed sorts
-----------------

To enable users to quickly specify more complicated sorts without having to 
resort to manually specifying constructors and operations on those sorts, mCRL2
provides some standard constructs to build new sorts out of existing ones. The 
grammar of a sort specification is given by the non-terminal :token:`SortExpr`. 

.. dparser:: ProjDecl ProjDeclList ConstrDecl ConstrDeclList SortExprList 
             SortExpr

A sort is either a :ref:`predefined sort <predefinedsorts>`, a sort that was 
declared in a :ref:`sort specification <sortspec>`, or 

*Mapping sorts*

  If ``D1``, ``D2``, ..., ``DN`` are sorts, and ``I`` is a sort, then ``D1 # D2
  # ... # DN -> I`` is the sort of a mapping from the carthesian product of
  ``D1`` through ``DN`` to ``I``.

*Lists, sets and bags*
  .. table:: Container sorts in mCRL2

     =================== =======================================
     :samp:`List({S})`   Lists with elements of sort :samp:`{S}`
     ------------------- ---------------------------------------
     :samp:`Set({S})`    Sets with elements of sort :samp:`{S}`
     ------------------- ---------------------------------------
     :samp:`Bag({S})`    Bags with elements of sort :samp:`{S}`
     =================== =======================================

*Structured sorts*
  Structured sorts are a short way to specify recursive data types as are 
  commonly used in functional programming languages. They are defined 

Global variables
----------------

.. dparser:: GlobVarSpec


