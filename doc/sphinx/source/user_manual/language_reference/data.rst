Data specifications
===================

.. highlight:: mcrl2 

This page describes all built-in data types with their associated functions and 
operators, and describes how custom data types can be defined.

A data specification consists of a number of *sorts*, a number of *constructors*
for each sort, a number of *mappings*, and a set of *equations*. A data 
specification is an equational specification, in which sorts denote data types. 
The semantics of a sort is a non-empty set. The elements of the semantics of a 
sort are described by its constructors, whereas the mappings are functions 
defined on the semantics of sorts. The equations (axioms) describe equational 
properties of functions and elements of the semantics.

Note that every element of the semantics of a sort can be constructed from its
constructors (this is a property also known as "no junk"). It may however be the
case that an element can be described by several constructors (in which case it
violates a property commonly known as "no confusion"). The only exception to
this are the booleans; ``true`` and ``false`` are distinct elements.


.. _sortspec:

Specifying sorts
----------------

In an mCRL2 specification, sorts may be declared in a sort specification. In the
grammar below, a sort specification is generated by the non-terminal 
:token:`SortSpec` in the grammar below.

.. dparser:: SortDecl SortSpec IdsDecl ConsSpec

Sort specifications are best understood by looking at an example. We will define
a sort ``Natural``, representing the natural numbers. We will do so by defining 
a constructor ``zero`` for it, and a successor relation ``succ``::

  sort Natural;
  cons zero: Natural;
       succ: Natural -> Natural;

Note that if we leave out the ``cons`` statement, we have still defined the sort
``Natural``. In that case, however, mCRL2 will not know anything about this sort
except that it represents a non-empty set. There are cases in which such 
underspecification can be used, for instance to model user data that passes 
through a system, but that does not influence the behaviour of a system.

The syntax of constructor specifications is given by the :token:`ConsSpec` 
non-terminal above. Every constructor for a sort *S* must be specified in a 
``cons`` block, and is specified by a name and a sort that is a mapping to *S*.
Note that *S* can be seen as a nullary mapping to *S*. 


A sort can either be one one of the 
predefined sorts, or a sort that you specified yourself (or will specify later
in the specification, as the order of the statements in an mCRL2 specification
does not change the meaning of the specification).

.. _binaryint:

Let's have a look at a slightly more complicated encoding of numbers, in this
case the positive numbers. We will use the predefined sort ``Bool``, which 
consists of the (distinct) elements ``true`` and ``false``::

  sort Positive;
  cons one: Positive;
       cdub: Bool # Positive -> Positive;

If we now interpret the term :samp:`cdub(true, {num})` (where *num* is a term
of sort ``Positive``) as "twice the number that *num* represents", and interpret
:samp:`cdub(false, {num})` as "twice the number that *num* represents, plus 
one", then we have created a binary encoding of the positive numbers. For 
instance, ``cdub(false, one)`` represents the number 2, and 
``cdub(false, cdub(true, cdub(false, one)))`` represents the number 10.

.. note::

   In mCRL2, the encoding of numbers (integers, positive numbers and natural 
   numbers) is binary, much like the example above. 

.. hint::

   If you need a more complex sort than described above, you will usually be 
   able to make a :ref:`constructed sort <constructedsorts>` that suits your 
   needs.

Data expressions
----------------

Data expressions are descriptions of an element of a sort. Therefore, any 
closed, well-typed expression is a data expression. The full grammar is given
below. 

.. table:: Examples of data expressions

  =============================== ==========
  ``true && false``               Data expression of sort ``Bool``
  ------------------------------- ----------
  ``1981``                        Data expression of sort ``Pos`` (or ``Nat``, 
                                  ``Int`` or ``Real``)
  ------------------------------- ----------
  ``if(true, 1981, 12 + 4 / 13)`` Data expression of sort ``Real``
  =============================== ==========

.. dparser:: DataExpr DataExprList BagEnumElt BagEnumEltList IdList VarDecl 
   VarsDecl VarsDeclList Assignment AssignmentList

Specifying mappings
-------------------

Mappings, like constructors, are functions that take zero or more arguments. The
difference lies in the fact that mappings say nothing about the sort that is 
their image (where constructors show you how to construct elements of that 
sort). 

To be more precise, mappings are aliases for an element of a specific sort, and
can be specified by the following grammar:

.. dparser:: IdsDecl MapSpec

Equational specifications give further information about how the elements that
these aliases represent behave. Equational specifications are given by the 
grammar below.

.. dparser:: VarsDecl VarsDeclList VarSpec EqnDecl EqnSpec

Equation systems are optionally preceded by a ``var`` block that defines 
variables that are used in the ``eqn`` block that follows. Variables are used to
do pattern matching in equation systems. To illustrate this, let us look at a
specification of the Fibonacci sequence::

   map fib: Nat -> Nat;
   var n: Nat;
   eqn n <= 1 -> fib(n) = n;
       n > 1 -> fib(n) = fib(Int2Nat(n - 1)) + fib(Int2Nat(n - 2))
   
Going through the code line by line, we see a mapping ``fib`` being defined that
maps natural numbers to natural numbers. Then a variable ``n`` of sort ``Nat``
is declared. 

On the third line, the first rewrite rule is declared, that says that if a term 
of the form ``fib(n)`` is encountered, where ``n`` is the variable and can hence
match any term of sort ``Nat``, then it can be rewritten to the value that
matches the variable, *if* that value is at most 1. 

The second rewrite rule says that if a term of the form ``fib(n)`` is
encountered, then it can be rewritten to ``fib(Int2Nat(n - 1)) + fib(Int2Nat(n 
- 2))`` if ``n`` was larger than 1.

In the above, we need to use ``Int2Nat`` to convince the type checking system 
that ``n-1`` and ``n-2`` will indeed be natural numbers. In general this is not
true (for ``n <= 1``), but we are making the executive decision that we know 
better than the type checker, because we know that the condition of the rewrite
rule will prevent us from getting into trouble.

.. admonition:: Example (underspecification)
   :class: collapse

   Consider the following data specification::

     sort A, B;
     cons b: B;
     map f: A;
         g: B;
         h: A -> B;
     var a: A;
     eqn h(a) = b; 

   The sort ``B`` is defined as the singleton set ``{b}``, but ``A`` is left 
   unspecified. Therefore, we cannot know what element ``f`` maps to. For ``g``
   on the other hand, we know that ``g`` maps to ``b``, as it is the only
   element of ``B``, but as this is not specified in the equational
   specification, mCRL2 will not detect this. However, the data expression
   ``h(f)`` will be rewritten to ``b``, as it matches the only rule in this
   equation system.

.. admonition:: Example (rewrite rules)
   :class: collapse

   In order to describe the behaviour of mappings, we need to
   give mCRL2 an equational specification of the mapping we wish to define. As an
   example, we will specify the exclusive or operation on booleans::

    map xor: Bool # Bool -> Bool;
    eqn xor(false, false) = false;
        xor(false, true) = true;
        xor(true, false) = true;
        xor(true, true) = false;

   This is rather verbose if we know that we already have a definition of
   inequality of booleans. We could therefore also specify it as follows::

     map xor: Bool # Bool -> Bool;
     var a, b: Bool;
     eqn xor(a, b) = a != b;

   Yet another way of specifying the same mapping would be to use the rewrite
   conditions to test for equality::

     map xor: Bool # Bool -> Bool;
     var a, b: Bool;
     eqn a == b -> xor(a, b) = false;
         a != b -> xor(a, b) = true;

.. warning::

   Functional programmers might have written down the following specification for
   the Fibonacci sequence::

     map fib: Nat -> Nat;
     var n: Nat;
     eqn fib(0) = 0;
         fib(1) = 1;
         fib(n + 2) = fib(n) + fib(n + 1);

   This, however, will not work in mCRL2: ``fib(10)`` will not rewrite at all. 
   The reason is that the pattern matching used in the rewrite system fails to 
   match ``n + 2`` to ``10``, because the number 10 is internally represented
   using a :ref:`binary encoding <binaryint>`, and therefore has a different
   structure than ``n + 2``.

   This kind of pattern matching can still be used, but it is advisable to only
   match terms that consist of only constructors and variables. One particularly
   useful example is that of lists, for which the constructors ``[]`` and ``|>``
   are defined::

     map remove: List(Nat) # Nat -> Nat;
     var x, y: Nat;
         l: List(Nat);
     eqn remove(x, []) = [];
         x == y -> remove(x |> l, y) = l;
         x != y -> remove(x |> l, y) = x |> remove(l, y);

.. _predefinedsorts:

Predefined sorts
----------------

To make modelling more convenient, mCRL2 provides a number of predefined sorts.
These sorts are listed in the table below. :ref:`Standard operations 
<predefinedmappings>` are defined on all predefined sorts; these operations are
discussed in more detail elsewhere in this document.

.. table:: Basic sorts in mCRL2

   =========== =======================
   ``Bool``    Booleans
   ----------- -----------------------
   ``Pos``     Positive numbers
   ----------- -----------------------
   ``Nat``     Natural numbers
   ----------- -----------------------
   ``Int``     Integers
   ----------- -----------------------
   ``Real``    Rationals
   =========== =======================

The constants ``true`` and ``false`` are defined as the only constructors for
the sort ``Bool``.

Any :token:`Number` that occurs in mCRL2 input is interpreted as a constant of
one of the integral sorts. All datatypes, including the standard data types, are
internally represented using abstract data types. This has the advantage that
numbers do not have a limited range. In particular, there is no largest number
in any of these domains, and there are no smallest integers and reals.

.. admonition:: Example

   If the mCRL2 toolset encounters the string ``1024`` in a context where a 
   ``Pos``, ``Nat``, ``Int`` or ``Real`` was expected, then it will be 
   interpreted as the decimal number ``1024`` of sort ``Pos``, as this is the
   most specific type that matches.

.. admonition:: Example

   To specify the decimal fractional value ``3.141592``, you will need to 
   specify it as a fraction, *i.e.*, ``3141592/1000000``.

.. note::
   :class: collapse 

   Blabla

.. _constructedsorts:

Constructed sorts
-----------------

To enable users to quickly specify more complicated sorts without having to 
resort to manually specifying constructors and operations on those sorts, mCRL2
provides some standard constructs to build new sorts out of existing ones. The 
grammar of a sort specification is given by the non-terminal :token:`SortExpr`. 

.. dparser:: ProjDecl ProjDeclList ConstrDecl ConstrDeclList SortExprList 
             SortExpr

A sort is either a :ref:`predefined sort <predefinedsorts>`, a sort that was 
declared in a :ref:`sort specification <sortspec>`, or 

*Mapping sorts*

  If ``D1``, ``D2``, ..., ``DN`` are sorts, and ``I`` is a sort, then ``D1 # D2
  # ... # DN -> I`` is the sort of a mapping from the carthesian product of
  ``D1`` through ``DN`` to ``I``.

*Lists, sets and bags*
  .. table:: Container sorts in mCRL2

     =================== =======================================
     :samp:`List({S})`   Lists with elements of sort :samp:`{S}`
     ------------------- ---------------------------------------
     :samp:`Set({S})`    Sets with elements of sort :samp:`{S}`
     ------------------- ---------------------------------------
     :samp:`Bag({S})`    Bags with elements of sort :samp:`{S}`
     =================== =======================================

*Structured sorts*
  Structured sorts are a short way to specify recursive data types as are 
  commonly used in functional programming languages. They are defined 

Global variables
----------------

.. dparser:: GlobVarSpec


