%% file watercan.mcrl2

act

  empty, fill, done,a;
  tocan, fromcan, pour, go: Nat # Nat # Nat # Nat # Nat # Nat;

map 
  target,bound: Nat;
eqn 
  target = 4;
  bound = 10;

proc

  Can(n:Nat,m:Nat) =
    (m > 0) -> (empty . Can(n,0)) +
    (m < n) -> (fill . Can(n,n))  + a.Can(n,m) +
    ( m != target ) -> (
      sum l,x,y,z:Nat . ( 
        ((l <= n) && (y <= z) && (z <= x) && (x <= bound)) ->
          tocan(n,m,l,x,y,z) . Can(n,l) ) +
     sum x,y,z,l:Nat . ( 
        ((l <= n) && (y <= x) && (z <= x) && (x <= bound)) ->
          fromcan(x,y,z,n,m,l) . Can(n,l) )
    ) <> done;

  Pour =
    sum n,m,l,x,y,z:Nat .
      (m > 0 && m <= n && l <= n && n <= bound && y <= x && z <= x && x <= bound) -> (
        (m <= x-y) -> (
          pour(n,m,0,x,y,Int2Nat(y+m)) . Pour 
        ) <> (
          pour(n,m,Int2Nat(m-x+y),x,y,x) . Pour
        ));

init

  allow( 
    { go, empty, fill,a },
  comm(
    { tocan|fromcan|pour -> go },
  Can(8,0) || Can(5,0) || Pour
    ));
