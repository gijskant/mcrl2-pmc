Water cans
----------

**Contribution of this section**

#. use of standard data types, and
#. use of simulator.

**New tools**:
:ref:`lpsxsim`.

Two water cans of known capacity, say of ``x`` and of ``y`` liters, a tap
and a sink are at our disposal. The cans do not have a graduation to
measure their content. The challenge is to pace an exact volume of
water, say of ``z`` liter, in one of the cans.

Given the description, there are basically four things one can do with
a can:

* to empty the can in the sink, which makes only sense if the can
  is non-empty;
* to fill the can completely from the tap, a proper thing to do
  for a can that is not full already
* to pour from the can into the other, provided there is water in
  the can;
* to fill the can by pouring from the other can, assuming the
  first is not brimful yet.

So, somehow we need to keep track of the actual content of the water
cans, to see if an empty-to-sink action or an pour-to-other action can
be done with the can, or that a fill-from-tap action or a
fill-from-other action applies.

Processes in mCRL2 may carry one or more parameters. We can
write, for example, ``BigCan(3)`` to express that the bigger of
the two watercans contains 3~liter. In the process definition we need
to declare the parameter, e.g. we write ``BigCan(m:Nat) = ... ``
to have for ``BigCan`` the variable ``m`` ranging over the
naturals, that include ``0``.

Similary, actions can have parameters. Here, we have occasion to
express that ``l`` liters of waters have been poured out. If the
action``lose`` denotes the pouring out, we do this by writing
``lose(l)``. In the definition of the action ``lose``
we need to indicate the parameter, e.g. by writing ``lose: Nat``
in the ``act`` part of the mCRL2 specification. Thus,
``l`` ranges over non-negative integer values.

For the concrete case of cans of ``5`` and ``8`` liter to yield ``4`` liters, a
first approximation may be as follows:

.. code-block:: mcrl2

  act

    empty, fill, done;
    lose, gain, pour: Nat;

  proc

    BigCan(m:Nat) =
      ( m != 4 ) -> (
        %% some code for the big can
      ) <> done ; 

    SmallCan(m:Nat) =
      ( m != 4 ) -> (
        %% some code for the small code
      ) <> done ; 

  init

    allow( 
      { empty, fill, pour },
    comm(
      { lose|gain -> pour },
    BigCan(0) || SmallCan(0) 
      ));

In this set-up, a ``lose`` action by the one can will synchronize
with a ``gain`` action by the other can, together synchronizing
as a ``pour`` action. The three actions all carry a parameter of
type ``Nat``, that needs to be equal for synchronization to
succeed. 

Another choice made above is the test whether the current content of
the required volume to pace. If no, we do some activity left
unspecified here, if yes we do the action ``done``. The general
form of the if-then-else construction in mCRL2 is ``c -> p <> q``
for condition ``c`` and processes ``p`` and ``q``.

One may wonder in what way the specification for the ``BigCan``
process will differ from that for the``SmallCan``. It seems more
appealling to make the capacity of the can a parameter too. An
incomplete specification of a solution of the watercan problem is
the following (also available as :download:`files/watercan1-incomplete.mcrl2`).
The term ``Can(n,m)`` indicates that a can of capacity ``n`` is currently holding a
volume of ``m``.

.. literalinclude:: files/watercan1-incomplete.mcrl2
   :language: mcrl2

An LTS generated by :ref:`mcrl22lps` and :ref:`lps2lts` has 46
states and 265 transitions. The property
``<true*.done> true``, asking whether it is possible to do the
``done`` action, is confirmed by model checking.

We can get some more feedback on what is going on by using the
simulator :ref:`lpsxsim` with which we can step through the LTS and
follow the the values of parameters. Calling at the command line the
:ref:`lpsxsim` tool with the linear process 
:file:`watercan01.lps`, produced by the :ref:`mcrl22lps` tool from
the mCRL2-specification :file:`watercan01.mcrl2`, by typing::

  $ lpsxsim watercan01.lps

opens an application with two smaller windows, the top one listing
possible transitions, the bottom one listing the values of the
parameters in the current state. Parameters have symbolic names as a
result of the linearization process. It looks similar to

  +-------------------------------------------------+
  | Transitions                                     |
  +==============+==================================+
  | *Action*     | *State Change*                   |
  +--------------+----------------------------------+
  | ``fill``     | ``s31_Can1 := 2, m_Can11 := 8;`` |
  +--------------+----------------------------------+
  | ``fill``     | ``s3_Can1 :=2, m_Can1 := 5;``    |
  +--------------+----------------------------------+
  | **Current state**                               |
  +--------------+----------------------------------+
  | *Parameter*  | *Value*                          |
  +--------------+----------------------------------+
  | ``s3_Can1``  | 1                                |
  +--------------+----------------------------------+
  | ``n_Can1``   | 5                                |
  +--------------+----------------------------------+
  | ``m_Can1``   | 0                                |
  +--------------+----------------------------------+
  | ``s31_Can1`` | 1                                |
  +--------------+----------------------------------+
  | ``n_Can11``  | 8                                |
  +--------------+----------------------------------+
  | ``m_Can11``  | 0                                |
  +--------------+----------------------------------+

By double clicking on a transition, the transition can be taken. For
example, clicking on the top ``fill`` transition yields a new
list of transitions and an update current state. Now, besides a
``fill`` action also the actions ``empty``, ``pour(1)``
to ``pour(5)`` are possible. The state now holds, e.g., the
value``8`` for the contents ``m_Can11`` for the bigger
can, as a result of the ``fill`` action.

The simulator reveals that we have made a mistake. Given a full can of
8~liter and an empty can of~5, the only volume we can pour
from the bigger can into the smaller can is the volume of 5~liters, as
no measure is available on the cans. Our specification, however,
allows for all volumes from~1 upto 5~liters. Pacing 4~liters would
then be easy, just pour 4~liters into the smaller can.

We can restrict the possible volumes that are poured over, by noting
that either (i)~the complete content of a can is poured into the other
provided the latter can can hold, (ii)~an amount of water is poured
from a can into the other such that the other can is brimful. Hence,
the minimum of the content of the from-can and the remaining capacity
of the to-can determines the amount of water that is going from the
one can to the other by pouring.

The basic idea then is to distinguish between an action
``lose_all`` and an action ``lose_some`` for pouring into
the other can, and between an action ``gain_all`` and
``gain_some`` for getting from the other can. These actions will
have a parameter for the amount of water involved. An action
``lose_all(m)`` synchronizes with the action
``gain_some(m)``, with ``m`` liters in the first can; the
action ``lose_some(n-m)`` matches the action
``gain_all(n-m)``, now with ``n`` liters and
``m`` liters as capacity and current content of the second can,
respectively. As synchronization function we will then have
``lose_all | gain_some -> pour`` as well as
``lose_some | gain_all -> pour``. So, ``pour`` actions can be the result of
two pairings of actions, ``lose_all`` with ``gain_some``
and ``lose_some`` with ``gain_all``. This process is described in the following
specification (also available as :download:`files/watercan2.mcrl2`).

.. literalinclude:: files/watercan2.mcrl2
   :language: mcrl2

In the specifcation above a further modification has been done.
The names ``A`` and ``B`` have been introduced for the cans. At
the start of the specification a new sort is introduced, viz. the
sort name. It is an enumeration sort, following the format

.. code-block:: mcrl2

  <sort name> = struct entity 1 | entity 2 | ... | entity k ;
  
Here we have two entities, the name ``A`` and the
name ``B``, hence ``k`` equals 2. The new actions have been
added, but also they can carry the name or names of cans
involved. E.g., the action ``empty(A)`` indicates that
can ``A`` has been emptied, ``done(B)`` indicates that the
target value has been left in can ``B``, whereas
``lose_all(B,A,3)`` represent that all of the current content of
can ``B``, apparently 3~liters, will be poured into
can ``A``. Therefore, the sort of the actions ``empty`` and
``done`` is ``Name``, as they take a name as parameter, the
sort of the action ``lose_all`` is ``Name # Name # Nat`` as
the actions takes two names and a natural number as parameter.
The summations in the mCRL2 specification, now quantify over
the name of the other can, called ``M``, and exclude to pour from
the can in itself by demanding ``M != N``.

We also have occasion to introduce constants. The is a specific use of
the facilities of mCRL2 in supporting abstract data
types. Here, after the keyword ``map`` we introduce three
constants over the natural numbers, called ``sizeA``,
``sizeB`` and ``target``. Next, following the keyword
``eqn``, we define them to hold the values ``5``, ``8``
and ``4``, respectively. The corresonding LTS has 35 states and
94 transitions. The LTS of a smaller example, can sizes 4 and 3 and
target volume 2 with 18 states and 46 transitions after reduction modulo
strong bisimulation is depicted in Figure :ref:`fig-watercan03`.

.. _fig-watercan3:

.. figure:: img/watercan03.*
   :align: center
   :width: 100%
   
   LTS of watercan example with cans of 4 and 3 liters and target volume of 2 liters.
