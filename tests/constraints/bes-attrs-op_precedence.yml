bes:
  order: left
  rules:
    - BesEqnSpec.V = []
    - BesInit.V = BesEqnSpec.V

eqndecls:
  order: left
  attrs: V
  rules:
    - BesEqnDecls.V = V
  
eq:
  order: left
  attrs: V
  rules:
    - BesEqnDecl.V = V
  
eqs:
  order: left
  attrs: V
  rules:
    - BesEqnDecl.V = V
    - BesEqnDecls.V = BesEqnDecl.V
  post:
    - V = BesEqnDecls.V

eqdecl:
  order: left
  attrs: V
  pre:
    - K = 'X' + str(len(V)+1)
    - V.append(K)
  rules:
    - BesVar = K
    - BesExpr.V = V
    - BesExpr.M = True

be_impl:
  order: left
  attrs: [V, M]
  rules:
    - BesTerm.V = V
    - BesTerm.M = not M
    - BesExpr.V = V
    - BesExpr.M = M

be_term:
  attrs: [V, M]
  rules:
    - BesTerm.V = V
    - BesTerm.M = M

be_disj:
  order: right
  attrs: [V, M]
  rules:
    - BesTerm.V = V
    - BesTerm.M = M
    - BesFactor.V = V
    - BesFactor.M = M

be_conj:
  order: right
  attrs: [V, M]
  rules:
    - BesTerm.V = V
    - BesTerm.M = M
    - BesFactor.V = V
    - BesFactor.M = M

be_fac:
  attrs: [V, M]
  rules:
    - BesFactor.V = V
    - BesFactor.M = M

be_true:
  order: left
  attrs: [V, M]

be_false:
  order: left
  attrs: [V, M]

be_neg:
  order: left
  attrs: [V, M]
  rules:
    - BesFactor.V = V
    - BesFactor.M = not M
  
be_brk:
  order: left
  attrs: [V, M]
  rules:
    - BesExpr.V = V
    - BesExpr.M = M
  
be_var:
  secondpass: bes
  order: left
  attrs: [V, M]
  pre:
    - K = '!' if not M else ''
  rules:
    - BesVar = K + choice(V)

init:
  order: left
  attrs: V
  rules:
    - BesVar = choice(V)
  
  