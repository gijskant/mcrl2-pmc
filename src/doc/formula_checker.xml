<refentry id="formula_checker">
 <info>
  <date>2005-2007</date>
 </info>

<refmeta>
 <refentrytitle>formula_checker</refentrytitle>
 <manvolnum>7</manvolnum>
 <refmiscinfo class="source">formula_checker</refmiscinfo>
 <refmiscinfo class="version"></refmiscinfo>
 <refmiscinfo class="manual">Library Functions</refmiscinfo>
</refmeta>

<refnamediv>
<refname>formula_checker</refname>
<refpurpose>a class that checks expressions of sort Bool</refpurpose>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcprototype>
  <funcdef>&formula_checker_constructor;</funcdef>
  <paramdef>&type_atermappl; &par_lps;</paramdef>
  <paramdef>&type_rewrite_strategy; &par_rewrite_strategy; = &strat_jitty;</paramdef>
  <paramdef>&type_int; &par_time_limit; = 0</paramdef>
  <paramdef>&type_bool; &par_path_eliminator; = &const_false;</paramdef>
  <paramdef>&type_smt_solver_type; &par_solver_type; = &solver_ario;</paramdef>
  <paramdef>&type_bool; &par_apply_induction; = &const_false;</paramdef>
  <paramdef>&type_bool; &par_counter_example; = &const_false;</paramdef>
  <paramdef>&type_bool; &par_witness; = &const_false;</paramdef>
  <paramdef>&type_char_string; &par_dot_file_name; = 0</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&type_void; &formula_checker_check_formulas;</funcdef>
  <paramdef>&type_atermlist; &par_formulas;</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>
<para>
  The class &class_formula_checker; is initialized with a specification of data equations in internal mCRL2 format using the constructor
  &formula_checker_constructor;.
  After initialization, the function &formula_checker_check_formulas; can be called any number of times to check whether the expressions of sort 
  &sort_bool; in internal mCRL2 format in the list passed as parameter &par_formulas; are tautologies or contradictions.
</para>
<para>
  The class &class_formula_checker; uses an instance of the class &class_bdd_prover; to prove a number of propositional formulas. The prover is
  initialized with the parameters &par_rewrite_strategy;, &par_time_limit;,
  &par_path_eliminator;, &par_solver_type;, &par_apply_induction; and &par_lps;. The
  parameter &par_rewrite_strategy; specifies which rewrite strategy is used by the prover's rewriter. It can be set to either
  &const_strat_inner;, &const_strat_innerc;, &const_strat_jitty; or &const_strat_jittyc;. The parameter &par_time_limit; specifies the maximum
  amount of time in seconds to be spent by the prover on proving a single formula. If &par_time_limit; is set to 0, no time limit will be enforced.
  The parameter &par_path_eliminator; specifies whether or not path elimination is applied. When path elimination is applied, the prover uses an
  SMT solver to remove inconsistent paths from BDDs. The parameter &par_solver_type; specifies which SMT solver is used for path elimination.
  Either
  the SMT solver &solver_ario-lnk; or &solver_cvc_lite-lnk; can be used.
  To use one of these solvers, the directory containing the corresponding
  executable must be in the path. If the parameter &par_path_eliminator; is set to &const_false;, the parameter &par_solver_type; is ignored.
  The parameter &par_time_limit; specifies the data equations used by the prover's rewriter. The parameter &par_apply_induction;
  indicates whether or not induction on list will be applied.
</para>
<para>
  The parameter &par_dot_file_name;
  specifies whether a file in dot format of the resulting BDD is saved each time the prover cannot determine whether an expression of sort 
  &sort_bool; is a contradiction
  or a tautology. If the parameter is set to 0, no .dot files are saved. If a string is passed as parameter &par_dot_file_name;, this string will
  be used as the prefix of the filenames. An instance of the class &class_bdd2dot; is used to save these files in dot format.
</para>
<para>
  If the parameter &par_counter_example; is set to &const_true;, a so called counter example is printed to &stderr; each time an expression is
  encountered that is neither a contradiction nor a tautology. A counter example is a valuation for which
  the expression does not hold.
</para>
<para>
  If the parameter &par_witness; is set to &const_false;, a so called witness is printed to &stderr; each time such an expression is
  encountered. A witness is a valuation for which the expression holds.
</para>
<para>
  The function &formula_checker_check_formulas; prints information to &stderr; indicating whether the expressions in the list of formulas passed as
  parameter &par_formulas; are tautologies or contradictions.
  In some cases the BDD based prover may be unable to determine whether an expression is a tautology or a
  contradiction. If this is the case, the function &formula_checker_check_formulas; will print information to &stderr; indicating this fact.
</para>
</refsect1>

<refsect1>
<title>Preconditions</title>
<para>
  The following precondition has to be satisfied for &formula_checker_constructor;:
  <itemizedlist>
    <listitem>
      <para>the argument passed as parameter &par_lps; is an LPS</para>
    </listitem>
    <listitem>
      <para>
        the argument passed as parameter &par_time_limit; is greater than or equal to 0. If the argument is equal to 0, no time limit will be
        enforced
      </para>
    </listitem>
  </itemizedlist>
</para>
<para>
The following precondition has to be satisfied for &formula_checker_check_formulas;:
<itemizedlist>
  <listitem>
    <para>the parameter &par_formulas; is a list of expressions of sort &sort_bool; in internal mCRL2 format</para>
  </listitem>
</itemizedlist>
</para>
</refsect1>

<refsect1>
<title>Author</title>
<para>
  Written by Luc Engelen. Please send all complaints, comments and bug reports to &bugmail;.
</para>
</refsect1>

</refentry>
