<?xml version="1.0"?>

<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN" "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd"[
<!ENTITY % param SYSTEM "param.xml">
%param;
<!ENTITY virtual "<type>virtual</type>">
<!ENTITY tconst "<type>const</type>">
<!ENTITY tvoid "<type>void</type>">
<!ENTITY tcbool "<type>bool</type>">
<!ENTITY tpchar "<type>char*</type>">
<!ENTITY taterm "<type>ATerm</type>">
<!ENTITY trewrstrat "<type>RewriteStrategy</type>">
<!ENTITY tRewriter "<type>Rewriter</type>">
<!ENTITY tpRewriter "<type>Rewriter *</type>">
<!ENTITY Rewriter_constructor "<function>Rewriter::Rewriter</function>">
<!ENTITY Rewriter_destructor "<function>Rewriter::~Rewriter</function>">
<!ENTITY Rewriter_rewr "<function>Rewriter::rewrite</function>">
<!ENTITY Rewriter_rewrlist "<function>Rewriter::rewriteList</function>">
<!ENTITY Rewriter_toInt "<function>Rewriter::toRewriteFormat</function>">
<!ENTITY Rewriter_fromInt "<function>Rewriter::fromRewriteFormat</function>">
<!ENTITY Rewriter_rewrInt "<function>Rewriter::rewriteInternal</function>">
<!ENTITY Rewriter_rewrIntlist "<function>Rewriter::rewriteInternalList</function>">
<!ENTITY Rewriter_addRule "<function>Rewriter::addRewriteRule</function>">
<!ENTITY Rewriter_remRule "<function>Rewriter::removeRewriteRule</function>">
<!ENTITY Rewriter_setsubst "<function>Rewriter::setSubstitution</function>">
<!ENTITY Rewriter_getsubst "<function>Rewriter::getSubstitution</function>">
<!ENTITY Rewriter_clearsubst "<function>Rewriter::clearSubstitution</function>">
<!ENTITY Rewriter_clearsubsts "<function>Rewriter::clearSubstitutions</function>">
<!ENTITY createRewriter "<function>createRewriter</function>">
<!ENTITY RewriteStrategyFromString "<function>RewriteStrategyFromString</function>">
<!ENTITY parDataEqnSpec "<parameter>DataEqnSpec</parameter>">
<!ENTITY parStrategy "<parameter>Strategy</parameter>">
<!ENTITY parVar "<parameter>Var</parameter>">
<!ENTITY parExpr "<parameter>Expr</parameter>">
<!ENTITY parRule "<parameter>Rule</parameter>">
<!ENTITY parTerm "<parameter>Term</parameter>">
<!ENTITY parTerms "<parameter>Terms</parameter>">
<!ENTITY parS "<parameter>s</parameter>">
<!ENTITY stratINNER "<constant>GS_REWR_INNER</constant>">
<!ENTITY stratINNERstring "<constant>inner</constant>">
<!ENTITY stratINNERC "<constant>GS_REWR_INNERC</constant>">
<!ENTITY stratJITTY "<constant>GS_REWR_JITTY</constant>">
<!ENTITY stratINVALID "<constant>GS_REWR_INVALID</constant>">
<!ENTITY gsEnableConstructorFunctions "<function>gsEnableConstructorFunctions</function>">
]>

<refentry id="librewrite">

<refmeta>
<refentrytitle>librewrite</refentrytitle>
<manvolnum>7</manvolnum>
</refmeta>

<refnamediv>
<refname>librewrite</refname>
<refpurpose>a mCRL2 library for rewriting data expressions.</refpurpose>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include "librewrite.h"
</funcsynopsisinfo>
<funcprototype>
  <funcdef>&Rewriter_constructor;</funcdef>
  <paramdef>&tvoid;</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&virtual; &Rewriter_destructor;</funcdef>
  <paramdef>&tvoid;</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&virtual; &tatermappl; &Rewriter_rewr;</funcdef>
  <paramdef>&tatermappl; &parTerm;</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&virtual; &tatermlist; &Rewriter_rewrlist;</funcdef>
  <paramdef>&tatermlist; &parTerms;</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&virtual; &taterm; &Rewriter_toInt;</funcdef>
  <paramdef>&tatermappl; &parTerm;</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&virtual; &tatermappl; &Rewriter_fromInt;</funcdef>
  <paramdef>&taterm; &parTerm;</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&virtual; &taterm; &Rewriter_rewrInt;</funcdef>
  <paramdef>&taterm; &parTerm;</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&virtual; &tatermlist; &Rewriter_rewrIntlist;</funcdef>
  <paramdef>&tatermlist; &parTerms;</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&virtual; &tcbool; &Rewriter_addRule;</funcdef>
  <paramdef>&tatermappl; &parRule;</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&virtual; &tcbool; &Rewriter_remRule;</funcdef>
  <paramdef>&tatermappl; &parRule;</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&virtual; &tvoid; &Rewriter_setsubst;</funcdef>
  <paramdef>&tatermappl; &parVar;</paramdef>
  <paramdef>&taterm; &parExpr;</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&virtual; &taterm; &Rewriter_getsubst;</funcdef>
  <paramdef>&tatermappl; &parVar;</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&virtual; &tvoid; &Rewriter_clearsubst;</funcdef>
  <paramdef>&tatermappl; &parVar;</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&virtual; &tvoid; &Rewriter_clearsubsts;</funcdef>
  <paramdef>&tvoid;</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&trewrstrat; &RewriteStrategyFromString;</funcdef>
  <paramdef>&tconst; &tpchar; &parS;</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&tpRewriter; &createRewriter;</funcdef>
  <paramdef>&tatermappl; &parDataEqnSpec;</paramdef>
  <paramdef>&trewrstrat; &parStrategy;</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>
<para>
The librewrite library provides a rewrite system for mCRL2 data expressions (only after data implementation). To use it, one creates a &tRewriter; class through the &createRewriter; function. The created rewriter is initialised with the equations from &parDataEqnSpec;, which are used as rewrite rules, and a rewriter strategy &parStrategy; (see below). After creation, one can still add or remove an rewrite rule &parRule; with the functions &Rewriter_addRule; and &Rewriter_remRule;. The latter removes (all occurrences of) &parRule; from the rules used by the rewrite system.
</para>
<para>
To actually rewrite a data expression, the functions &Rewriter_rewr; and &Rewriter_rewrlist; can be used. The function &Rewriter_rewr; rewrites a single mCRL2 data expression &parTerm;, while &Rewriter_rewrlist; rewrites every expression in the list &parTerms;. Because the rewriters use their own internal format for data expressions (for more efficient rewriting), every call to &Rewriter_rewr; or &Rewriter_rewrlist; results in an implicit conversion to and from the internal format before, respectively after the actual rewriting. When rewriting is a critical part of an application, it is wise to explicitly convert the data expressions before repeated calls on such an expression. This is done with the functions &Rewriter_toInt; and &Rewriter_fromInt;. (Note that the expression in the internal format is an &taterm; instead of an &tatermappl;.) Terms in the internal format can be rewritten with the function &Rewriter_rewrInt; and &Rewriter_rewrIntlist; (analogous to &Rewriter_rewr; and &Rewriter_rewrlist;).
</para>

<refsect2>
<title>Strategies</title>
<para>
Currently, there are three different rewriting strategies available in librewrite. A standard innermost rewriting strategy is available under the name &stratINNER;. This strategy will fit most non critical rewriting uses, such as simulation, (simple) LPE manipulation and generation of (very) small state spaces. For time critical uses, there is a compiling innermost rewriting strategy &stratINNERC;. With this strategy, the creation of a &tRewriter; object will result in the compilation of an optimised rewriter. This does mean that gcc and the appropriate headers and libraries must be available.
</para>
<para>
An alternative to &stratINNER; is the JITty rewriter &stratJITTY;. This strategy can avoid a lot of unnecessary rewriting in certain cases and can handle some rewrite rules that cause the innermost rewriters to rewrite infinitely.
</para>
<para>
To convert a string representation of a strategy to a &trewrstrat;, one can use &RewriteStrategyFromString;. This is useful for converting command line arguments, specifying a rewrite strategy. The string representations are derived from there &trewrstrat; name by taking the last part and writing it in lower case (e.g. &stratINNERstring; for &stratINNER;). If the supplied string does not match any of the available strategies, &stratINVALID; is returned. Note that it is not allowed to supply &stratINVALID; to &createRewriter;.
</para>
</refsect2>

<refsect2>
<title>Implicit variable substitutions</title>
<para>
For efficient variable substitutions, a rewriter supplies some special functions. Instead of first substituting values for variables in a term and then rewriting the result, one can also set such a variable &parVar; to an expression &parExpr; with &Rewriter_setsubst;, which does nothing but storing this information, and rewrite the desired term afterwards, with the same effect. With &Rewriter_getsubst; one can retreive the expression a variable has been set to (or the variable itself, if the variable was not set). To clear a set variable &parVar; one can call &Rewriter_clearsubst; (or &Rewriter_clearsubsts; to clear all substitutions).
</para>
<para>
Note that &parExpr; has to be in the internal format of the rewriter.
</para>
</refsect2>

</refsect1>

<refsect1>
<title>Preconditions</title>
<para>
The following preconditions have to be satisfied for all functions, except &RewriteStrategyFromString;:
<itemizedlist>
  <listitem>
    <para>the &aterm; library is initialised</para>
  </listitem>
  <listitem>
    <para>&gsEnableConstructorFunctions; has been called</para>  
  </listitem>
</itemizedlist>
</para>
<para>
The following preconditions have to be satisfied for &createRewriter;:
<itemizedlist>
  <listitem>
    <para>&parDataEqnSpec; is a DataEqnSpec from a mCRL2 specification (after data implementation)</para>
  </listitem>
  <listitem>
    <para>&parStrategy; is not &stratINVALID;</para>
  </listitem>
</itemizedlist>
</para>
<para>
The following precondition has to be satisfied for &Rewriter_addRule; and &Rewriter_remRule;:
<itemizedlist>
  <listitem>
    <para>&parRule; is a DataEqn (after data implementation)</para>
  </listitem>
</itemizedlist>
</para>
<para>
The following precondition has to be satisfied for &Rewriter_rewr; and &Rewriter_toInt;:
<itemizedlist>
  <listitem>
    <para>&parTerm; is a DataExpr (after data implementation)</para>
  </listitem>
</itemizedlist>
</para>
<para>
The following precondition has to be satisfied for &Rewriter_rewrInt; and &Rewriter_fromInt;:
<itemizedlist>
  <listitem>
    <para>&parTerm; is a data expression in the internal rewriter format</para>
  </listitem>
</itemizedlist>
</para>
<para>
The following precondition has to be satisfied for &Rewriter_rewrlist;:
<itemizedlist>
  <listitem>
    <para>&parTerms; is a ATermList of DataExprs (after data implementation)</para>
  </listitem>
</itemizedlist>
</para>
<para>
The following precondition has to be satisfied for &Rewriter_rewrIntlist;:
<itemizedlist>
  <listitem>
    <para>&parTerm; is a ATermList of data expressions in the internal rewriter format</para>
  </listitem>
</itemizedlist>
</para>
<para>
The following precondition has to be satisfied for &Rewriter_setsubst;, &Rewriter_getsubst; and &Rewriter_clearsubst;:
<itemizedlist>
  <listitem>
    <para>&parVar; is a DataVarId (after data implementation)</para>
  </listitem>
</itemizedlist>
</para>
<para>
The following precondition has to be satisfied for &Rewriter_setsubst;:
<itemizedlist>
  <listitem>
    <para>&parExpr; is a data expression in the internal rewriter format</para>
  </listitem>
</itemizedlist>
</para>
</refsect1>

<refsect1>
<title>Known issues</title>
<para>
Files generated by the compiling rewriter (&stratINNERC;) are not removed after usage.
</para>
</refsect1>

<refsect1>
<title>Author</title>
<para>
Written by Muck van Weerdenburg. Please send all complaints, comments and bug fixes to <email>bug@mcrl2.org</email>.
</para>
</refsect1>

</refentry>
