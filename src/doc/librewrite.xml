<refentry id="librewrite">
 <info>
  <date>2005-2007</date>
 </info>

<refmeta>
 <refentrytitle>rewrite</refentrytitle>
 <manvolnum>7</manvolnum>
 <refmiscinfo class="source">rewrite</refmiscinfo>
 <refmiscinfo class="version"></refmiscinfo>
 <refmiscinfo class="manual">Library Functions</refmiscinfo>
</refmeta>

<refnamediv>
<refname>librewrite</refname>
<refpurpose>a mCRL2 library for rewriting data expressions.</refpurpose>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcsynopsisinfo>
#include "librewrite.h"
</funcsynopsisinfo>
<funcprototype>
  <funcdef>&Rewriter_constructor;</funcdef>
  <paramdef>&type_void;</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&virtual; &Rewriter_destructor;</funcdef>
  <paramdef>&type_void;</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&virtual; &type_atermappl; &Rewriter_rewr;</funcdef>
  <paramdef>&type_atermappl; &parTerm;</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&virtual; &type_atermlist; &Rewriter_rewrlist;</funcdef>
  <paramdef>&type_atermlist; &parTerms;</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&virtual; &type_aterm; &Rewriter_toInt;</funcdef>
  <paramdef>&type_atermappl; &parTerm;</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&virtual; &type_atermappl; &Rewriter_fromInt;</funcdef>
  <paramdef>&type_aterm; &parTerm;</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&virtual; &type_aterm; &Rewriter_rewrInt;</funcdef>
  <paramdef>&type_aterm; &parTerm;</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&virtual; &type_atermlist; &Rewriter_rewrIntlist;</funcdef>
  <paramdef>&type_atermlist; &parTerms;</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&virtual; &tcbool; &Rewriter_addRule;</funcdef>
  <paramdef>&type_atermappl; &parRule;</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&virtual; &tcbool; &Rewriter_remRule;</funcdef>
  <paramdef>&type_atermappl; &parRule;</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&virtual; &type_void; &Rewriter_setsubst;</funcdef>
  <paramdef>&type_atermappl; &parVar;</paramdef>
  <paramdef>&type_aterm; &parExpr;</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&virtual; &type_aterm; &Rewriter_getsubst;</funcdef>
  <paramdef>&type_atermappl; &parVar;</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&virtual; &type_void; &Rewriter_clearsubst;</funcdef>
  <paramdef>&type_atermappl; &parVar;</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&virtual; &type_void; &Rewriter_clearsubsts;</funcdef>
  <paramdef>&type_void;</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&tpRewriter; &createRewriter;</funcdef>
  <paramdef>&type_atermappl; &parDataEqnSpec;</paramdef>
  <paramdef>&trewrstrat; &parStrategy;</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&tcbool; &isValidRewriteRule;</funcdef>
  <paramdef>&type_atermappl; &parDataEqn;</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&trewrstrat; &PrintRewriteStrategy;</funcdef>
  <paramdef>&tpfile; &parStream;</paramdef>
  <paramdef>&trewrstrat; &parStrategy;</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&trewrstrat; &RewriteStrategyFromString;</funcdef>
  <paramdef>&type_const; &type_pchar; &parS;</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>
<para>
The librewrite library provides a rewrite system for mCRL2 data expressions (only after data implementation). To use it, one creates a &tRewriter; class through the &createRewriter; function. The created rewriter is initialised with the equations from &parDataEqnSpec;, which are used as rewrite rules, and a rewriter strategy &parStrategy; (see below). After creation, one can still add or remove an rewrite rule &parRule; with the functions &Rewriter_addRule; and &Rewriter_remRule;. The latter removes (all occurrences of) &parRule; from the rules used by the rewrite system. To check whether a &parDataEqn; is a valid rewrite rule the function &isValidRewriteRule; can be used.
</para>
<para>
To actually rewrite a data expression, the functions &Rewriter_rewr; and &Rewriter_rewrlist; can be used. The function &Rewriter_rewr; rewrites a single mCRL2 data expression &parTerm;, while &Rewriter_rewrlist; rewrites every expression in the list &parTerms;. Because the rewriters use their own internal format for data expressions (for more efficient rewriting), every call to &Rewriter_rewr; or &Rewriter_rewrlist; results in an implicit conversion to and from the internal format before, respectively after the actual rewriting. When rewriting is a critical part of an application, it is wise to explicitly convert the data expressions before repeated calls on such an expression. This is done with the functions &Rewriter_toInt; and &Rewriter_fromInt;. (Note that the expression in the internal format is an &type_aterm; instead of an &type_atermappl;.) Terms in the internal format can be rewritten with the function &Rewriter_rewrInt; and &Rewriter_rewrIntlist; (analogous to &Rewriter_rewr; and &Rewriter_rewrlist;).
</para>

<refsect2>
<title>Strategies</title>
<para>
Currently, there are four different rewriting strategies available in librewrite. A standard innermost rewriting strategy is available under the name &stratINNER;. This strategy will fit most non critical rewriting uses, such as simulation, (simple) LPS manipulation and generation of (very) small state spaces. For time critical uses, there is a compiling innermost rewriting strategy &stratINNERC;. With this strategy, the creation of a &tRewriter; object will result in the compilation of an optimised rewriter. This does mean that gcc and the appropriate headers and libraries must be available.
</para>
<para>
An alternative to &stratINNER; is the JITty rewriter &stratJITTY;. This strategy can avoid a lot of unnecessary rewriting in certain cases and can handle some rewrite rules that cause the innermost rewriters to rewrite infinitely. There is also a compiling variant &stratJITTYC;. This compiling JITty rewriter is in general the best choice if one needs to generate large state spaces.
</para>
<para>
For each of the interpreting rewriters (&stratINNER; and &stratJITTY;) there is also a variant that uses a prover for boolean expressions. This can be useful in cases where the default rewriters cannot reduce a term any further while the expression is, for example, always equivalent to &false;.
</para>
<para>
A strategy &trewrstrat; can be printed to a stream in string representation using &PrintRewriteStrategy;. The string representations are derived from their &trewrstrat; name by taking the last part and writing it in lower case (e.g. &stratINNERstring; for &stratINNER;).
</para>
<para>
To convert a string representation of a strategy to a &trewrstrat;, one can use &RewriteStrategyFromString;. This is useful for converting command line arguments specifying a rewrite strategy. If the supplied string does not match any of the available strategies, &stratINVALID; is returned. Note that it is not allowed to supply &stratINVALID; to &createRewriter;.
</para>
</refsect2>

<refsect2>
<title>Implicit variable substitutions</title>
<para>
For efficient variable substitutions, a rewriter supplies some special functions. Instead of first substituting values for variables in a term and then rewriting the result, one can also set such a variable &parVar; to an expression &parExpr; with &Rewriter_setsubst;, which does nothing but storing this information, and rewrite the desired term afterwards, with the same effect. With &Rewriter_getsubst; one can retrieve the expression a variable has been set to (or the variable itself, if the variable was not set). To clear a set variable &parVar; one can call &Rewriter_clearsubst; (or &Rewriter_clearsubsts; to clear all substitutions).
</para>
<para>
Note that &parExpr; has to be in the internal format of the rewriter.
</para>
</refsect2>

</refsect1>

<refsect1>
<title>Preconditions</title>
<para>
The following preconditions have to be satisfied for all functions, except &RewriteStrategyFromString;:
<itemizedlist>
  <listitem>
    <para>the &aterm; library is initialised</para>
  </listitem>
  <listitem>
    <para>&gsEnableConstructorFunctions; has been called</para>  
  </listitem>
</itemizedlist>
</para>
<para>
The following preconditions have to be satisfied for &createRewriter;:
<itemizedlist>
  <listitem>
    <para>&parDataEqnSpec; is a DataEqnSpec from a mCRL2 specification (after data implementation)</para>
  </listitem>
  <listitem>
    <para>&parStrategy; is not &stratINVALID;</para>
  </listitem>
</itemizedlist>
</para>
<para>
The following precondition has to be satisfied for &Rewriter_addRule; and &Rewriter_remRule;:
<itemizedlist>
  <listitem>
    <para>&parRule; is a DataEqn (after data implementation)</para>
  </listitem>
</itemizedlist>
</para>
<para>
The following precondition has to be satisfied for &Rewriter_rewr; and &Rewriter_toInt;:
<itemizedlist>
  <listitem>
    <para>&parTerm; is a DataExpr (after data implementation)</para>
  </listitem>
</itemizedlist>
</para>
<para>
The following precondition has to be satisfied for &Rewriter_rewrInt; and &Rewriter_fromInt;:
<itemizedlist>
  <listitem>
    <para>&parTerm; is a data expression in the internal rewriter format</para>
  </listitem>
</itemizedlist>
</para>
<para>
The following precondition has to be satisfied for &Rewriter_rewrlist;:
<itemizedlist>
  <listitem>
    <para>&parTerms; is a ATermList of DataExprs (after data implementation)</para>
  </listitem>
</itemizedlist>
</para>
<para>
The following precondition has to be satisfied for &Rewriter_rewrIntlist;:
<itemizedlist>
  <listitem>
    <para>&parTerm; is a ATermList of data expressions in the internal rewriter format</para>
  </listitem>
</itemizedlist>
</para>
<para>
The following precondition has to be satisfied for &Rewriter_setsubst;, &Rewriter_getsubst; and &Rewriter_clearsubst;:
<itemizedlist>
  <listitem>
    <para>&parVar; is a DataVarId (after data implementation)</para>
  </listitem>
</itemizedlist>
</para>
<para>
The following precondition has to be satisfied for &Rewriter_setsubst;:
<itemizedlist>
  <listitem>
    <para>&parExpr; is a data expression in the internal rewriter format</para>
  </listitem>
</itemizedlist>
</para>
<para>
The following precondition has to be satisfied for &isValidRewriteRule;:
<itemizedlist>
  <listitem>
    <para>&parDataEqn; is a DataEqn (after data implementation)</para>
  </listitem>
</itemizedlist>
</para>
</refsect1>

<refsect1>
<title>Known issues</title>
<para>
Files generated by the compiling rewriter (&stratINNERC;) are not removed after usage.
</para>
</refsect1>

<refsect1>
<title>Author</title>
<para>
Written by Muck van Weerdenburg. Please send all complaints, comments and bug fixes to &bugmail;.
</para>
</refsect1>

</refentry>
