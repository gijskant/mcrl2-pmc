<?xml version="1.0"?>

<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN" "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"[
<!ENTITY lpeformcheck "<function>lpeformcheck</function>">
<!ENTITY option "<parameter>OPTION</parameter>">
<!ENTITY formulas "<parameter>FORMULAS</parameter>">
<!ENTITY infile "<parameter>INFILE</parameter>">
<!ENTITY prefix "<parameter>PREFIX</parameter>">
<!ENTITY strategy "<parameter>STRATEGY</parameter>">
<!ENTITY seconds "<parameter>SECONDS</parameter>">
<!ENTITY solver "<parameter>SOLVER</parameter>">
<!ENTITY sort_bool "<type>Bool</type>">
<!ENTITY opt_f "<option>-f</option>">
<!ENTITY opt_l "<option>-l</option>">
<!ENTITY opt_c "<option>-c</option>">
<!ENTITY opt_w "<option>-w</option>">
<!ENTITY opt_p "<option>-p</option>">
<!ENTITY opt_h "<option>-h</option>">
<!ENTITY opt_q "<option>-q</option>">
<!ENTITY opt_v "<option>-v</option>">
<!ENTITY opt_d "<option>-d</option>">
<!ENTITY opt_r "<option>-r</option>">
<!ENTITY opt_t "<option>-t</option>">
<!ENTITY opt_z "<option>-z</option>">
<!ENTITY opt_o "<option>-o</option>">
<!ENTITY opt_formulas "<option>--formulas</option>">
<!ENTITY opt_counter_example "<option>--counter-example</option>">
<!ENTITY opt_witness "<option>--witness</option>">
<!ENTITY opt_print_dot "<option>--print-dot</option>">
<!ENTITY opt_help "<option>--help</option>">
<!ENTITY opt_version "<option>--version</option>">
<!ENTITY opt_quiet "<option>--quiet</option>">
<!ENTITY opt_verbose "<option>--verbose</option>">
<!ENTITY opt_debug "<option>--debug</option>">
<!ENTITY opt_rewrite_strategy "<option>--rewrite-strategy</option>">
<!ENTITY opt_time_limit "<option>--time-limit</option>">
<!ENTITY opt_smt_solver "<option>--smt-solver</option>">
<!ENTITY opt_induction "<option>--induction</option>">
<!ENTITY strat_inner_string "<constant>'inner'</constant>">
<!ENTITY strat_innerc_string "<constant>'innerc'</constant>">
<!ENTITY strat_jitty_string "<constant>'jitty'</constant>">
<!ENTITY strat_jittyc_string "<constant>'jittyc'</constant>">
<!ENTITY solver_ario_string "<constant>'ario'</constant>">
<!ENTITY solver_cvc_lite_string "<constant>'cvc-lite'</constant>">
<!ENTITY solver_ario "<constant>ario</constant>">
<!ENTITY solver_cvc_lite "<constant>cvc-lite</constant>">
<!ENTITY stdin "<constant>stdin</constant>">
<!ENTITY link_ario "<uri>http://www.eecs.umich.edu/~ario/</uri>">
<!ENTITY link_cvc "<uri>http://www.cs.nyu.edu/acsys/cvcl/</uri>">
]>

<refentry id="lpeformcheck">

<refmeta>
  <refentrytitle>lpeformcheck</refentrytitle>
  <manvolnum>1</manvolnum>
</refmeta>

<refnamediv>
  <refname>lpeformcheck</refname>
  <refpurpose>check formulas using the data specification of an LPE</refpurpose>
</refnamediv>

<refsynopsisdiv>
  <cmdsynopsis>
    <command>&lpeformcheck;</command>
    <arg choice="plain" rep="repeat"><arg choice="opt">&option;</arg></arg>
    <arg choice="opt">&infile;</arg>
    <arg choice="req">&opt_formulas;=&formulas;</arg>
  </cmdsynopsis>
</refsynopsisdiv>

<refsect1>
  <title>Description</title>
  <para>
    The term "formula" in the following text denotes arbitrary expressions of sort &sort_bool; in the mCRL2 format.
</para>
  <para>
    All formulas in the list of formulas in internal mCRL2 format as found in
    &formulas; are checked using the data specification of the mCRL2 LPE as found in
    &infile;. The &lpeformcheck; tool indicates whether each formula is a tautology or a
    contradiction. If the tool is unable to determine whether a formula is a
    tautology or a contradiction, it indicates this fact.
  </para>

  <para>
    If &infile; is not specified, the LPE is read from &stdin;.
  </para>

  <para>
    In some cases &lpeformcheck; is unable to determine whether a
    formula is a tautology or a contradiction. The option &opt_verbose; gives
    insight into what the prover used by the tool is doing and can be used to see if
    rewrite rules have to be added to the specification in order to enable the prover
    to determine that certain formulas are indeed tautologies or contradictions.
  </para>

  <para>
    The &lpeformcheck; tool uses a BDD based prover to check the formulas. In some cases
    it may be useful to use an SMT solver to assist the prover. The SMT solver can further
    reduce BDDs by removing inconsistent paths. A specific SMT solver can be chosen using
    the option &opt_smt_solver;=&solver;. Either the SMT solver &solver_ario; or
    &solver_cvc_lite; can be used. To use one of these solvers, the directory containing the
    corresponding executable must be in the path.
    On June the 20th of 2006, Ario 1.1 was available on &link_ario; and CVC Lite was available on &link_cvc;.
  </para>

</refsect1>

<refsect1>
<title>Options</title>
<para>
  Mandatory arguments to long options are mandatory for short options too.
  <variablelist>
    <varlistentry>
      <term>&opt_f;</term>
      <term>&opt_formulas;=&formulas;</term>
      <listitem>
        <para>
          Use the list of formulas in internal mCRL2 format as found in
          &formulas; as input
        </para>
      </listitem>
    </varlistentry>

  <varlistentry>
    <term>&opt_c;</term>
    <term>&opt_counter_example;</term>
    <listitem>
      <para>
        Give a valuation for which the current
        formula does not hold, in case the current
        formula is neither a contradiction nor a
        tautology
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_w;</term>
    <term>&opt_witness;</term>
    <listitem>
      <para>
        Give a valuation for which the current
        formula holds, in case the current formula
        is neither a contradiction nor a tautology
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_p;</term>
    <term>&opt_print_dot;=&prefix;</term>
    <listitem>
      <para>
        Save a .dot file of the resulting BDD if
        it is impossible to determine whether a
        formula is a contradiction or a tautology
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_h;</term>
    <term>&opt_help;</term>
    <listitem>
      <para>
        Display help message and terminate
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_version;</term>
    <listitem>
      <para>
        Display version information and terminate
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_q;</term>
    <term>&opt_quiet;</term>
    <listitem>
      <para>
        Do not display warning messages
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_v;</term>
    <term>&opt_verbose;</term>
    <listitem>
      <para>
        Display concise intermediate messages
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_d;</term>
    <term>&opt_debug;</term>
    <listitem>
      <para>
        Display detailed intermediate messages
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_r;</term>
    <term>&opt_rewrite_strategy;=&strategy;</term>
    <listitem>
      <para>
        Use the specified &strategy; as rewrite
        strategy:
        <itemizedlist spacing='compact'>
          <listitem>
            <para>
              &strat_inner_string; for the innermost rewrite strategy
            </para>
          </listitem>
          <listitem>
            <para>
              &strat_innerc_string; for the compiled innermost rewrite strategy
            </para>
          </listitem>
          <listitem>
            <para>
              &strat_jitty_string; for the jitty rewrite strategy
            </para>
          </listitem>
          <listitem>
            <para>
              &strat_jittyc_string; for the compiled jitty rewrite strategy
            </para>
          </listitem>
        </itemizedlist>
        By default, the jitty rewrite strategy is used
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_t;</term>
    <term>&opt_time_limit;=&seconds;</term>
    <listitem>
      <para>
        Spend at most the specified number of &seconds; on proving
        a single formula
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_z;</term>
    <term>&opt_smt_solver;=&solver;</term>
    <listitem>
      <para>
        Use the specified &solver; to remove inconsistent paths from BDDs:
        <itemizedlist spacing='compact'>
          <listitem>
            <para>
              &solver_ario_string; for the SMT solver Ario
            </para>
          </listitem>
          <listitem>
            <para>
              &solver_cvc_lite_string; for the SMT solver CVC Lite
            </para>
          </listitem>
        </itemizedlist>
        By default, no path elimination is applied
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_o;</term>
    <term>&opt_induction;</term>
    <listitem>
      <para>
        Apply induction on lists
      </para>
    </listitem>
  </varlistentry>

  </variablelist>
</para>
</refsect1>

<refsect1>
<title>Author</title>
<para>
  Written by Luc Engelen. Please send all complaints, comments and bug
  reports to <email>bug@mcrl2.org</email>.
</para>
</refsect1>

</refentry>
