<refentry id="lpsinvelm">
 <info>
  <date>2005-2007</date>
 </info>

<refmeta>
  <refentrytitle>lpsinvelm</refentrytitle>
  <manvolnum>1</manvolnum>
  <refmiscinfo class="source">lpsinvelm</refmiscinfo>
  <refmiscinfo class="version"></refmiscinfo>
  <refmiscinfo class="manual">User Commands</refmiscinfo>
</refmeta>

<refnamediv>
  <refname>lpsinvelm</refname>
  <refpurpose>check invariants and use these to simplify or eliminate summands of an LPS</refpurpose>
</refnamediv>

<refsynopsisdiv>
  <cmdsynopsis>
    <command>&lpsinvelm;</command>
    <arg choice="plain" rep="repeat"><arg choice="opt">&option;</arg></arg>
    <arg choice="opt">&infile;<arg choice="opt">&outfile;</arg></arg>
    <arg choice="req">&opt_invariant;=&invariant;</arg>
  </cmdsynopsis>
</refsynopsisdiv>

<refsect1>
  <title>Description</title>
  <para>
    The &lpsinvelm; tool checks whether the invariant in internal mCRL2 format as found in
    &invariant; holds for the mCRL2 LPS as found in &infile;. If the invariant holds, it will
    eliminate all summand of the LPS of which the condition violates the invariant.
    It can also be used to simplify the conditions of the summands of the given LPS.
    The resulting LPS is written to the file named &outfile;.
  </para>

  <para>
    If &infile; is not specified, the LPS is read from &cstdin;. If &outfile; is
    not specified, the resulting LPS is written to &cstdout;.
  </para>

  <para>
    Given an LPS,
    <literallayout>
      P(d: D) = ...
              + sum ei: Ei. ci(d, ei) -> ai(fi(d, ei)) . P(gi(d, ei))
              + ...;
    </literallayout>
    a formula of the form
    <literallayout>
      inv(d) /\ ci(d, ei) => inv(gi(d, ei))
    </literallayout>
    is generated for each of the summands, where <literal>inv()</literal> is the expression passed using the option &opt_invariant;.
    This expression is an invariant of the LPS if it holds in the initial state and all the generated formulas are tautologies.
  </para>
  <para>
    The invariant is used to eliminate summands as follows. A formula of the form
    <literallayout>
      inv(d) /\ ci(d, ei)
    </literallayout>
    is generated for each of the summands or for the summand indicated using the option &opt_summand; only. The tool uses a BDD based prover for
    expressions of sort &sort_bool; to see if the generated formula is a contradiction. If the formula is a contradiction for some summand, this
    summand
    will be eliminated from the LPS. If the formula is not a contradiction, the summand remains unchanged unless the option &opt_simplify_all;
    is used.
  </para>

  <para>
    The option &opt_simplify_all; will replace the conditions of all summands by the equivalent
    BDD of the condition in conjunction with the invariant passed using the option &opt_invariant;.
    This may enable other tools, like for instance &lpsconstelm-lnk; or
    &lpsparelm-lnk;, to simplify the LPS even further.
  </para>

  <para>
    In some cases it may be useful to use an SMT solver to assist the prover. The SMT
    solver can further reduce BDDs by removing inconsistent paths. A specific SMT solver
    can be chosen using the option &opt_smt_solver;=&solver;. Either
  the SMT solver &solver_ario-lnk; or &solver_cvc_lite-lnk; can be used.
  To use one of these solvers, the directory containing the
    corresponding executable must be in the path.
  </para>

  <para>
    Without using the option &opt_no_check;, &lpsinvelm; will first check if the given expression
    is an invariant of the LPS. If this is not the case, no elimination or simplification will
    be done. In some cases the invariant may hold even though the prover is unable to determine
    this fact. In cases where
    an expression is an invariant of the LPS, but the prover is unable to determine this, the option
    &opt_no_check; can be used to eliminate or simplify summands anyway. Note that this also makes
    it possible to eliminate or simplify summands using an expression that is not an invariant of the
    LPS.
  </para>

  <para>
    The option &opt_verbose; gives insight into what the prover is doing and can be used to see
    if rewrite rules have to be added to the specification, in order to enable the prover to
    determine the invariance of an expression.
  </para>
</refsect1>

<refsect1>
<title>Options</title>
<para>
  Mandatory arguments to long options are mandatory for short options too.
  <variablelist>
  <varlistentry>
    <term>&opt_i;</term>
    <term>&opt_invariant;=&invariant;</term>
    <listitem>
      <para>
        Use the expression of sort &sort_bool; in internal mCRL2 format as
        found in &invariant; as invariant
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_s;</term>
    <term>&opt_summand;=&num;</term>
    <listitem>
      <para>
        Eliminate or simplify the summand with number &num; only
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_n;</term>
    <term>&opt_no_check;</term>
    <listitem>
      <para>
        Do not check if the invariant holds before eliminating unreachable summands
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_e;</term>
    <term>&opt_no_elimination;</term>
    <listitem>
      <para>
        Do not eliminate or simplify summands
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_l;</term>
    <term>&opt_simplify_all;</term>
    <listitem>
      <para>
        Simplify the conditions of all summands, instead of just eliminating the summands
        whose conditions in conjunction with the invariant are contradictions
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_y;</term>
    <term>&opt_all_violations;</term>
    <listitem>
      <para>
        Do not terminate as soon as a violation of the invariant is found, but report
        all violations instead
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_c;</term>
    <term>&opt_counter_example;</term>
    <listitem>
      <para>
        Display a valuation indicating why the invariant could possibly be violated if
        it is uncertain whether a summand violates the invariant
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_p;</term>
    <term>&opt_print_dot;=&prefix;</term>
    <listitem>
      <para>
        Save a .dot file of the resulting BDD if
        it is impossible to determine whether a
        summand violates the invariant. &prefix;
        will be used as prefix of the output
        files
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_h;</term>
    <term>&opt_help;</term>
    <listitem>
      <para>
        display help message and terminate
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_version;</term>
    <listitem>
      <para>
        display version information and terminate
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_q;</term>
    <term>&opt_quiet;</term>
    <listitem>
      <para>
        do not display warning messages
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_v;</term>
    <term>&opt_verbose;</term>
    <listitem>
      <para>
        display concise intermediate messages
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_d;</term>
    <term>&opt_debug;</term>
    <listitem>
      <para>
        Display detailed intermediate messages
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_r;</term>
    <term>&opt_rewrite_strategy;=&strategy;</term>
    <listitem>
      <para>
        Use the specified &strategy; as rewrite strategy (see &rewriter-lnk;
        manual page).  By default, &strat_jitty_string; is used
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_t;</term>
    <term>&opt_time_limit;=&seconds;</term>
    <listitem>
      <para>
        Spend at most the specified number of &seconds; on proving
        a single expression
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_z;</term>
    <term>&opt_smt_solver;=&solver;</term>
    <listitem>
      <para>
        Use the specified &solver; to remove inconsistent paths from BDDs:
        <itemizedlist spacing='compact'>
          <listitem>
            <para>
              &solver_ario_string; for the SMT solver Ario
            </para>
          </listitem>
          <listitem>
            <para>
              &solver_cvc_lite_string; for the SMT solver CVC Lite
            </para>
          </listitem>
        </itemizedlist>
        By default, no path elimination is applied
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_o;</term>
    <term>&opt_induction;</term>
    <listitem>
      <para>
        Apply induction on lists
      </para>
    </listitem>
  </varlistentry>

  </variablelist>
</para>
</refsect1>

<refsect1>
<title>Author</title>
<para>
  Written by Luc Engelen. Please send all complaints, comments and bug
  reports to &bugmail;.
</para>
</refsect1>

</refentry>
