<?xml version="1.0"?>

<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN" "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"[
<!ENTITY lpeconfcheck "<function>lpeconfcheck</function>">
<!ENTITY option "<parameter>OPTION</parameter>">
<!ENTITY infile "<parameter>INFILE</parameter>">
<!ENTITY outfile "<parameter>OUTFILE</parameter>">
<!ENTITY invariant "<parameter>INVARIANT</parameter>">
<!ENTITY number "<parameter>NUMBER</parameter>">
<!ENTITY prefix "<parameter>PREFIX</parameter>">
<!ENTITY strategy "<parameter>STRATEGY</parameter>">
<!ENTITY seconds "<parameter>SECONDS</parameter>">
<!ENTITY opt_i "<option>-i</option>">
<!ENTITY opt_s "<option>-s</option>">
<!ENTITY opt_n "<option>-n</option>">
<!ENTITY opt_m "<option>-m</option>">
<!ENTITY opt_a "<option>-a</option>">
<!ENTITY opt_c "<option>-c</option>">
<!ENTITY opt_p "<option>-p</option>">
<!ENTITY opt_h "<option>-h</option>">
<!ENTITY opt_q "<option>-q</option>">
<!ENTITY opt_v "<option>-v</option>">
<!ENTITY opt_d "<option>-d</option>">
<!ENTITY opt_r "<option>-r</option>">
<!ENTITY opt_t "<option>-t</option>">
<!ENTITY opt_invariant "<option>--invariant</option>">
<!ENTITY opt_summand "<option>--summand</option>">
<!ENTITY opt_no_check "<option>--no-check</option>">
<!ENTITY opt_no_marking "<option>--no_marking</option>">
<!ENTITY opt_check_all "<option>--check_all</option>">
<!ENTITY opt_counter_example "<option>--counter-example</option>">
<!ENTITY opt_print_dot "<option>--print-dot</option>">
<!ENTITY opt_help "<option>--help</option>">
<!ENTITY opt_version "<option>--version</option>">
<!ENTITY opt_quiet "<option>--quiet</option>">
<!ENTITY opt_verbose "<option>--verbose</option>">
<!ENTITY opt_debug "<option>--debug</option>">
<!ENTITY opt_rewrite_strategy "<option>--rewrite-strategy</option>">
<!ENTITY opt_time_limit "<option>--time-limit</option>">
<!ENTITY strat_inner_string "<constant>inner</constant>">
<!ENTITY strat_innerc_string "<constant>innerc</constant>">
<!ENTITY strat_jitty_string "<constant>jitty</constant>">
<!ENTITY strat_jittyc_string "<constant>jittyc</constant>">
<!ENTITY stdin "<constant>stdin</constant>">
<!ENTITY stdout "<constant>stdout</constant>">
]>

<refentry id="lpeconfcheck">

<refmeta>
  <refentrytitle>lpeconfcheck</refentrytitle>
  <manvolnum>1</manvolnum>
</refmeta>

<refnamediv>
  <refname>lpeconfcheck</refname>
  <refpurpose>check which summands of an LPE are confluent and mark them</refpurpose>
</refnamediv>

<refsynopsisdiv>
  <cmdsynopsis>
    <command>&lpeconfcheck;</command>
    <arg choice="plain" rep="repeat"><arg choice="opt">&option;</arg></arg>
    <arg choice="opt">&infile;<arg choice="opt">&outfile;</arg></arg>
  </cmdsynopsis>
</refsynopsisdiv>

<refsect1>
  <title>Description</title>
  <para>
    The &lpeconfcheck; tool checks which tau-summands of the mCRL2 LPE as found
    in &infile; are confluent and marks these. The resulting LPE is written to
    the file named &outfile;.
  </para>

  <para>
    If &infile; is not specified, the LPE is read from &stdin;. If &outfile; is
    not specified, the resulting LPE is written to &stdout;.
  </para>

  <para>
    Given an LPE,
    <literallayout>
      P(d: D) = ...
              + sum ei: Ei. ci(d, ei) -> ai(fi(d, ei)) . P(gi(d, ei))
              + ...
              + sum ej: Ej. cj(d, ej) -> tau . P(gj(d, ej))
              + ...;
    </literallayout>
    tau-summand j is confluent with summand i if the following condition holds
    for all d: D, for all ei: Ei and for all ej: Ej:
    <literallayout>
      (inv(d) /\ ci(d, ei) /\ cj(d, ej))
      =>
      (ci(gj(d, ej), ei) /\ cj(gi(d, ei), ej) /\ fi(d, ei) == fi(gj(d, ej), ei) /\ gi(gj(d, ej), ei) == gj(gi(d, ei), ej))
    </literallayout>
    where inv() is the invariant specified using the option &opt_invariant;. In case ai is also a tau-action, the formula
    above can be weakened to the following:
    <literallayout>
      (inv(d) /\ ci(d, ei) /\ cj(d, ej))
      =>
      (gi(d, ei) == gj(d, ej) \/ (ci(gj(d, ej), ei) /\ cj(gi(d, ei), ej) /\ gi(gj(d, ej), ei) == gj(gi(d, ei), ej)))
    </literallayout>
  </para>

  <para>
    The tool will generate the confluence conditions mentioned above for a number of
    summands and tries to prove that they are tautologies using a prover for
    propositional formulas. Because of the limitations of the prover used to check
    these conditions, &lpeconfcheck; may indicate that a tau-summand is not confluent
    even though it is. The option &opt_verbose; gives insight into what the prover is
    doing and can be used to see if rewrite rules have to be added to the specification
    in order to enable the prover to determine that certain condition are indeed
    tautologies.
  </para>

  <para>
    The tool can determine whether two summands are confluent in three ways and will
    indicate which of the methods was used while proving confluence. The three ways
    of determining confluence are as follows:
    <itemizedlist spacing='compact'>
      <listitem>
        <para>
          The most time consuming way of checking the confluence of two summands is
          generating the confluence condition and then checking if this condition is a
          tautology using the prover. If two summands are proven confluent using the
          prover, &lpeconfcheck; indicates this by printing a plus sign ('+').
        </para>
      </listitem>
      <listitem>
        <para>
          Another way of checking the confluence of two summands is determining whether
          the two summands are syntactically disjoint. Two summands are syntactically
          disjoint if the following holds:
          <itemizedlist spacing='compact'>
            <listitem>
              <para>
                The set of variables used by one summand is disjoint from the set
                of variables changed by the other summand and vice versa.
              </para>
            </listitem>
            <listitem>
              <para>
                The set of variables changed by one summand is disjoint from the set
                of variables changed by the other summand.
              </para>
            </listitem>
          </itemizedlist>
          If two summands are confluent because of syntactic disjointness, &lpeconfcheck;
          indicates this by printing a colon (':').
        </para>
      </listitem>
      <listitem>
        <para>
          If summand number 1 has been proven confluent with summand number 2, summand
          number 2 is obviously confluent with summand number 1. This method of checking
          confluence is called checking confluence by symmetry. If two summands are
          confluent by symmetry, &lpeconfcheck; indicates this by printing a dot ('.').
        </para>
      </listitem>
    </itemizedlist>
  </para>
</refsect1>

<refsect1>
<title>Options</title>
<para>
  Mandatory arguments to long options are mandatory for short options too.
  <variablelist>
  <varlistentry>
    <term>&opt_i;</term>
    <term>&opt_invariant;=&invariant;</term>
    <listitem>
      <para>
        Use the formula in internal mCRL2 format as
        found in &invariant; as invariant
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_s;</term>
    <term>&opt_summand;=&number;</term>
    <listitem>
      <para>
        Check the summand with number &number; only
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_n;</term>
    <term>&opt_no_check;</term>
    <listitem>
      <para>
        Do not check if the invariant holds before
        checking for confluence
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_m;</term>
    <term>&opt_no_marking;</term>
    <listitem>
      <para>
        Do not mark the confluent tau-summands.
        Since there are no changes made to the LPE,
        nothing is written to &outfile;
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_a;</term>
    <term>&opt_check_all;</term>
    <listitem>
      <para>
        Do not stop checking summands on detection
        of the first non-confluence
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_c;</term>
    <term>&opt_counter_example;</term>
    <listitem>
      <para>
        Give a valuation for which the confluence
        condition does not hold, in case the
        encountered condition is neither a
        contradiction nor a tautolgy
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_p;</term>
    <term>&opt_print_dot;</term>
    <listitem>
      <para>
        Save a .dot file of the resulting BDD in
        case two summands cannot be proven
        confluent. PREFIX will be used as prefix
        of the output files
      </para>
    </listitem>
  </varlistentry>
  
  <varlistentry>
    <term>&opt_h;</term>
    <term>&opt_help;</term>
    <listitem>
      <para>
        Display help message and terminate
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_version;</term>
    <listitem>
      <para>
        Display version information and terminate
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_q;</term>
    <term>&opt_quiet;</term>
    <listitem>
      <para>
        Do not display warning messages
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_v;</term>
    <term>&opt_verbose;</term>
    <listitem>
      <para>
        Display concise intermediate messages
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_d;</term>
    <term>&opt_debug;</term>
    <listitem>
      <para>
        Display detailed intermediate messages
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_r;</term>
    <term>&opt_rewrite_strategy;=&strategy;</term>
    <listitem>
      <para>
        Use the specified &strategy; as rewrite
        strategy:
        <itemizedlist spacing='compact'>
          <listitem>
            <para>
              &strat_inner_string; for the innermost rewrite strategy
            </para>
          </listitem>
          <listitem>
            <para>
              &strat_innerc_string; for the compiled innermost rewrite strategy
            </para>
          </listitem>
          <listitem>
            <para>
              &strat_jitty_string; for the jitty rewrite strategy
            </para>
          </listitem>
          <listitem>
            <para>
              &strat_jittyc_string; for the compiled jitty rewrite strategy
            </para>
          </listitem>
        </itemizedlist>
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_t;</term>
    <term>&opt_time_limit;=&seconds;</term>
    <listitem>
      <para>
        Spend at most the specified number of &seconds; on proving
        a single formula
      </para>
    </listitem>
  </varlistentry>

  </variablelist>
</para>
</refsect1>

<refsect1>
<title>Author</title>
<para>
  Written by Luc Engelen. Please send all complaints, comments and bug
  reports to <email>bug@mcrl2.org</email>.
</para>
</refsect1>

</refentry>
