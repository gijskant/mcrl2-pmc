<?xml version="1.0"?>

<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN" "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"[
<!ENTITY lpeconfcheck "<function>lpeconfcheck</function>">
<!ENTITY option "<parameter>OPTION</parameter>">
<!ENTITY infile "<parameter>INFILE</parameter>">
<!ENTITY outfile "<parameter>OUTFILE</parameter>">
<!ENTITY invariant "<parameter>INVARIANT</parameter>">
<!ENTITY number "<parameter>NUMBER</parameter>">
<!ENTITY prefix "<parameter>PREFIX</parameter>">
<!ENTITY strategy "<parameter>STRATEGY</parameter>">
<!ENTITY seconds "<parameter>SECONDS</parameter>">
<!ENTITY solver "<parameter>SOLVER</parameter>">
<!ENTITY opt_i "<option>-i</option>">
<!ENTITY opt_g "<option>-g</option>">
<!ENTITY opt_s "<option>-s</option>">
<!ENTITY opt_n "<option>-n</option>">
<!ENTITY opt_m "<option>-m</option>">
<!ENTITY opt_a "<option>-a</option>">
<!ENTITY opt_c "<option>-c</option>">
<!ENTITY opt_p "<option>-p</option>">
<!ENTITY opt_h "<option>-h</option>">
<!ENTITY opt_q "<option>-q</option>">
<!ENTITY opt_v "<option>-v</option>">
<!ENTITY opt_d "<option>-d</option>">
<!ENTITY opt_r "<option>-r</option>">
<!ENTITY opt_t "<option>-t</option>">
<!ENTITY opt_z "<option>-z</option>">
<!ENTITY opt_invariant "<option>--invariant</option>">
<!ENTITY opt_generate_invariants "<option>--generate-invariants</option>">
<!ENTITY opt_summand "<option>--summand</option>">
<!ENTITY opt_no_check "<option>--no-check</option>">
<!ENTITY opt_no_marking "<option>--no-marking</option>">
<!ENTITY opt_check_all "<option>--check-all</option>">
<!ENTITY opt_counter_example "<option>--counter-example</option>">
<!ENTITY opt_print_dot "<option>--print-dot</option>">
<!ENTITY opt_help "<option>--help</option>">
<!ENTITY opt_version "<option>--version</option>">
<!ENTITY opt_quiet "<option>--quiet</option>">
<!ENTITY opt_verbose "<option>--verbose</option>">
<!ENTITY opt_debug "<option>--debug</option>">
<!ENTITY opt_rewrite_strategy "<option>--rewrite-strategy</option>">
<!ENTITY opt_time_limit "<option>--time-limit</option>">
<!ENTITY opt_smt_solver "<option>--smt-solver</option>">
<!ENTITY strat_inner_string "<constant>inner</constant>">
<!ENTITY strat_innerc_string "<constant>innerc</constant>">
<!ENTITY strat_jitty_string "<constant>jitty</constant>">
<!ENTITY strat_jittyc_string "<constant>jittyc</constant>">
<!ENTITY solver_ario_string "<constant>'ario'</constant>">
<!ENTITY solver_cvc_lite_string "<constant>'cvc-lite'</constant>">
<!ENTITY solver_ario "<constant>ario</constant>">
<!ENTITY solver_cvc_lite "<constant>cvc-lite</constant>">
<!ENTITY stdin "<constant>stdin</constant>">
<!ENTITY stdout "<constant>stdout</constant>">
<!ENTITY const_true "<constant>true</constant>">
<!ENTITY link_ario "<uri>http://www.eecs.umich.edu/~ario/</uri>">
<!ENTITY link_cvc "<uri>http://www.cs.nyu.edu/acsys/cvcl/</uri>">
<!ENTITY inv "<literal>inv()</literal>">
<!ENTITY tau "<literal>tau</literal>">
<!ENTITY ctau "<literal>ctau</literal>">
]>

<refentry id="lpeconfcheck">

<refmeta>
  <refentrytitle>lpeconfcheck</refentrytitle>
  <manvolnum>1</manvolnum>
</refmeta>

<refnamediv>
  <refname>lpeconfcheck</refname>
  <refpurpose>check which &tau;-summands of an LPE are confluent and mark them by renaming their &tau;-actions to &ctau;</refpurpose>
</refnamediv>

<refsynopsisdiv>
  <cmdsynopsis>
    <command>&lpeconfcheck;</command>
    <arg choice="plain" rep="repeat"><arg choice="opt">&option;</arg></arg>
    <arg choice="opt">&infile;<arg choice="opt">&outfile;</arg></arg>
  </cmdsynopsis>
</refsynopsisdiv>

<refsect1>
  <title>Description</title>
  <para>
    The &lpeconfcheck; tool checks which &tau;-summands of the mCRL2 LPE as found
    in &infile; are confluent and marks them by renaming their &tau;-actions to &ctau;. The
    resulting LPE is written to the file named &outfile;.
  </para>

  <para>
    If &infile; is not specified, the LPE is read from &stdin;. If &outfile; is
    not specified, the resulting LPE is written to &stdout;.
  </para>

  <para>
    Given an LPE,
    <literallayout>
      P(d: D) = ...
              + sum ei: Ei. ci(d, ei) -> ai(fi(d, ei)) . P(gi(d, ei))
              + ...
              + sum ej: Ej. cj(d, ej) -> tau . P(gj(d, ej))
              + ...;
    </literallayout>
    &tau;-summand <literal>j</literal> is confluent with summand <literal>i</literal> if the following condition holds
    for all <literal>d: D</literal>, for all <literal>ei: Ei</literal> and for all <literal>ej: Ej</literal>:
    <literallayout>
      (inv(d) /\ ci(d, ei) /\ cj(d, ej))
      =>
      (ci(gj(d, ej), ei) /\ cj(gi(d, ei), ej) /\ fi(d, ei) == fi(gj(d, ej), ei) /\ gi(gj(d, ej), ei) == gj(gi(d, ei), ej))
    </literallayout>
    where &inv; is the invariant specified using the option &opt_invariant;. In case <literal>ai</literal>
    is also a &tau;-action, this formula can be weakened to the following:
    <literallayout>
      (inv(d) /\ ci(d, ei) /\ cj(d, ej))
      =>
      (gi(d, ei) == gj(d, ej) \/ (ci(gj(d, ej), ei) /\ cj(gi(d, ei), ej) /\ gi(gj(d, ej), ei) == gj(gi(d, ei), ej)))
    </literallayout>
    If the option &opt_invariant; is not used, the invariant is equal to &const_true;.
  </para>

  <para>
    The tool will generate these confluence conditions for all
    &tau;-summands
    and tries to prove that they are tautologies using a BDD based prover for
    propositional formulas. In some cases &lpeconfcheck; indicates that a
    &tau;-summand is not confluent
    even though it is. The option &opt_verbose; gives insight into what the prover is
    doing and can be used to see if rewrite rules have to be added to the specification
    in order to enable the prover to determine that certain condition are indeed
    tautologies.
  </para>

  <para>
    In some cases it may be useful to use an SMT solver to assist the prover. The SMT
    solver can further reduce BDDs by removing inconsistent paths. A specific SMT solver
    can be chosen using the option &opt_smt_solver;=&solver;. Either the SMT solver &solver_ario; or
    &solver_cvc_lite; can be used. To use one of these solvers, the directory containing the
    corresponding executable must be in the path.
    On June the 20th of 2006, Ario was available on &link_ario; and CVC Lite was available on &link_cvc;.
  </para>

  <para>
    The tool can determine whether two summands are confluent in three ways and will
    indicate which of the methods was used while proving confluence. The three ways
    of determining confluence are as follows:
    <itemizedlist spacing='compact'>
      <listitem>
        <para>
          If summand number 1 has been proven confluent with summand number 2, summand
          number 2 is also confluent with summand number 1. This method of checking
          confluence is called checking confluence by symmetry. If two summands are
          confluent by symmetry, &lpeconfcheck; indicates this by printing a dot ('.').
        </para>
      </listitem>
      <listitem>
        <para>
          Another way of checking the confluence of two summands is determining whether
          the two summands are syntactically disjoint. Two summands are syntactically
          disjoint if the following holds:
          <itemizedlist spacing='compact'>
            <listitem>
              <para>
                The set of variables used by one summand is disjoint from the set
                of variables changed by the other summand and vice versa.
              </para>
            </listitem>
            <listitem>
              <para>
                The set of variables changed by one summand is disjoint from the set
                of variables changed by the other summand.
              </para>
            </listitem>
          </itemizedlist>
          If two summands are confluent because of syntactic disjointness, &lpeconfcheck;
          indicates this by printing a colon (':').
        </para>
      </listitem>
      <listitem>
        <para>
          The most time consuming way of checking the confluence of two summands is
          generating the confluence condition and then checking if this condition is a
          tautology using the prover. If two summands are proven confluent using the
          prover, &lpeconfcheck; indicates this by printing a plus sign ('+').
          If the option &opt_generate_invariants; is used, the &lpeconfcheck; tool will try to prove
          that the reduced confluence condition is an invariant of the LPE, in case the confluence condition
          is not a tautology. If the reduced confluence condition is indeed an invariant, the
          two summands are proven confluent. &lpeconfcheck; indicates this by printing an 'i'.
        </para>
      </listitem>
    </itemizedlist>
  </para>
  <para>
    If there already is an action named &ctau; present in the LPE as found in &infile;, an error will be reported.
  </para>
</refsect1>

<refsect1>
<title>Options</title>
<para>
  Mandatory arguments to long options are mandatory for short options too.
  <variablelist>
  <varlistentry>
    <term>&opt_i;</term>
    <term>&opt_invariant;=&invariant;</term>
    <listitem>
      <para>
        Use the formula in internal mCRL2 format as
        found in &invariant; as invariant
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_g;</term>
    <term>&opt_generate_invariants;</term>
    <listitem>
      <para>
        Try to prove that the reduced confluence
        condition is an invariant of the LPE, in case
        the confluence condition is not a tautology.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_s;</term>
    <term>&opt_summand;=&number;</term>
    <listitem>
      <para>
        Check the summand with number &number; only
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_n;</term>
    <term>&opt_no_check;</term>
    <listitem>
      <para>
        Do not check if the invariant holds before
        checking for confluence
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_m;</term>
    <term>&opt_no_marking;</term>
    <listitem>
      <para>
        Do not mark the confluent &tau;-summands.
        Since there are no changes made to the LPE,
        nothing is written to &outfile;
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_a;</term>
    <term>&opt_check_all;</term>
    <listitem>
      <para>
        Check the confluence of the &tau;-summands regarding all other summands, instead of
        continuing with the next &tau;-summand as soon as a summand is
        encountered that is not confluent with the current &tau;-summand
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_c;</term>
    <term>&opt_counter_example;</term>
    <listitem>
      <para>
        Give a valuation for which the confluence
        condition does not hold, in case the
        encountered condition is neither a
        contradiction nor a tautolgy
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_p;</term>
    <term>&opt_print_dot;</term>
    <listitem>
      <para>
        Save a .dot file of the resulting BDD in
        case two summands cannot be proven
        confluent. PREFIX will be used as prefix
        of the output files
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_h;</term>
    <term>&opt_help;</term>
    <listitem>
      <para>
        Display help message and terminate
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_version;</term>
    <listitem>
      <para>
        Display version information and terminate
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_q;</term>
    <term>&opt_quiet;</term>
    <listitem>
      <para>
        Do not display warning messages
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_v;</term>
    <term>&opt_verbose;</term>
    <listitem>
      <para>
        Display concise intermediate messages
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_d;</term>
    <term>&opt_debug;</term>
    <listitem>
      <para>
        Display detailed intermediate messages
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_r;</term>
    <term>&opt_rewrite_strategy;=&strategy;</term>
    <listitem>
      <para>
        Use the specified &strategy; as rewrite
        strategy:
        <itemizedlist spacing='compact'>
          <listitem>
            <para>
              &strat_inner_string; for the innermost rewrite strategy
            </para>
          </listitem>
          <listitem>
            <para>
              &strat_innerc_string; for the compiled innermost rewrite strategy
            </para>
          </listitem>
          <listitem>
            <para>
              &strat_jitty_string; for the jitty rewrite strategy
            </para>
          </listitem>
          <listitem>
            <para>
              &strat_jittyc_string; for the compiled jitty rewrite strategy
            </para>
          </listitem>
        </itemizedlist>
        By default, the jitty rewrite strategy is used
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_t;</term>
    <term>&opt_time_limit;=&seconds;</term>
    <listitem>
      <para>
        Spend at most the specified number of &seconds; on proving
        a single formula
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_z;</term>
    <term>&opt_smt_solver;=&solver;</term>
    <listitem>
      <para>
        Use the specified &solver; to remove inconsistent paths from BDDs:
        <itemizedlist spacing='compact'>
          <listitem>
            <para>
              &solver_ario_string; for the SMT solver Ario
            </para>
          </listitem>
          <listitem>
            <para>
              &solver_cvc_lite_string; for the SMT solver CVC Lite
            </para>
          </listitem>
        </itemizedlist>
        By default, no path elimination is applied
      </para>
    </listitem>
  </varlistentry>

  </variablelist>
</para>
</refsect1>

<refsect1>
<title>Author</title>
<para>
  Written by Luc Engelen. Please send all complaints, comments and bug
  reports to <email>bug@mcrl2.org</email>.
</para>
</refsect1>

</refentry>
