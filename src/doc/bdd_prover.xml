<refentry id="bdd_prover">

 <info>
  <date>2005-2007</date>
 </info>

<refmeta>
 <refentrytitle>bdd_prover</refentrytitle>
 <manvolnum>7</manvolnum>
  <refmiscinfo class="source">bdd_prover</refmiscinfo>
  <refmiscinfo class="version"></refmiscinfo>
  <refmiscinfo class="manual">Library Functions</refmiscinfo>
</refmeta>

<refnamediv>
<refname>bdd_prover</refname>
<refpurpose>a class of mCRL2 provers that uses binary decision diagrams to prove formulas</refpurpose>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcprototype>
  <funcdef>&bdd_prover_constructor;</funcdef>
  <paramdef>&type_atermappl; &par_lpe;</paramdef>
  <paramdef>&type_rewrite_strategy; &par_rewrite_strategy; = &const_strat_jitty;</paramdef>
  <paramdef>&type_int; &par_time_limit; = 0</paramdef>
  <paramdef>&type_bool; &par_path_eliminator; = &const_false;</paramdef>
  <paramdef>&type_smt_solver_type; &par_solver_type; = &const_solver_type_ario;</paramdef>
  <paramdef>&type_bool; &par_apply_induction; </paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&type_virtual; &type_bool; &bdd_prover_is_tautology;</funcdef>
  <paramdef>&type_void;</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&type_virtual; &type_bool; &bdd_prover_is_contradiction;</funcdef>
  <paramdef>&type_void;</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&type_virtual; &type_atermappl; &bdd_prover_get_bdd;</funcdef>
  <paramdef>&type_void;</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&type_virtual; &type_atermappl; &bdd_prover_get_witness;</funcdef>
  <paramdef>&type_void;</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&type_virtual; &type_atermappl; &bdd_prover_get_counter_example;</funcdef>
  <paramdef>&type_void;</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>
<para>
  The term "formula" in the following text denotes arbitrary expressions of sort &sort_bool; in the mCRL2 format.
</para>
<para>
  A prover uses a rewriter to rewrite parts of the formulas it manipulates. The constructor &bdd_prover_constructor; initializes the prover's
  rewriter with the data equations in internal mCRL2 format contained in the LPE passed as parameter
  &par_lpe; and the rewrite strategy passed as parameter &par_rewrite_strategy;. The parameter &par_rewrite_strategy; can be set to either
  &const_strat_inner;, &const_strat_innerc;, &const_strat_jitty; or &const_strat_jittyc;. To limit the number of seconds spent on proving a single
  formula, a time limit can be set. If the time limit is set to 0, no time limit will be enforced.
  The parameter &par_apply_induction; indicates whether or induction on lists is applied.
  The constructor &bdd_prover_constructor; has two additional parameters, &par_path_eliminator; and &par_solver_type;. The parameter
  &par_path_eliminator; can be used to enable the use of an instance of the class &class_bdd_path_eliminator;. Instances of this class use an SMT
  solver to eliminate inconsistent paths from BDDs. The parameter &par_solver_type;
  can be used to indicate which SMT solver should be used for this task. Either the SMT solver &solver_ario; or &solver_cvc_lite; can be used.
  To use one of these solvers, the directory containing the corresponding
  executable must be in the path. On June the 20th of 2006, Ario 1.1 was available on &link_ario; and CVC Lite was available on &link_cvc;.
  If the parameter &par_path_eliminator; is set to &const_false;, the parameter &par_solver_type; is ignored and no instance of the class
  &class_bdd_path_eliminator; is initialized.
</para>
<para>
  The formula to be handled is set using the method &prover_set_formula; inherited from the class &class_prover;. An entity of the class
  &class_bdd_prover; uses binary decision diagrams to determine if a given formula is a tautology or a contradiction. The
  resulting BDD can be retreived using the method &bdd_prover_get_bdd;.
</para>
<para>
  The methods &bdd_prover_is_tautology; and &bdd_prover_is_contradiction; indicate whether or not a formula is a tautology or a
  contradiction. These methods will return &answer_yes;, &answer_no; or &answer_undefined;.
</para>
<para>
  If a formula is neither a tautology nor a contradiction according to the prover, a so called witness or counter example can be returned by the
  methods &bdd_prover_get_witness; and &bdd_prover_get_counter_example;. A witness is a valuation for which the formula holds, a counter example
  is a valuation for which it does not hold.
</para>
</refsect1>

<refsect1>
<title>Preconditions</title>
<para>
  The following precondition has to be satisfied for &bdd_prover_constructor;:
  <itemizedlist>
    <listitem>
      <para>
        the argument passed as parameter &par_time_limit; is greater than or equal to 0. If the argument is equal to 0, no time limit will be
        enforced
      </para>
    </listitem>
    <listitem>
      <para>the argument passed as parameter &par_lpe; is an LPE</para>
    </listitem>
  </itemizedlist>
</para>
<para>
  The following precondition has to be satisfied for &bdd_prover_is_tautology;, &bdd_prover_is_contradiction;,
  &bdd_prover_get_bdd;, &bdd_prover_get_witness; and &bdd_prover_get_counter_example;:
  <itemizedlist>
    <listitem>
      <para>the method &prover_set_formula; has been called</para>
    </listitem>
  </itemizedlist>
</para>
</refsect1>

<refsect1>
<title>Author</title>
<para>
  Written by Luc Engelen. Please send all complaints, comments and bug reports to <email>bug@mcrl2.org</email>.
</para>
</refsect1>

</refentry>
