<refentry id="confluence_checker">
 <info>
  <date>2005-2007</date>
 </info>

<refmeta>
 <refentrytitle>confluence_checker</refentrytitle>
 <manvolnum>7</manvolnum>
 <refmiscinfo class="source">confluence_checker</refmiscinfo>
 <refmiscinfo class="version"></refmiscinfo>
 <refmiscinfo class="manual">Library Functions</refmiscinfo>
</refmeta>

<refnamediv>
<refname>confluence_checker</refname>
<refpurpose>
  a class that checks which &tau;-summands of an mCRL2 LPE are confluent and marks them by renaming their &tau;-actions to &ctau;
</refpurpose>
</refnamediv>

<refsynopsisdiv>
<funcsynopsis>
<funcprototype>
  <funcdef>&confluence_checker_constructor;</funcdef>
  <paramdef>&type_atermappl; &par_lpe;</paramdef>
  <paramdef>&type_rewrite_strategy; &par_rewrite_strategy; = &strat_jitty;</paramdef>
  <paramdef>&type_int; &par_time_limit; = 0</paramdef>
  <paramdef>&type_bool; &par_path_eliminator; = &const_false;</paramdef>
  <paramdef>&type_smt_solver_type; &par_solver_type; = &const_solver_type_ario;</paramdef>
  <paramdef>&type_bool; &par_apply_induction; = &const_false;</paramdef>
  <paramdef>&type_bool; &par_no_marking; = &const_false;</paramdef>
  <paramdef>&type_bool; &par_check_all; = &const_false;</paramdef>
  <paramdef>&type_bool; &par_counter_example; = &const_false;</paramdef>
  <paramdef>&type_bool; &par_generate_invariants; = &const_false;</paramdef>
  <paramdef>&type_char_pointer; &par_dot_file_name; = 0</paramdef>
</funcprototype>
<funcprototype>
  <funcdef>&confluence_checker_check_confluence_and_mark;</funcdef>
  <paramdef>&type_atermappl; &par_invariant;, &type_int; &par_summand_number;</paramdef>
</funcprototype>
</funcsynopsis>
</refsynopsisdiv>

<refsect1>
<title>Description</title>
<para>
  Given an LPE,
  <literallayout>
    P(d: D) = ...
            + sum ei: Ei. ci(d, ei) -> ai(fi(d, ei)) . P(gi(d, ei))
            + ...
            + sum ej: Ej. cj(d, ej) -> tau . P(gj(d, ej))
            + ...;
  </literallayout>
  &tau;-summand <literal>j</literal> is confluent with summand <literal>i</literal> if the following condition holds
  for all <literal>d: D</literal>, for all <literal>ei: Ei</literal> and for all <literal>ej: Ej</literal>:
  <literallayout>
    (inv(d) /\ ci(d, ei) /\ cj(d, ej))
    =>
    (ci(gj(d, ej), ei) /\ cj(gi(d, ei), ej) /\ fi(d, ei) == fi(gj(d, ej), ei) /\ gi(gj(d, ej), ei) == gj(gi(d, ei), ej))
  </literallayout>
  where &inv; is the invariant specified using the parameter &par_invariant; of the function &confluence_checker_check_confluence_and_mark;.
  In case <literal>ai</literal> is also a &tau;-action, the formula above can be weakened to the following:
  <literallayout>
    (inv(d) /\ ci(d, ei) /\ cj(d, ej))
    =>
    (gi(d, ei) == gj(d, ej) \/ (ci(gj(d, ej), ei) /\ cj(gi(d, ei), ej) /\ gi(gj(d, ej), ei) == gj(gi(d, ei), ej)))
  </literallayout>
</para>

<para>
  The class &class_confluence_checker; can determine whether two summands are confluent
  in three ways and will indicate which of the methods was used while proving confluence.
  The three ways of determining confluence are as follows:
  <itemizedlist spacing='compact'>
    <listitem>
      <para>
        If summand number 1 has been proven confluent with summand number 2, summand
        number 2 is obviously confluent with summand number 1. This method of checking
        confluence is called checking confluence by symmetry. If two summands are
        confluent by symmetry, the class &class_confluence_checker; indicates this by
        printing a dot ('.').
      </para>
    </listitem>
    <listitem>
      <para>
        Another way of checking the confluence of two summands is determining whether
        the two summands are syntactically disjoint. Two summands are syntactically
        disjoint if the following holds:
        <itemizedlist spacing='compact'>
          <listitem>
            <para>
              The set of variables used by one summand is disjoint from the set
              of variables changed by the other summand and vice versa.
            </para>
          </listitem>
          <listitem>
            <para>
              The set of variables changed by one summand is disjoint from the set
              of variables changed by the other summand.
            </para>
          </listitem>
        </itemizedlist>
        If two summands are confluent because of syntactic disjointness, the class
        &class_confluence_checker; indicates this by printing a colon (':').
      </para>
    </listitem>
    <listitem>
      <para>
        The most time consuming way of checking the confluence of two summands is
        generating the confluence condition and then checking if this condition is a
        tautology using a prover for expressions of sort &sort_bool;. If two summands are
        proven confluent using the prover, the class &class_confluence_checker;
        indicates this by printing a plus sign ('+').
        If the parameter &par_generate_invariants; is set to &const_true;, the class
        &class_confluence_checker;
        will try to prove that the reduced confluence condition is an invariant of the LPE,
        in case the confluence condition is not a tautology. If the reduced confluence
        condition is indeed an invariant, the two summands are proven confluent.
        The class &class_confluence_checker; indicates this by printing an 'i'.
      </para>
    </listitem>
  </itemizedlist>
</para>

<para>
  The class &class_confluence_checker; uses an instance of the class &class_bdd_prover;, an instance of the class &class_disjointness_checker; and
  an instance of the class &class_invariant_checker;
  to determine which &tau;-summands of an mCRL2 LPE are confluent. Confluent &tau;-summands will be marked by renaming their &tau;-actions to
  &ctau;. The constructor &confluence_checker_constructor; initializes the BDD based prover with the parameters &par_rewrite_strategy;,
  &par_time_limit;,
  &par_path_eliminator;, &par_solver_type;, &par_apply_induction; and &par_lpe;. The
  parameter &par_rewrite_strategy; specifies which rewrite strategy is used by the prover's rewriter. It can be set to either
  &const_strat_inner;, &const_strat_innerc;, &const_strat_jitty; or &const_strat_jittyc;. The parameter &par_time_limit; specifies the maximum
  amount of time in seconds to be spent by the prover on proving a single expression. If &par_time_limit; is set to 0, no time limit will be 
  enforced.
  The parameter &par_path_eliminator; specifies whether or not path elimination is applied. When path elimination is applied, the prover uses an
  SMT solver to remove inconsistent paths from BDDs. The parameter &par_solver_type; specifies which SMT solver is used for path elimination. 
  Either
  the SMT solver &solver_ario-lnk; or &solver_cvc_lite-lnk; can be used.
  To use one of these solvers, the directory containing the corresponding
  executable must be in the path. If the parameter &par_path_eliminator; is set to &const_false;, the parameter &par_solver_type; is ignored. The parameter &par_apply_induction;
  indicates whether or not induction on list will be applied.
</para>
<para>
  The parameter &par_dot_file_name;
  specifies whether a file in dot format of the resulting BDD is saved each time the prover cannot determine whether an expression of sort
  &sort_bool; is a contradiction
  or a tautology. If the parameter is set to 0, no .dot files are saved. If a string is passed as parameter &par_dot_file_name;, this string will
  be used as the prefix of the filenames. An instance of the class &class_bdd2dot; is used to save these files in dot format.
</para>
<para>
  If the parameter &par_counter_example; is set to &const_true;, a so called counter example is printed to &stderr; each time the prover
  indicates that two summands are not confluent. A counter example is a valuation for which the confluence condition to be proven does not hold.
</para>
<para>
  If the parameter &par_check_all; is set to &const_true;, the confluence of the &tau;-summands regarding all other summands will be checked.
  If the parameter is set to &const_false;, &class_confluence_checker; continues with the next &tau;-summand as soon as a summand is encountered
  that is not confluent with the current &tau;-summand.
</para>
<para>
  If the parameter &par_generate_invariants; is set, an invariant checker is used to check if the reduced confluence condition is an invariant of
  the LPE passed as parameter &par_lpe;. If the reduced confluence condition is an invariant, the two summands are confluent.
</para>
<para>
  The function &confluence_checker_check_confluence_and_mark; returns an LPE with all &tau;-actions of confluent &tau;-summands renamed to &ctau;,
  unless the parameter &par_no_marking; is set to &const_true;. In case the parameter &par_no_marking; was set to &const_true;, the confluent
  tau-summands will not be marked, only the results of the confluence checking will be displayed.
</para>
<para>
  If there already is an action named &ctau; present in the LPE passed as parameter &par_lpe;, an error will be reported.
</para>
</refsect1>

<refsect1>
<title>Preconditions</title>
<para>
  The following precondition has to be satisfied for &confluence_checker_constructor;:
  <itemizedlist>
    <listitem>
      <para>the argument passed as parameter &par_lpe; is a valid mCRL2 LPE</para>
    </listitem>
    <listitem>
      <para>
        the argument passed as parameter &par_time_limit; is greater than or equal to 0. If the argument is equal to 0, no time limit will be
        enforced
      </para>
    </listitem>
  </itemizedlist>
</para>
<para>
  The following precondition has to be satisfied for &confluence_checker_check_confluence_and_mark;:
  <itemizedlist>
    <listitem>
      <para>
        the argument passed as parameter &par_invariant; is an expression of sort &sort_bool; in internal mCRL2 format
      </para>
    </listitem>
    <listitem>
      <para>
        the argument passed as parameter &par_summand_number; corresponds with a summands of the LPE passed as parameter &par_lpe;.
        It lies in the interval from and including 1 upto and including the highest summand number
      </para>
    </listitem>
  </itemizedlist>
</para>
</refsect1>

<refsect1>
<title>Author</title>
<para>
  Written by Luc Engelen. Please send all complaints, comments and bug reports to &bugmail;.
</para>
</refsect1>

</refentry>
