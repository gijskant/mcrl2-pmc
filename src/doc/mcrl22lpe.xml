<?xml version="1.0"?>

<!DOCTYPE webpage PUBLIC "-//Norman Walsh//DTD Website Full V2.6//EN" "http://docbook.sourceforge.net/release/website/current/schema/dtd/website-full.dtd" [
<!ENTITY mcrl22lpe "<command>mcrl22lpe</command>">
<!ENTITY option "<parameter>OPTION</parameter>">
<!ENTITY infile "<parameter>INFILE</parameter>">
<!ENTITY outfile "<parameter>OUTFILE</parameter>">
<!ENTITY format "<parameter>FORMAT</parameter>">
<!ENTITY internal "<parameter>internal</parameter>">
<!ENTITY basic "<parameter>basic</parameter>">
<!ENTITY advanced "<parameter>advanced</parameter>">
<!ENTITY opt_0 "<option>-0</option>">
<!ENTITY opt_1 "<option>-1</option>">
<!ENTITY opt_2 "<option>-2</option>">
<!ENTITY opt_3 "<option>-3</option>">
<!ENTITY opt_c "<option>-c</option>">
<!ENTITY opt_n "<option>-n</option>">
<!ENTITY opt_r "<option>-r</option>">
<!ENTITY opt_w "<option>-w</option>">
<!ENTITY opt_b "<option>-b</option>">
<!ENTITY opt_a "<option>-a</option>">
<!ENTITY opt_o "<option>-o</option>">
<!ENTITY opt_f "<option>-f</option>">
<!ENTITY opt_e "<option>-e</option>">
<!ENTITY opt_p "<option>-p</option>">
<!ENTITY opt_h "<option>-h</option>">
<!ENTITY opt_q "<option>-q</option>">
<!ENTITY opt_v "<option>-v</option>">
<!ENTITY opt_d "<option>-d</option>">
<!ENTITY opt_m "<option>-m</option>">
<!ENTITY opt_g "<option>-g</option>">
<!ENTITY opt_D "<option>-D</option>">
<!ENTITY opt_stack "<option>--stack</option>">
<!ENTITY opt_regular "<option>--regular</option>">
<!ENTITY opt_regular2 "<option>--regular2</option>">
<!ENTITY opt_alternative "<option>--alternative</option>">
<!ENTITY opt_cluster "<option>--cluster</option>">
<!ENTITY opt_no-cluster  "<option>--no-cluster</option>">
<!ENTITY opt_no-alpha "<option>--no-alpha</option>">
<!ENTITY opt_newstate "<option>--newstate</option>">
<!ENTITY opt_binary "<option>--binary</option>">
<!ENTITY opt_statenames "<option>--statenames</option>">
<!ENTITY opt_no-rewrite "<option>--no-rewrite</option>">
<!ENTITY opt_no-freevars "<option>--no-freevars</option>">
<!ENTITY opt_check-only "<option>--check-only</option>">
<!ENTITY opt_end-phase "<option>--end-phase</option>">
<!ENTITY opt_help "<option>--help</option>">
<!ENTITY opt_version "<option>--version</option>">
<!ENTITY opt_quiet "<option>--quiet</option>">
<!ENTITY opt_verbose "<option>--verbose</option>">
<!ENTITY opt_debug "<option>--debug</option>">
<!ENTITY opt_nosumelm "<option>--no-sumelm</option>">
<!ENTITY opt_nodeltaelm "<option>--no-deltaelm</option>">
<!ENTITY opt_delta "<option>--delta</option>">
<!ENTITY stdin "<constant>stdin</constant>">
<!ENTITY stdout "<constant>stdout</constant>">
]>

<webpage id="mcrl22lpe-web">
  <head><title>mcrl22lpe</title></head>

<refentry id="mcrl22lpe">

<refmeta>
  <refentrytitle>mcrl22lpe</refentrytitle>
  <manvolnum>1</manvolnum>
</refmeta>

<refnamediv>
  <refname>mcrl22lpe</refname>
  <refpurpose>translate a .mcrl2 file into a .lpe file</refpurpose>
</refnamediv>

<refsynopsisdiv>
  <cmdsynopsis>
    <command>&mcrl22lpe;</command>
    <arg choice="plain" rep="repeat"><arg choice="opt">&option;</arg></arg>
    <arg choice="opt">&infile;
    <arg choice="opt">&outfile;</arg>
    </arg>
  </cmdsynopsis>
</refsynopsisdiv>

<refsect1>
  <title>Description</title>
  <para>
    The tool &mcrl22lpe; translates an mCRL2 specification to a linear process equation
(LPE). The input is read from &infile; and the output is written to
    &outfile;. If &outfile; is not present,
    &stdout; is used. If &infile; is not present, &stdin; is used.
  </para>
  <para>
    The input consists of a behavioural description in mCRL2 (milli Common 
    Representation Language 2). For the language description see the tutorial
    Process Algebra and mCRL2, by
    J.F. Groote, A.H.J. Mathijssen, S.C.W. Ploeger, 
    M.A. Reniers, M.J. van Weerdenburg and J. van der Wulp to be found
    at <filename>www.mcrl2.org</filename>.
  </para>
  <para>
    The process in the input must be in parallel pCRL format. This means
    that it must consist of the parallel composition of a set of processes
    that are described using actions, conditions, sum operators, timing, sequential
    and alternative composition operators only. The parallel, communication
    and renaming operators can only be used on the outer level.
    Typical input examples are found in the directory <filename>examples</filename>
    of the mCRL2 repository.
  </para>
  <para>
    All datatypes needed for the linearisation will be added to the
    generated linear process. Furthermore, all the datatypes in the mCRL2 specification, 
    such as natural numbers, sets and functions,
    are translated to elementary sorts with only
    constructors, mappings and equations.
  </para>
  <para>
    For certain inputs, the tool mcrl22lpe can take a large amount of time.
    In some cases it will not terminate, for instance with a non terminating rewrite
    rules. The following options can be used to speed the linearisation up, at the
    expense of a less readable result.
  </para>
  <para>
    The option &opt_stack; avoids non termination if the process structure
    is not regular. The option &opt_no-rewrite; causes rewriting to be switched
    off, avoiding non termination due to non terminating rewrite rules.
    The option &opt_nosumelm; avoids the use of sum elimination, which under
    certain circumstances may take a lot of time.
    Finally, the option &opt_nodeltaelm; avoids removal of spurious
    delta summands, which uses a kwadratic algorithm in the number of 
    summands, and therefore, may be very time consuming.
  </para>
</refsect1>

<refsect1>
<title>Options</title>
<para>
  <variablelist>
  <varlistentry>
    <term>&opt_0;</term>
    <term>&opt_stack;</term>
    <listitem>
      <para>
        The LPE is generated using stack datatypes. The non parallel processes
        are transformed to restricted Greibach Normal Form and straightforwardly
        translated to linear processes using a stack. The resulting linear
        processes are then put in parallel. This works for
        any allowed input. Unfortunately, the linear process that is the
        result of this operation can basically only be used for state
        space generation. Symbolic operations on the stacks are generally
        not very effective, because the stack datatype is too complex. For
        symbolic analysis, the options &opt_regular; or &opt_regular2; can be used.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_1;</term>
    <term>&opt_regular;</term>
    <listitem>
      <para>
        The non parallel processes are translated to restricted Greibach
        Normal Form. Instead of using a stack, these processes are translated
        to an LPE with finite control variables. If
        some process has an infinite number of control states, the tool will
        attempt to generate all of them, causing
        it to run out of memory. In such a case the &opt_stack; 
        option can be used to produce a linear process.
      </para>
      <para>
        The &opt_regular; option is almost the same as the &opt_regular2; option.
        The only difference is in the way new process variables are generated:
        &opt_regular; generates less
        parameters in the linear process than &opt_regular;, but &opt_regular2; 
        generates an LPE in a few cases where the use of &opt_regular; leads to
        non-termination.
      </para>
      <para>
        The difference between the two is explained best by an example. 
        The tool &mcrl22lpe; sometimes has to replace a sequence of process
        variables by a single new variable. For instance, 
        P1(f(x)).P2(g(x)) must be replaced by a new process P.
        With the option &opt_regular;, the new process has a single parameter
        x, matching the single free variable x. I.e. the definition of P
        is P(x)=P1(f(x)).P2(g(x)). With the option &opt_regular2; a
        variable is introduced for every term. In this latter 
        case P is defined by
        P(y,z)=P1(y).P2(z) and the expression P1(f(x)).P2(g(x)) is replaced by
        P(f(x),g(x)). 
      </para>
      <para>
        We give an example in which linearisation with &opt_regular; fails
        to terminate and the use of &opt_regular2; succeeds. Consider the 
        process definition 
           proc P(n:Nat)=a.P(n+1)+b
        and let the initial process be defined by
           init P(0).delta.
        Now with &opt_regular; infinitely many new processes are generated namely
        one for each of the following form:
        P(0).delta, P(1).delta, etc. With &opt_regular2; only one new process
        is generated, namely one for P(n).delta.
      </para>
      <para>
        The option &opt_regular; is used by default.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_2;</term>
    <term>&opt_regular2;</term>
    <listitem>
      <para>
        See the explanation of &opt_regular;.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_3;</term>
    <term>&opt_alternative;</term>
    <listitem>
      <para>
        This option causes the use of a classical method of linearisation that can handle
        a wider range of specifications than &opt_regular;. 
        In essence it calculates Milner's expansion and introduces new
        processes for the process expression after the initial actions.
        These are in turn expanded again. 
      </para> 
      <para>
        This technique can handle any mCRL2 specification
        as long as there are only a finite number of processes involved.
        It cannot handle time and does not accept the &opt_cluster; and
        &opt_no-freevars; options.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_c;</term>
    <term>&opt_cluster;</term>
    <listitem>
      <para>
        This option causes the output linear process to be clustered.
        This option is not used by default. Clustering means that
        summands with the same action labels are taken together.
        For instance, a(f1).P(g1)+a(f2).P(g2) is replaced by 
        sum b:Bool.a(if(b,f1,f2)).P(if(b,g1,g2)). The advantage is
        that the number of summands can be reduced substantially in this
        way. The disadvantage is that sum operators are introduced and
        new data sorts with auxiliary functions are generated. In order to
        avoid the generation of new sorts, the option &opt_binary; can be
        used which causes all new sorts to be encoded using booleans.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_n;</term>
    <term>&opt_no-cluster;</term>
    <listitem>
      <para>
        This option prevents clustering of linear processes before they
        are put in parallel. By default these processes are clustered to 
        avoid a blow-up in the number of summands when transforming two
        parallel linear processes into a single linear process.
        If a linear process with M summands is put in parallel
        with a linear process with N summands the resulting process has M*N+M+N 
        summands. Both M and N can be substantially reduced by clustering
        at the cost of introducing new sorts and functions.
        See &opt_cluster;, esp. for a short explanation
        of the clustering process.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_r;</term>
    <term>&opt_no-alpha;</term>
    <listitem>
      <para>
        By default &mcrl22lpe; attempts to distribute communication, hiding and
        allow operators over the parallel composition operator as this reduces the size
        of intermediate linear processes. By using this option, this step can be
        avoided. The name stems from the alphabet axioms in process algebra.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_w;</term>
    <term>&opt_newstate;</term>
    <listitem>
      <para>
        The sort of state variables is by default Pos, i.e. positive
        natural numbers. By using this option new finite sorts named Enumk
        are generated where k is the size of the domain. Also, auxiliary case functions
        and equalities are defined. In combination
        with the option &opt_binary; the finite sorts are encoded by booleans.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_b;</term>
    <term>&opt_binary;</term>
    <listitem>
      <para>
        This option causes all generated finite sorts to be encoded using boolean.
        These finite sorts are
        generated when clustering and when generating state variables.
        See &opt_cluster; and &opt_newstate;.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_a;</term>
    <term>&opt_statenames;</term>
    <listitem>
      <para>
        Using this option, the names of generated data parameters are 
        extended with the name of the process in which they occur. In this
        way it is easier to determine where the parameter comes from.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_o;</term>
    <term>&opt_no-rewrite;</term>
    <listitem>
      <para>
        This option prevents intermediate rewriting of terms. This is
        especially useful when the equations in the input specification
        are not terminating, as in this case the lineariser will not
        terminate. 
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_f;</term>
    <term>&opt_no-freevars;</term>
    <listitem>
      <para>
        When linearising, there are several places where the values
        of data variables are irrelevant for the behaviour of the 
        process. E.g. when linearising the process 
        X=sum d:D.read(d).send(d).X, the value of the variable d has
        no meaning after the send action. In this case a 'free variable'
        is introduced to indicate that the value of this variable can
        be chosen freely. As the number of free variables can be 
        quite large, the generation of such variables can be 
        avoided by using this option. In this case a
        dummy value is chosen, which is the same for each sort.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_m;</term>
    <term>&opt_nosumelm;</term>
    <listitem>
      <para>
        This option causes the linearisation to avoid sum 
        elimination. If there is a condition or part of a condition
        of the form x=t with x a variable bound in a sum operator, then
        the term t can often be substituted for x, and the sum over x can
        be removed. Sometimes searching for equations x=t can
        be very time consuming. Using thed flag &opt_nosumelm;
        sum elimination can be switched off.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_g;</term>
    <term>&opt_nosumelm;</term>
    <listitem>
      <para>
        With this option the linearisation will not attempt to remove
        spurious delta summands. Due to the existence of time, delta
        summands cannot be omitted. Due to the presence of
        multi-actions the number of summands can be huge. The algorithm
        for removing delta summands simply works by comparing each delta
        summand with each other summand to see whether the condition of
        the one implies the condition of the other. Clearly, this has
        kwadratic complexity, and can a long time.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_D;</term>
    <term>&opt_delta;</term>
    <listitem>
      <para>
         With this option a (untimed) delta summand is added to each
         state of each process. This influences the behaviour of timed processes in 
         the sense that processes can also choose to idle, without being forced to
         perform an action. For untimed processes this was already the case, and
         there is no effect on the semantics. The advantage of this option is that
         the delta can subsume all other conditional and timed delta's reducing the
         number of delta summands in the resulting linear process. Furthermore, as
         processing delta summands can be very time consuming, this option can
         make linearisation substantially faster.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_e;</term>
    <term>&opt_check-only;</term>
    <listitem>
      <para>
        Using this option &mcrl22lpe; only checks the syntax and the 
        static semantics of the input, but it will not execute the linearisation
        process. This is useful to check whether the input is proper mCRL2.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_p;</term>
    <term>&opt_end-phase;=PHASE</term>
    <listitem>
      <para>
        This option causes the linearisation to stop after a particular phase.
        Phases can be 'pa' (parse), 'tc' (type check), 'ar' (alphabet reduction)
        or 'di' (data implementation). This option is primarily provided for 
        debugging and developing purposes.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_h;</term>
    <term>&opt_help;</term>
    <listitem>
      <para>
        Display a help message.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_version;</term>
    <listitem>
      <para>
        Display version information.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_q;</term>
    <term>&opt_quiet;</term>
    <listitem>
      <para>
        Do not display warning messages. 
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_v;</term>
    <term>&opt_verbose;</term>
    <listitem>
      <para>
        Display short intermediate messages.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_d;</term>
    <term>&opt_debug;</term>
    <listitem>
      <para>
        Display detailed intermediate messages.
      </para>
    </listitem>
  </varlistentry>
  </variablelist>
</para>
</refsect1>

<refsect1>
<title>Author</title>
<para>
  Written by Jan Friso Groote. Please send all complaints, comments and bug fixes
  to <email>bug@mcrl2.org</email>.
</para>
</refsect1>

</refentry>
</webpage>
