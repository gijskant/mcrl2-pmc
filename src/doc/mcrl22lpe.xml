<?xml version="1.0"?>

<!DOCTYPE refentry PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN" "http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"[
<!ENTITY mcrl22lpe "<function>mcrl22lpe</function>">
<!ENTITY option "<parameter>OPTION</parameter>">
<!ENTITY infile "<parameter>INFILE</parameter>">
<!ENTITY outfile "<parameter>OUTFILE</parameter>">
<!ENTITY format "<parameter>FORMAT</parameter>">
<!ENTITY internal "<parameter>internal</parameter>">
<!ENTITY basic "<parameter>basic</parameter>">
<!ENTITY advanced "<parameter>advanced</parameter>">
<!ENTITY opt_0 "<option>-0</option>">
<!ENTITY opt_1 "<option>-1</option>">
<!ENTITY opt_2 "<option>-2</option>">
<!ENTITY opt_3 "<option>-3</option>">
<!ENTITY opt_c "<option>-c</option>">
<!ENTITY opt_n "<option>-n</option>">
<!ENTITY opt_r "<option>-r</option>">
<!ENTITY opt_w "<option>-w</option>">
<!ENTITY opt_b "<option>-b</option>">
<!ENTITY opt_a "<option>-a</option>">
<!ENTITY opt_o "<option>-o</option>">
<!ENTITY opt_f "<option>-f</option>">
<!ENTITY opt_e "<option>-e</option>">
<!ENTITY opt_p "<option>-p</option>">
<!ENTITY opt_h "<option>-h</option>">
<!ENTITY opt_q "<option>-q</option>">
<!ENTITY opt_v "<option>-v</option>">
<!ENTITY opt_d "<option>-d</option>">
<!ENTITY opt_stack "<option>--stack</option>">
<!ENTITY opt_regular "<option>--regular</option>">
<!ENTITY opt_regular2 "<option>--regular2</option>">
<!ENTITY opt_alternative "<option>--alternative</option>">
<!ENTITY opt_cluster "<option>--cluster</option>">
<!ENTITY opt_no-cluster  "<option>--no-cluster</option>">
<!ENTITY opt_no-alpha "<option>--no-alpha</option>">
<!ENTITY opt_newstate "<option>--newstate</option>">
<!ENTITY opt_binary "<option>--binary</option>">
<!ENTITY opt_statenames "<option>--statenames</option>">
<!ENTITY opt_no-rewrite "<option>--no-rewrite</option>">
<!ENTITY opt_no-freevars "<option>--no-freevars</option>">
<!ENTITY opt_check-only "<option>--check-only</option>">
<!ENTITY opt_end-phase "<option>--end-phase</option>">
<!ENTITY opt_help "<option>--help</option>">
<!ENTITY opt_version "<option>--version</option>">
<!ENTITY opt_quiet "<option>--quiet</option>">
<!ENTITY opt_verbose "<option>--verbose</option>">
<!ENTITY opt_debug "<option>--debug</option>">
<!ENTITY stdin "<constant>stdin</constant>">
<!ENTITY stdout "<constant>stdout</constant>">
]>

<refentry id="mcrl22lpe">

<refmeta>
  <refentrytitle>mcrl22lpe</refentrytitle>
  <manvolnum>1</manvolnum>
</refmeta>

<refnamediv>
  <refname>mcrl22lpe</refname>
  <refpurpose>translate a .mcrl2 file into a .lpe file</refpurpose>
</refnamediv>

<refsynopsisdiv>
  <cmdsynopsis>
    <command>&mcrl22lpe;</command>
    <arg choice="plain" rep="repeat"><arg choice="opt">&option;</arg></arg>
    <arg choice="opt">&infile;
    <arg choice="opt">&outfile;</arg>
    </arg>
  </cmdsynopsis>
</refsynopsisdiv>

<refsect1>
  <title>Description</title>
  <para>
    The tool &mcrl22lpe; translates an mcrl2 file to a linear process (i.e. an .lpe
    file). The source comes from &infile; and the result is written into
    &outfile;. If &outfile; is not present,
    &stdout; is used. If &infile; is not present, &stdin; is used.
  </para>
  <para>
    The input of consists of a behavioral description in mcrl2 (milli Common 
    Representation Language 2). For the language description see the directory
    articles (when this manual page was written, no proper tutorial reference to 
    mCRL2 was available). 
  </para>
  <para>
    The process in the input must be in parallel pCRL format. This means
    that it must consist of the parallel composition of a set of processes
    that are described using actions, conditions, sum operators, timing, sequential
    and alternative composition operators only. The parallel, communication,
    and renaming operators can only be used on the outer level.
    Typical input examples are found in the directory examples.
  </para>
  <para>
    All the datatypes needed for the linearisation will be added to the
    specification. Furthermore, all the complex datatypes in the mcrl2 
    specification are translated to elementary sorts with only
    constructors, mappings and equations.
  </para>
</refsect1>

<refsect1>
<title>Options</title>
<para>
  <variablelist>
  <varlistentry>
    <term>&opt_0;</term>
    <term>&opt_stack;</term>
    <listitem>
      <para>
        The LPE is generated using stack datatypes. The non parallel processes
        are transformed to restricted Greibach Normal Form and straightforwardly
        translated to linear processes using a stack. Then the resulting linear
        processes are put in parallel. This works for
        all allowed input. Unfortunately, the linear process that is the
        result of this operation can basically only be used for state
        space generation. Symbolic operations on the stacks are generally
        not very fruitful, because the stack datatype is too complex. For
        symbolic analysis, the flags &opt_regular; or &opt_regular2; must be used.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_1;</term>
    <term>&opt_regular;</term>
    <listitem>
      <para>
        The non parallel processes are translated to restricted Greibach
        Normal Forms. Instead of using a stack, these processes are translated
        to a LPEs with finite control variables. If
        some process has an infinite number of control states, the tool will
        attempt to generate all of them, causing
        this tool to run out of memory. In such a case the &opt_stack; 
        option should be used as it will produce a linear process.
      </para>
      <para>
        The &opt_regular; flag is almost the same as the &opt_regular2; flag.
        The only difference is in the way new process variables are generated.
        The essential difference boils down to &opt_regular; generating less
        parameters in the linear process, whereas &opt_regular2; will 
        generate an LPE in a few cases where the use of &opt_regular; leads to
        a loop.
      </para>
      <para>
        In difference between the two is best explained by an example. 
        The tool &mcrl22lpe; sometimes has to replace a sequence of process
        variables by a single new variable. For instance 
        P1(f(x)).P2(g(x)) must be replaced by a new process P.
        With the flag &opt_regular; the new process has a single parameter
        x, matching the single free variable x. I.e. the definition of P
        is P(x)=P1(f(x)).P2(g(x)). With the flag &opt_regular2; for every term a
        variable is introduced. In the latter case P will have the definition
        P(y,z)=P1(y).P2(z) and the expression P1(f(x)).P2(g(x)) is replaced by
        P(f(x),g(x)). 
      </para>
      <para>
        It is instructive to see where linearisation with &opt_regular; fails
        to terminate and the use of &opt_regular2; succeeds. Consider the 
        example 
        <simplelist type='inline'>
           <member>proc P(n:Nat)=a.P(n+1)+b; </member>
           <member>init P(0).delta;</member> 
        </simplelist>
        Here with the option &opt_regular; new processes are generated for
        P(0).delta, P(1).delta, etc. With &opt_regular; only one new process
        is generated, namely one for P(n).delta.
      </para>
      <para>
        The flag &opt_regular; is used by default.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_2;</term>
    <term>&opt_regular2;</term>
    <listitem>
      <para>
        see the explanation of &opt_regular;.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_3;</term>
    <term>&opt_alternative;</term>
    <listitem>
      <para>
        This causes the use of a classical method of linearisation that can handle
        a wider range of specifications than the flag &opt_regular;. 
        In essence it calculates Milner's expansion and introduces new
        processes for the process expression after the initial actions.
        These are in turn expanded again. 
      </para> 
      <para>
        This technique can handle mcrl2 processes in its full generality
        as long as there are only a finite number of processes involved.
        It cannot handle time and does not accept the &opt_cluster; and
        &opt_no-freevars; options.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_c;</term>
    <term>&opt_cluster;</term>
    <listitem>
      <para>
        This option causes the final linear process to be clustered.
        By default this is not carried out. Clustering means that
        summands with the same action labels are taken together.
        For instance a(f1).P(g1)+a(f2).P(g2) is replaced by 
        sum b:Bool.a(if(b,f1,f2)).P(if(b,g1,g2)). The advantage is
        that the number of summands can be reduced substantially in this
        way. The disadvantage is that sum operators are introduced and
        new sorts with auxiliary functions are generated. In order to
        avoid the generation of new sorts the flag &opt_binary; can be
        used, which will encode all the sorts using booleans.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_n;</term>
    <term>&opt_no-cluster;</term>
    <listitem>
      <para>
        This options prevents clustering of linear processes before they
        are put in parallel. By default these processes are clustered to 
        avoid a blow up in the number of summands when calculating the 
        parallel composition. If a process with n summands is put in parallel
        with a process with m summands the resulting process has m*n+m+n 
        summands. Both m and n can be substantially reduced by clustering
        at the cost of introducing new sorts and functions and by complicating
        the linear process. See also &opt_cluster;, esp. for a short explanation
        of the clustering process.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_r;</term>
    <term>&opt_no-alpha;</term>
    <listitem>
      <para>
        By default &mcrl22lpe; attempts to distribute communication, hiding and
        allow operators over the parallel operator as this reduces the size
        of intermediate linear processes. By using this flag, this step can be
        avoided. The name stems from the alphabet axioms in process algebra.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_w;</term>
    <term>&opt_newstate;</term>
    <listitem>
      <para>
        The sort of state variables is by default Pos, i.e. the sort of positive
        natural numbers. By using this flag new finite sorts of the form Enumk
        are generated with k the size of the domain. Also auxiliary case functions
        and equalities (with k*k defining equations) are defined. In combination
        with the flag &opt_binary; the finite sorts are encoded by booleans.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_b;</term>
    <term>&opt_binary;</term>
    <listitem>
      <para>
        This flag prevents the generation of finite sorts but instead
        causes these to be encoded using booleans. These finite sorts are
        generated when clustering and when generating state variables.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_a;</term>
    <term>&opt_statenames;</term>
    <listitem>
      <para>
        Using this flag, the names of generated data variables are 
        extended with the name of the process in which they occur. In this
        way it is easier to determine where the variable comes from.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_o;</term>
    <term>&opt_no-rewrite;</term>
    <listitem>
      <para>
        This flag prevents intermediate rewriting of terms. This is
        especially useful when the equations in the input specification
        are not terminating, as in this case the lineariser will not
        terminate. 
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_f;</term>
    <term>&opt_no-freevars;</term>
    <listitem>
      <para>
        When linearizing, there are several places where the values
        of data variables are irrelevant for the behaviour of the 
        process. E.g. when linearizing the process 
        X=sum d:D.read(d).send(d).X, the value of the variable d has
        no meaning after the send action. In this case a 'free variable'
        is introduced to indicate that the value of this variable can
        be freely chosen. As the number of free variables can be 
        quite large, the generation of such variables can be 
        avoided by using the flag &opt_no-freevars;. In this case a
        dummy value is chosen, which is the same for each sort.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_e;</term>
    <term>&opt_check-only;</term>
    <listitem>
      <para>
        Using this flag &mcrl22lpe; only checks the syntax and the 
        static semantics of the input, but it will not commence the linearisation
        process. This is useful to check whether the input is proper mcrl2.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_p;</term>
    <term>&opt_end-phase;=PHASE</term>
    <listitem>
      <para>
        This flag causes the linearisation to stop after a particular phase.
        Phases can be 'pa' (parse), 'tc' (type check), 'ar' (alphabet reduction)
        or 'di' (data implementation). This flag is primarily provided for 
        debugging and developing purposes.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_h;</term>
    <term>&opt_help;</term>
    <listitem>
      <para>
        Display a help message, indicating all the available flags.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_version;</term>
    <listitem>
      <para>
        Display version information and terminate.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_q;</term>
    <term>&opt_quiet;</term>
    <listitem>
      <para>
        Do not display warning messages. Especially provided for use
        with the websquadt tool.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_v;</term>
    <term>&opt_verbose;</term>
    <listitem>
      <para>
        Turn on the display of short intermediate messages.
      </para>
    </listitem>
  </varlistentry>

  <varlistentry>
    <term>&opt_d;</term>
    <term>&opt_debug;</term>
    <listitem>
      <para>
        Turn on the display of detailed intermediate messages.
      </para>
    </listitem>
  </varlistentry>
  </variablelist>
</para>
</refsect1>

<refsect1>
<title>Author</title>
<para>
  Written by Jan Friso Groote. Please send all complaints, comments and bug fixes
  to <email>bug@mcrl2.org</email>.
</para>
</refsect1>

</refentry>
