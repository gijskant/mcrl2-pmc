\documentclass{article}
\usepackage[UKenglish]{babel}
\usepackage{calc}
\usepackage{latexsym,amssymb,amsfonts,amsthm, amsmath}
\usepackage{float}
\usepackage{alltt}
\usepackage[top=3cm,left=3cm,bottom=3cm,right=3cm]{geometry}

\title{Interface Bridge from Command Line\\ to Higher Level (G)UI}

\newcommand{\spf}{the XML format }

\begin{document}
 \maketitle
 \section{Purpose}
  To develop a specification format that captures information about a tool such
  that:
  \begin{itemize}
   \item it is known what kind of functionality a tool provides,
   \item it is clear what objects (files, streams, ...) serve as its input,
   \item what objects are produced as output,
   \item a user interface --in general-- and a GUI --in particular-- can be
         automatically generated for configuration of the tool on top of a
         command line user interface.
  \end{itemize}
  Tools are command line programs, whose behaviour can be steered by command
  line options as well as some limited run-time interaction via simple dialogues.
  More complex programs, that require a lot of user interaction with rich
  dialogues, are excluded for the moment.
  \\[5pt]
  The primary means of communicating to a tool about what it should use as
  input and the names of what it should produce as output is passing arguments
  on the command line. Many existing tools operate in this fashion. However
  there is no standard way to do this. Typically a command line user interface
  --because that is what we are talking about-- looks different on for instance
  DOS then it does on UNIX systems. We will first introduce a conceptual
  framework for reasoning about command line user interfaces.
  \\[5pt]
  Note that everything that falls outside this framework is not be considered
  in our specification format. But we feel this is justified because the
  framework should already covers a very large class of existing command line
  interfaces.

 \section{Concepts} \label{sectionConcepts}
  Every tool has a name which is used to invoke it on the command prompt. This
  name is not interesting for our specification format. The reason is that we
  want to have a tool return a specification of its interface as a part of its
  behaviour. But if a tool is invoked then its name is already known... With a
  special command line switch: `\texttt{--sqi-interface}' the tool may return a
  specification of its interface and terminate.
  \\[5pt]
  To run a tool, a number of arguments is specified as a string, which
  represents a sequence of white-space separated arguments. So an argument is a
  sequence of characters that may contain white-space, but only if it is
  delimited by quotes. If we are not mistaking, this is the standard way of
  command line parameter passing.
  \\[5pt]
  Arguments can either be optional or mandatory. In many cases arguments
  themselves can have arguments.  And some sort of implicit type system is used
  to restrict the possible values of arguments. Often an implicit dependency
  relation is imposed on arguments. If argument A is specified then argument B
  is not allowed, and the tool will return an error (or worse, give a segmentation fault).
  \\[5pt]
  To bring some order into this chaos we will distinguish several classes of arguments.
  An argument is:
  \begin{itemize}
   \item an \emph{option} (e.g. `-r'),
   \item an \emph{option} with arguments (e.g. 5 in `-v 5'),
   \item an input or output object (file name, URI, ...),
   \item \emph{remaining argument}.
  \end{itemize}
  The context determines what class an argument is in.  Input and output
  objects are distinguished because they represent a commonly used special
  dependence to the system outside the tool.
  \\[5pt]
  An option may have can have multiple arguments associated with it which all
  directly follow the option.  It must be known beforehand how many arguments
  can be specified to each option and the \emph{type} of each of those
  arguments. Commonly a special character or white-space are used to separate
  an option from its arguments. For instance `-v 5' or `-v=5' for option v.
  Multiple arguments of options can also be separated by white-space or some
  predefined character.
  \\[5pt]
  The remaining arguments may also have a type and otherwise it is assumed to
  be a string. The possible primitive data types are:
  \begin{table}[H]
   \begin{tabular}{ll}
    string:        & an arbitrary sequence of characters, \\
    enumeration:   & a predefined finite set of strings, \\
    integer:       & an arbitrary sequence of digit characters (decimal notation assumed), \\
    real:          & an integer optionally followed by the decimal separator `.' and another integer \\
    list:          & an arbitrary sequence of strings separated by a predefined character and/or white-space.
   \end{tabular}
   \label{primitive_datatypes}
  \end{table}

  \subsection{Focus}
   \noindent At this point we are going to restrict ourselves to command line
   interfaces that follow this pattern. Somewhat more precisely, for any tool,
   the possible combinations of command line arguments that are needed to
   unlock any desired functionality of a tool should somehow `fit' the pattern
   described this section. More precisely, any desired combination of
   command line arguments should follow the suggested syntax (expressed as EBNF).
  \begin{alltt}
 \(\langle\)arguments\(\rangle\)        \(::=\) \(\langle\)argument\(\rangle\) [ \(\langle\)white-space\(\rangle\) \(\langle\)arguments\(\rangle\) ]
 \(\langle\)argument\(\rangle\)         \(::=\) \(\langle\)option\(\rangle\)
 \(\langle\)argument\(\rangle\)         \(::=\) \(\langle\)object\(\rangle\)
 \(\langle\)argument\(\rangle\)         \(::=\) \(\langle\)simple-argument\(\rangle\)
 \(\langle\)option\(\rangle\)           \(::=\) \(\langle\)identifier\(\rangle\) [ \(\langle\)option-separator\(\rangle\) \(\langle\)option-arguments\(\rangle\) ]
 \(\langle\)identifier\(\rangle\)       \(::=\) \(\langle\)non-white-space-character\(\rangle\) \(\langle\)non-white-space-character\(\rangle\)\(\sp{*}\)
 \(\langle\)option-separator\(\rangle\) \(::=\) \(\langle\)white-space\(\rangle\) [ \(\langle\)identifier\(\rangle\) [\(\langle\)white-space\(\rangle\)] ]
 \(\langle\)option-arguments\(\rangle\) \(::=\) \(\langle\)simple-argument\(\rangle\) [ \(\langle\)common-separator\(\rangle\) \(\langle\)simple-argument\(\rangle\) ]
 \(\langle\)object\(\rangle\)           \(::=\) \(\langle\)identifier\(\rangle\)\end{alltt}

   \noindent Think of an \emph{object} for instance as being a URI. Furthermore
   a \emph{option-separator} is commonly substantial white-space or `=' for
   instance.  Similarly the \emph{common-separator} is usually chosen to be
   either substantial white-space or `,'. And finally, the
   \emph{simple-argument} is an instance of one of the `data types' informally
   described in figure \ref{primitive_datatypes}.

 \section{Requirements}
  The previous chapter end with an implicit description of the the class of
  command line user interfaces that we will focus on in this document.  The
  syntax of the command line argument string that a tool accepts provides clues
  for human beings about how to operate a tool. A lot of information about how
  to actually use a tool, however, often remains implicit. What kind of
  additional information that is needed, in view of our goal, is explored in this
  section.
  \\[5pt]
  Note that so far our interface description is very much targeted at command
  line argument passing, which might not be needed anymore when other methods
  of passing arguments become available. The concepts presented in the previous
  section should easily carry over to different ways of argument passing. In a
  way, it will always remain more difficult to interface with a tool interface
  that was developed for human beings, than one that was invented with machine
  communication in mind. Many existing tools follow the former scheme however...

  \subsection{Information on Input and Output Objects}

  Picture a GUI that offers use of a substantial amount of different tools that
  are invoked solely by combining data guided by the interface specification we
  develop here. It becomes important to classify tools by functionality, and to
  manage the input objects and output objects. This information all has to be
  available to successfully integrate a tool with such a GUI. Instead of ad-hoc
  coupling of the tool we want to put this information into the interface
  definition.
  \\[5pt]
  Issues that have not yet been considered but are important are:
  \begin{itemize}
   \item the format used for an output and especially input objects
   \item dependencies among arguments
   \item a range of the integers or reals as type
   \item for convenience: a default value for a type
  \end{itemize}
  In turn each of these points will be discussed next.

  \subsection{Information on Input and Output Objects}
   A tool that operates on files in format A simply might not work with format B
   (unless B is somehow contained in A).  At the GUI level this can be expressed
   by a file selector dialogue that filters out files with types other than those
   that are compatible with format A. To do this the information that the input
   file should be of type A --which is potentially invisible from the name of a
   file-- is required.

  \subsection{Restrictions on data-types}
   If an argument of type integer or real is requested, sometimes only a
   specific subset of the integers or reals is actually expected. To allow
   specification of arbitrary of subsets would be overkill.  How to verify in a
   generic way that an even number, prime number, or Fibonacci number should be
   specified. A simple range specified by an optional upper bound and lower
   bound seems to be a good compromise.
   \\[5pt]
   For certain widgets, for instance a drop down box, it is convenient to have a
   default value that can be preselected. Suppose that a user wants to specify the
   '-v' option that has a required integer parameter. Then a generated GUI can
   be left to choose the default, which would undoubtedly be 0.

  \subsection{Argument Conditions}

   Because we want to generate GUI dialogues from the information
   contained in our interface specification it is important to know about
   restrictions on what arguments can occur together with what other arguments.
   A bad GUI does not protect a user from making such easily avoided mistakes. A
   better choice between available widgets can be made with such information in
   order to make it more difficult for users to select conflicting options.
   \\[5pt]
   The restrictions on the presence of arguments will be made explicit by means
   of conditions. Which --at this point-- we consider to be Boolean formulae
   where the variables each, represent the presence of a particular argument on
   the command line.
   \\[5pt]
   Note that in addition, the conditions can also express that arguments other
   than options or arguments of options must be specified in combination with an
   option. For instance if the '-r' option is given then an input file must also
   have been specified as argument.

  \subsection{Categorising}

   Given the description in the first section about the purpose of this
   specification format it isn't obvious as what this section is doing here.  In
   view of a grand tool that is used to integrate the functionality provided by
   numerous other tools it is nice to be able to categorise tools by their
   function. Since this specification format is needed in such a context, and
   since the category to which a tool is assigned is potentially coupled to
   what arguments are specified on the command line we feel it's appropriate to
   talk about tool categories.
   \\[5pt]
   One might argue that this is not something that belongs here. There is
   however a very good reason to want such information here. A tool can behave
   in different ways depending on command line arguments. This also means that
   the tool could be categorised differently depending on the communication
   performed through the interface of a tool. Because such information is
   generic and useful, from our point of view, we want to address it
   explicitly.
   \\[5pt]
   A tools category puts forth certain expectations about the output it
   produces and the input it takes. The input and output object combinations
   determine the categories to which a tool belongs. What category a tool
   should be assigned to potentially depends on the presence of options, the
   value of arguments of options and what input and output objects are
   specified. The actual mapping to categories should be possible with
   information available in a tools command line interface specification.
   \\[5pt]
   For instance there is a category of \emph{analysers}, which are tools that
   perform a analysis on specifications and report the results.  Another
   category of tools are \emph{transformers}, that transform specifications
   into other specifications. If a potentially large number of tools is
   available then such categories are invaluable because they speed up the
   process of finding the tool someone is looking for.
   \\[5pt]
   And finally, through proper use of categories, it should be possible to hide
   functionality of a tool that a user is not interested in at some point. This
   could lower the threshold for users that are not very familiar with the use
   of a tool that has much functionality. Of course there is always the issue
   that some people believe that tools that can do completely different things
   should actually be split up in tools that do one thing very well. In which
   case the category idea becomes redundant altogether...

 \section{Toward Implementation}

  An interface is a very important concept in architectural design.
  Considerable effort is put into getting interfaces right. Once an interface
  is stable it is not likely to change anymore. Except for possible extensions
  that result in backwards compatible behaviour with respect to the interface
  without the extension. In its own right the specification format we are
  designing for the purpose of describing tool interfaces serves as an
  interface as well.
  \\[5pt]
  We have chosen to use the eXtensible Markup Language (XML) for the new
  specification format. XML is an open standard for structuring documents with
  ever-increasing popularity and growing tool support on different platforms.
  Along with other open standards such as XSLT it is relatively easy to
  manipulate documents expressed in XML. For example a parser library that
  traverses the structure of any well-formed XML document is readily available
  for most modern programming languages.
  \\[5pt]
  The choice of XML is motivated by primarily by its ease of use and its
  popularity. The syntax of XML is properly defined which makes that anyone
  familiar with XML can at the very least read it. Furthermore standard tool support
  can be used to verify syntax, as well as conformance to an XML document type
  using the XML Schema standard. So validated parsing comes almost for free
  when once we have developed an XML Schema. And because it is XML it is
  relatively easy, using XSLT, to transform the XML for instance to an
  non-backwards compatible future version of this specification.
%  And finally, the XSLT tool support is available to convert between future
%  (extended) versions of the new specification format. A custom build language
%  and generated parser are likely more efficient, but it costs more effort to
%  create and maintain. Since efficiency does not play a large role here, XML
%  seems a straightforward choice.
  \\[5pt]
  In the end the construction of specifications for tool interfaces may be
  assisted by a computer program using a GUI. This should help to lower the
  threshold for tool developers to create such interface specifications.

 \section{Specification Format}
  
  This section is setup as follows. The central concepts that are directly
  translated to XML are discussed in a top to bottom fashion. For any such
  concept, the XML element with its possible attributes is explored, as well
  how they should be interpreted.

  \subsection{Data Types} \label{subsectionDataTypes}

   A primitive data type is one of the data types that was informally defined in
   \ref{sectionConcepts}. Since the introduction we have identified that it is
   nice to be able to restrict the domain of a type at some times. A small
   number of relatively simple restrictions is allowed. In a future version
   this may be extended, should the need arise.

   \subsubsection{Integer}

    An integer is a string that satisfies certain constraints that depend on
    the chosen numeric system. Attributes of the `integer' element:
    \begin{itemize}
     \item system: enumeration of: "binary", "octagonal", "decimal" and "hexadecimal",
     \item minimum: the integer number should be at least this,
     \item maximum: the integer number should be at most this.
    \end{itemize}
    All attribute are optional. If both the minimum and maximum attributes are
    present, then the minimum must be strictly smaller than the maximum. The
    element should be empty.
    \\[5pt]
    The XML schema definition:
 \begin{alltt} \scriptsize <xs:simpleType name="number-system">
   <xs:restriction base="xs:string">
    <xs:enumeration value="binary" />
    <xs:enumeration value="octagonal" />
    <xs:enumeration value="decimal" />
    <xs:enumeration value="hexadecimal" />
   </xs:restriction>
  </xs:simpleType>
  <xs:complexType name="integer">
   <xs:attribute name="system" type="xs:string" use="optional" />
   <xs:attribute name="minimum" type="xs:integer" use="optional" />
   <xs:attribute name="maximum" type="xs:integer" use="optional" />
  </xs:complexType>\end{alltt}
    A semantic condition that cannot be expressed into the XML
    schema, is that the minimum should be strictly smaller than the maximum, if
    both are specified.
    
   \subsubsection{Real}

    In practise a real number is an integer in decimal notation with optionally
    a decimal separator (.) that may occur anywhere between two decimal digits.
    Other numeric systems than the decimal systems are not available for the reals.
    Attributes of the `real' element:
    \begin{itemize}
     \item minimum: the real number should be at least this,
     \item maximum: the real number should be at most this.
    \end{itemize}
    The same restrictions hold as for the `integer' element.
    \\[5pt]
    The corresponding XML schema definition:
 \begin{alltt} \scriptsize <xs:complexType name="real">
   <xs:attribute name="minimum" type="xs:integer" use="optional" />
   <xs:attribute name="maximum" type="xs:integer" use="optional" />
  </xs:complexType>\end{alltt}
    And again it should hold that the minimum should be strictly smaller than
    the maximum, if both are specified.

   \subsubsection{Enumeration}

    Enumeration is a choice between a small fixed set of strings (the
    alternatives). The attributes of the `enumeration' element:
    \begin{itemize}
     \item minimum-selection: the minimum number of selected alternatives (default 1),
     \item maximum-selection: the maximum number of selected alternatives (default 1).
    \end{itemize}
    Again all attributes are optional, and the minimum-selection should be
    strictly smaller than the maximum-selection. Furthermore the `enumeration'
    element must contain `alternative' elements.
    \\[5pt]
    The corresponding XML schema definition:
 \begin{alltt} \scriptsize <xs:complexType name="alternative">
   <xs:simpleContent>
    <xs:extension base="xs:string">
    </xs:extension>
   </xs:simpleContent>
  </xs:complexType>
  <xs:complexType name="enumeration">
   <xs:sequence>
    <xs:element name="alternative" type="alternative" minOccurs="1" maxOccurs="unbounded" />
   </xs:sequence>
   <xs:attribute name="minimum-selection" type="xs:integer" use="optional" />
   <xs:attribute name="maximum-selection" type="xs:integer" use="optional" />
  </xs:complexType>\end{alltt}
    A semantic condition is that the number of alternative elements that occur
    as child of an enumeration is at least equal to the value of the minimum
    selection attribute \emph{and} the value of the maximum-selection attribute
    may not be greater than the number of child elements.

   \subsubsection{String}

    A string denotes any sequence of characters. Potentially one would like to
    have regular expressions to denote a limited subset. Besides a restriction
    to an enumeration, or a minimum or maximum to the length of a string no
    further possibilities exist at this time to restrict the string data type.
    In a future version the PCRE library (for Perl compatible regular
    expression) might be adopted. But at this point the definition of a regular
    expression syntax seems to be a bridge too far.
    \\[5pt]
    Attributes of the `string' element:
    \begin{itemize}
     \item minimum-length: a positive number that denotes the minimum length of the string,
     \item maximum-length: a positive number that denotes the maximum length of the string,
    \end{itemize}
    All of these attributes are optional, and again the minimum should be
    strictly smaller than the maximum.
    \\[5pt]
    The corresponding XML schema definition:
 \begin{alltt} \scriptsize <xs:complexType name="string">
   <xs:attribute name="minimum-length" type="xs:integer" use="optional" />
   <xs:attribute name="maximum-length" type="xs:integer" use="optional" />
  </xs:complexType>\end{alltt}

   \subsubsection{List}

    A list is a complex type that was added because sometimes extra syntax is
    used that simply does not match that of any single data type discussed in
    this sub section. By default the elements of a list have no restriction on
    the type. So a list may contain integers as well as strings (in the end
    everything is converted to a string anyway). However specifying that a list
    may contain only elements of type integer is also possible.
    \\[5pt]
    Attributes of the `list' element:
    \begin{itemize}
     \item minimum-length: a positive number that denotes the minimum length of the list,
     \item maximum-length: a positive number that denotes the maximum length of the list,
     \item value-separator: a string used to separate the values passed as arguments, (default " ")
     \item left-delimiter: a string used to delimit an argument list, (default "")
     \item right-delimiter: a string used to delimit an argument list, (default "")
     \item left-value-delimiter: a string used to delimit an argument, (default "")
     \item right-value-delimiter: a string used to delimit an argument. (default "")
    \end{itemize}
    The left* and right* delimiters are used to explicitly delimit an argument.
    This can be used for instance to stop a shell from expanding arguments. The
    left and right value delimiter can be set to `'' such that \texttt{'*.o'} is not
    expanded by the shell (that would otherwise replace it by the files in the
    current working directory that match the pattern).
    \\[5pt]
    The corresponding XML schema definition:
 \begin{alltt} \scriptsize <xs:complexType name="list">
   <xs:sequence>
    <xs:choice minOccurs="1" maxOccurs="unbounded">
     <xs:element name="integer" />
     <xs:element name="real" />
     <xs:element name="enumeration" />
     <xs:element name="string" />
     <xs:element name="list" />
    </xs:choice>
   </xs:sequence>
   <xs:attribute name="minimum-length" type="xs:integer" use="optional" />
   <xs:attribute name="maximum-length" type="xs:integer" use="optional" />
   <xs:attribute name="left-separator" type="xs:string" use="optional" />
   <xs:attribute name="right-separator" type="xs:string" use="optional" />
   <xs:attribute name="left-value-separator" type="xs:string" use="optional" />
   <xs:attribute name="right-value-separator" type="xs:string" use="optional" />
  </xs:complexType>\end{alltt}
    And again the minimum must be strictly smaller than the maximum.  As an
    example consider the following specification with list:
 \begin{alltt} \scriptsize <list minimum-length="3" maximum-length="3" value-separator="," left-delimiter="[" right-delimiter="]"
     left-value-delimiter=" " right-value-delimiter=" ">
     <list value-separator="," left-delimiter="(" right-delimiter=")">
      <integer />
      <real />
     </list>
    <string />
   </list>\end{alltt}
    a valid instance would be: "[ (1,2.0) , astring ]".

  \subsection{Category}

   At the highest level in the specification format is a mode-of-operation, or
   the functional category in which the tool operates (e.g. visualisation).
   Categories can be nested, so as to describe sub categories. Categories
   contain a description of those program arguments that have meaning for the
   functionality offered by the tool in a mode of operation that matches this
   category.
   \\[5pt]
   Recall that the idea is to categorise a potentially large number of tools,
   such that a user is able to quickly find the tool with that functionality he
   or she searches.  Categories that are too large inhibit a user's progress. An
   implementation may ignore (sub) categories as desired.
   \\[5pt]
   For example for some tool the visualisation functionality might be triggered
   by a \texttt{--visualisation} switch, in which case the \texttt{-a} switch
   signals that a non-default clustering algorithm is used. Otherwise the tool
   would would just search for deadlocks, in which case the \texttt{-a} switch
   has no meaning. So \texttt{--visualisation} triggers a mode of operation,
   that allows it to be classified into the Visualisation category. And in this
   category it makes sense to be able to set the \texttt{-a} switch.
   \\[10pt]
   In \spf a category is specified by the `category' element that has
   the following attributes:
   \begin{itemize}
    \item name: the name of the category (mandatory).
   \end{itemize}
   The contents of this element may either be empty, contain category
   nodes, the argument nodes defined in the next subsection, and condition nodes.

  \subsection{Arguments}

   An argument describes a command line argument, in the context of some
   category. By means of conditions, that have yet to be defined, the
   dependencies with respect to the occurrence of other arguments is specified.
   An argument has a type which classifies it to one of the classes distinguished in section \ref{sectionConcepts}.
   \\[5pt]
   In \spf an argument is abstract and has concrete implementations for
   each of the distinguished argument classes. The different argument classes
   are described next. The following attributes are shared between the elements
   that represent the argument classes:
   \begin{itemize}
    \item id: unique identifier for this argument),
    \item use: one of "required" or "optional" (default "required").
   \end{itemize}
   All of these attributes are mandatory. Furthermore the first child element
   must be be the description element. This is an element with no attributes
   that describes the argument and its effect(s).

   \subsubsection{Basic Arguments} \label{subsubsectionBasicArguments}
%\textit{I have unfolded the type attribute, to create multiple argument elements.
%   This allows that the content of these argument classes be defined differently.
%   At the schema level this allows to constrain the syntax to that which has meaning.
%   For instance what is the semantics of: \\
%   \center{\texttt{`<argument type="input" ...></argument type="option" ...><argument></argument>'}.}
%   \\[5pt]
%   }
   Basic arguments are any of the primitive types, or a list of 
   \ref{sectionConcepts}. Each of the data types corresponds with an element.
   Each of those data-types has different properties so in XML we will model
   each type by its own element.
   \\[5pt]
   TODO argument multiplicity, or a combination of arguments, may be specified more than once...

   \subsubsection{Options}

    An option is a type of argument that may trigger different behaviour of a tool.
    Options can also take arguments, even a list of arguments. The number of
    arguments an option can take is either a small fixed number, or an unbounded
    number (a list).
    \\[5pt]
    In \spf an option is specified by the `option' element that has the
    following attributes in addition to the ones mentioned before:
    \begin{itemize}
     \item representation: the string that represents the command (e.g. "-a", "--a", "+a", ...), (mandatory)
     \item option-separator: a string used to separate the options from the arguments,
    \end{itemize}
    all attributes are optional, unless mentioned otherwise.
    \\[5pt]
    The `arguments' element may be specified as child of an `option' node.  If
    an `option' node has no children, then it takes no arguments. An arguments
    node has data types described in sub section \ref{subsectionDataTypes} as
    children. Each `arguments' node specifies a combination of argument types
    that is expected after this option.
    \\[5pt]
    To illustrate that it is still possible to specify an option that does not
    have a fixed arity so to say consider the following scenario.  Imagine a
    tool with a `-a' option that takes either two or three arguments.  Then it
    is still possible to specify two `-a' options one with two arguments and one
    with three and give them different identifiers, and specify in a condition
    that the options with the identifier are mutually exclusive.

  \subsubsection{Input/Output}

   In \spf a category is specified by the `item' element that has
   the following attributes:
   \begin{itemize}
    \item type: one of "input" or "output" (mandatory)
    \item format: a Mime-type or the name of a file format (mandatory).
   \end{itemize}
   The contents of the element is a URI that specifies an input or output location.

  \subsection{Conditions}

   Conditions provide the means to express that some combinations of arguments
   may not specified at the same time on the command line. When building a GUI
   for the tool this information can be used to hide or disable widgets that
   would result in running a tool with such conflicting command options.
   \\[5pt]
   A condition is a Boolean formula with as atoms whether an argument is
   specified on the command line (called \emph{active} for convenience). A
   combination in a category is valid if and only if all conditions evaluate to
   true. The `atom' has only the id attribute that should correspond with the
   id of an argument contained in the category.
   \\[5pt]
   The XML schema definition for a condition becomes:
 \begin{alltt} \scriptsize <xs:complexType name="condition">
   <xs:sequence>
    <xs:choice>
     <xs:element name="not"  type="condition"/>
     <xs:element name="and"  type="condition" minOccurs="2" maxOccurs="unbounded"/>
     <xs:element name="or"   type="condition" minOccurs="2" maxOccurs="unbounded"/>
     <xs:element name="atom" type="identifier"/>
    </xs:choice>
   </xs:sequence>
  </xs:complexType>\end{alltt}
  For example if 000 is the id of an option \texttt{-a}, then `\texttt{<not><atom
  id="000"></not>}' denotes that argument 000 is not active. If this is a
  condition then argument -a may not be specified in this category. An
  interesting question would be: why is an argument defined if it cannot be
  used?

 \section{Translation}

  How are the strings that can be executed as commands generated from the
  information contained in a specification in the format described in the
  previous section? If all conditions are satisfied, then the arguments that
  need to be present on the command line are taken in the order in which they
  are encountered and a single space is added as white space between arguments.
  \\[5pt]
  \ldots
  
\begin{alltt}
\end{alltt}

\section{Notes}
\subsection{Standing Issues}
\begin{itemize}
 \item We should find a proper name for this specification format.
 \item Using an XML name space for instance sqi looks good.
 \item Predefined names for categories and sub-categories.
 \item Should there be a data type for dates?
 \item Other common numeric representations: hexadecimal, octagonal, binary?
 \item Implementation hints for GUI applications.
\end{itemize}

\subsection{Undiscussed Things}
\begin{itemize}
 \item Adopted \texttt{sqi} as preliminary name of specification format.
 \item Options that may take a variable number of arguments.
 \item Multiplicity of arguments (an argument may be specified a number of times to increase effect).
\end{itemize}
\end{document}
